要实现应用程序之间的交互，我们需要一个能够在浏览器和Web服务器之间传递请求和响应的机制。  
由于请求和相应都是由 0 和 1 组成的数字信息，所以可以说，我们需要的是一种能够将数字信息搬运到指定目的地的机制。  
这种机制是由操作系统中的网络控制软件，以及交换机、路由器等设备分工合作来实现的，它的基本思路是将数字信息分割成一个一个的小块，然后装入一些被称为“包”（Packet）的容器中来运送。  
这个负责搬运数字信息的机制，再加上浏览器和Web服务器这些网络应用程序，这两部分就组成了网络。  

# 章节主要内容

## 第1章 Web 浏览器

首先介绍浏览器的工作方式，当输入网址时，浏览器就会按照一定的规则去分析这个网址的含义，然后根据其含义生成请求消息。  
接着浏览器就会委托操作系统中的网络控制软件将消息发送给服务器。  

## 第2章 协议栈、网卡

介绍探索搬运数据的机制。  
首先介绍协议栈（网络控制软件叫作协议栈）。这个软件会将从浏览器接收到的消息打包，然后加上目的地址等控制信息。  
接下来，协议栈会将包交给网卡（负责以太网或无线网络通信的硬件）。  
然后，网卡会将包转换为电信号并通过网线发送出去。这样一来，包就进入到网络之中了。  

## 第3章 集线器、交换机、路由器

本章假设客户端计算机是连接到家庭或公司的局域网中，然后再通过 ADSL 和光纤到户（FTTH）等宽带线路接入互联网。  
在这样的场景中，网卡发送的包会经过交换机等设备，到达用来接入互联网的路由器。路由器的后面就是互联网，网络运营商会负责将包送到目的地。  

## 第4章 接入网、网络运营商

数据从用来接入互联网的路由器出发，进入了互联网的内部。互联网的入口线路称为接入网。  
在骨干网中存在很多运营商和大量的路由器，这些路由器相互连接，组成一张巨大的网，而我们的网络包就在其中经过若干路由器的接力，最终被发送到目标Web服务器上。  

## 第5章 防火墙、缓存服务器

通过骨干网之后，网络包最终到达了 Web 服务器所在的局域网中。  
接着，它会遇到防火墙，防火墙会对进入的包进行检查。  
检查完之后，网络包接下来可能还会遇到缓存服务器。  
此外，在大型网站中，可能还会配备将消息分布到多台 Web 服务器上的负载均衡器，还有可能会使用通过分布在整个互联网中的缓存服务器来分发内容的服务。  
经过这些机制之后，网络包才会到达 Web 服务器。  

## 第6章 Web服务器

当网络包到达 Web 服务器后，数据会被解包并还原为原始的请求消息，然后交给 Web 服务器程序。  
接下来，Web 服务器程序分析请求消息的含义，并按照其中的指示将数据装入响应消息中，然后发回给客户端。  
  - 响应消息回到客户端的过程和之前我们介绍的过程正好相反。
当响应到达客户端之后，浏览器会从中读取出网页的数据并在屏幕上显示出来。  

# 涉及到的主要关键词

## 第1章 浏览器生成消息

浏览器、Web服务器、网址（URL）、HTTP、HTML、协议、URI、请求消息、解析器、Socket库、DNS服务器、域名  

## 第2章 用电信号传输TCP/IP数据

TCP/IP、套接字、协议栈、IP地址、端口号、包、头部、网卡、网卡驱动、MAC地址、以太网控制器、ICMP、UDP  

## 第3章 从网线到网络设备

局域网（LAN）、双绞线、串扰、中继式集线器、MDI、MDI-X、交换式集线器、全双工、半双工、碰撞、自动协商、路由器、  
路由表、子网掩码、默认网关、分片、地址转换、公有地址、私有地址  

## 第4章 通过接入网进入互联网内部

ADSL、FTTH、光纤、接入网、ADSL􀀀Modem集成式路由器、ATM、信元、正交振幅调制、分离器、DSLAM、宽带接入服务器、  
远程接入服务器、PPP、网络运行中心（NOC）、光纤、IX（Internet􀀀eXchange，互联网交换）  

## 第5章 服务器端的局域网中有什么玄机

防火墙、包过滤、数据中心、轮询、负载均衡器、缓存服务器、代理、代理服务器、内容分发服务、重定向  

## 第6章 请求到达Web服务器，响应返回浏览器

响应消息、多任务、多线程、虚拟目录、CGI、表单、访问控制、密码、数据格式、MIME  

# 第1章 浏览器生成消息——探索浏览器内部

## 热身问答

1. `http://www.nikkeibp.co.jp/`中的`www`只是Web服务器上的一种命名。  
   World Wide Web是Web的提出者最早开发的浏览器兼HTML编辑器的名字。  

2. 如果是`.com`、`.net`、`.org`、`.jp`（除`co.jp`、`ne.jp`等`xx.jp`格式的域名外）等没有对注册对象范围进行限制的域名，任何个人都可以申请注册。  
   - 在中国的情况，个人可以申请“`.cn`”域名，但“`.com.cn`”“`.net.cn`”等域名则是不开放给个人注册的。
   - 日本的域名体系中，`.jp`下级的域名用的是两个字母的命名，例如`.co.jp`、`.ne.jp`。
   此外，也有一种`.name`域名是专门为个人申请者准备的。  
   
3. 应用程序并不是自己去控制网络，而是委托操作系统来控制网络。  

## 看点

### 生成HTTP请求消息

用户在浏览器输入网址（URL） -\> 浏览器解析网址 -\> 浏览器根据网址含义生成请求信息

### 向DNS服务器查询Web服务器的IP地址

请求消息生成之后，浏览器会委托操作系统向 Web 服务器发送请求，但浏览器必须告诉操作系统接收方的 IP 地址才行，因此浏览器必须先查出 Web 服务器的 IP 地址。  
网址中只有 Web 服务器的域名，因此浏览器需要向 DNS 服务器查询域名对应的IP地址。  

### 全世界 DNS 服务器的大接力

全世界共有上万台 DNS 服务器，它们相互接力才能完成IP地址的查询，而它们进行接力的方法也是本章看点之一。  

### 委托协议栈发送消息

查询到 IP 地址之后，浏览器就可以将消息委托给操作系统发送给Web服务器了，但这个委托到底是如何完成的呢？这也是本章看点之一。  
理解了向操作系统进行委托时的规则，我们就能够明白做出某个委托时操作系统会给我们怎样的反馈，这可以说是相当于具体地理解了网络的潜在能力。  

## 生成 HTTP 请求消息

### 输入网址

#### 网址的定义

网址，准确来说应该叫 URL，是以`http://` 开头的那一串东西；  
实际上除了`http:`，网址还可以以其他一些文字开头，例如“`ftp:`、`file:`、`mailto:`等。  

浏览器是一个具备多种客户端功能的综合性客户端软件，因此它需要一些东西来判断应该使用其中哪种功能来访问相应的数据，而各种不同的 URL 就是用来干这个的，比如访问 Web 服务器时用`http:`，而访问 FTP 服务器下载和上传文件时用`ftp:`。  

#### 网址的格式

根据访问目标的不同，URL 的写法也会不同。  
  - 在访问 Web 服务器和 FTP 服务器时，URL 中会包含服务器的域名和要访问的文件的路径名等；
  - 发邮件的 URL 则包含收件人的邮件地址。
此外，根据需要，URL 中还会包含用户名、密码、服务器端口号等信息。  

##### URL的各种格式

用HTTP协议访问Web服务器时：  
|http://|user|:|password|@|www.glasscom.com|:80|/dir/file1.htm|  
|---|---|---|---|---|---|---|---|  
||用户名（可省略）||密码（可省略）||Web服务器域名|端口号（可省略）|文件的路径名|

用FTP协议下载和上传文件时：  
|ftp://|user|:|password|@|ftp.glasscom.com|:21|/dir/file1.htm|
|---|---|---|---|---|---|---|---|
|协议|用户名（可省略）||密码（可省略）||FTP服务器域名|端口号（可省略）|文件的路径名|

读取客户端计算机本地文件时:  
|file://|localhost|/c:/path/file1.zip|
|---|---|---|
||计算机名（可省略）|文件的路径名|

发送电子邮件时：  
|mailto:|tone@glasscom.com|
|---|---|
||邮件地址|

阅读新闻组的文章时:  
|news:|comp.protocols.tcp-ip|
|---|---|
||新闻组名|

尽管 URL 有各种不同的写法，但它们有一个共同点，那就是 URL 开头的文字，即`http:`、`ftp:`、`file:`、`mailto:`这部分文字都表示浏览器应当使用的访问方法。  
  - 访问 Web 服务器时应该使用 HTTP 协议；
  - 访问 FTP 服务器时则应该使用 FTP 协议。
因此，我们可以把这部分理解为访问时使用的协议类型。  
尽管后面部分的写法各不相同，但开头部分的内容决定了后面部分的写法，因此并不会造成混乱。  

> 1. HTTP：Hypertext Transfer Protocol，超文本传送协议。
  2. 协议：通信操作的规则定义称为协议（protocol）。

### 解析网址

浏览器要做的第一步工作就是对 URL 进行解析，从而生成发送给 Web 服务器的请求消息。  
具体步骤：  
1. 按照 URL 规格对字符串进行解析；
2. 将 URL 拆分为各个组成元素；
3. 分别理解各个元素的语义含义；
   - 主机名用于确定要访问的服务器；
   - 路径名用于确定服务器上要访问的具体资源位置。
4. 根据解析结果确定访问目标。

### 省略文件名的情况

URL 可以省略文件名，进一步省略目录名，再进一步省略结尾的`/`。这些写法都是允许的。  
当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是`/index.html`或者`/default.htm`这些文件。  

例：http://www.lab.glasscom.com/whatisthis  
一般来说，这种情况会按照下面的惯例进行处理：
如果Web 服务器上存在名为 whatisthis 的文件，则将 whatisthis 作为文件名来处理；  
如果存在名为 whatisthis 的目录，则将 whatisthis 作为目录名来处理。  

### HTTP 的基本思路

解析完 URL 之后，浏览器会使用 HTTP 协议来访问 Web 服务器。  

HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤，其基本思路非常简单。  
首先，客户端会向服务器发送请求消息。请求消息中包含的内容是“对什么”和“进行怎样的操作”两个部分。  
收到请求消息之后，Web 服务器会对其中的内容进行解析，通过 URI 和方法来判断“对什么”“进行怎样的操作”，并根据这些要求来完成自己的工作，然后将结果存放在响应消息中。  


#### URI 和方法

- 相当于“对什么”的部分称为 URI；
  - 一般来说，URI 的内容是一个存放网页数据的文件名或者是一个 CGI 程序的文件名，例如“/dir1/file1.html”“/dir1/program1.cgi”等。
  - 不过，URI 不仅限于此，也可以直接使用“http:”开头的 URL 来作为 URI。换句话说就是，这里可以写各种访问目标，而这些访问目标统称为URI。

- “进行怎样的操作”的部分称为方法。
  - 方法表示需要让 Web 服务器完成怎样的工作，其中典型的例子包括读取 URI 表示的数据、将客户端输入的数据发送给 URI 表示的程序等。

#### HTTP 的主要方法：  

|方法|含义|
|---|---|
|GET|获取 URI 指定的信息。如果 URI 指定的是文件，则返回文件的内容；如果 URI 指定的是 CGI 程序，则返回该程序的输出数据|
|POST|从客户端向服务器发送数据。一般用于发送表单中填写的数据等情况下|
|HEAD|和 GET 基本相同。不过它只返回 HTTP 的消息头（message header），而并不返回数据的内容。用于获取文件最后更新时间等属性信息|
|OPTIONS|用于通知或查询通信选项|
|PUT|替换 URI 指定的服务器上的文件。如果 URI 指定的文件不存在，则创建该文件|
|DELETE|删除 URI 指定的服务器上的文件|
|TRACE|将服务器收到的请求行和头部（header）直接返回给客户端。用于在使用代理的环境中检查改写请求的情况|
|CONNECT|使用代理传输加密消息时使用的方法|

除了表中的内容之外，HTTP 消息中还有一些用来表示附加信息的头字段。客户端向 Web 服务器发送数据时，会先发送头字段，然后再发送数据。不过，头字段属于可有可无的附加信息。  

#### 响应消息

在响应消息的开头有一个状态码，它用来表示操作的执行结果是成功还是发生了错误。  
  - 当我们访问 Web 服务器时，遇到找不到的文件就会显示出404 Not Found 的错误信息，其实这就是状态码。
状态码后面就是头字段和网页数据。响应消息会被发送回客户端，客户端收到之后，浏览器会从消息中读出所需的数据并显示在屏幕上。到这里，HTTP 的整个工作就完成了。  

#### 补充知识

上表列出的 HTTP 方法中最常用的就是`GET`方法，所以一般的访问过程是：  
1. 在请求消息中写上 GET 方法，然后在 URI 中写上存放网页数据的文件名“/dir1/file1.html”；
   - 表示我们需要获取 /dir1/file1.html 文件中的数据。
2. 当 Web 服务器收到消息后，会打开 /dir1/file1.html 文件并读取出里面的数据；
3. 将读出的数据存放到响应消息中，并返回给客户端；
4. 最后，客户端浏览器会收到这些数据并显示在屏幕上。

还有一个经常使用的方法就是`POST`，在表单中填写数据并将其发送给 Web 服务器时就会使用这个方法。
  - 当我们在网上商城填写收货地址和姓名，或者是在网上填写问卷时，都会遇到带有输入框的网页，而这些可以输入信息的部分就是表单。
1. 使用POST 方法时，URI 会指向 Web 服务器中运行的一个应用程序的文件名；
   - 典型的例子包括“index.cgi”“index.php”等。
2. 在请求消息中，除了方法和 URI 之外，还要加上传递给应用程序和脚本的数据；
   - 这里的数据也就是用户在输入框里填写的信息。
3. 当服务器收到消息后，Web 服务器会将请求消息中的数据发送给 URI 指定的应用程序；
4. Web 服务器从应用程序接收输出的结果，会将它存放到响应消息中并返回给客户端；
5. 最后，客户端浏览器会收到这些数据并显示在屏幕上。

前面两个方法属于 HTTP 的典型用法，除此之外的其他方法在互联网上几乎见不到使用的例子。  

如果只有 GET 和 POST 方法，我们就只能从 Web 服务器中获取网页数据，以及将网页输入框中的信息发送给 Web 服务器。  
而有了 PUT 和 DELETE 方法，就能够从客户端修改或者删除 Web 服务器上的文件。  
有了这些功能，我们甚至可以将 Web 服务器当成文件服务器来用。  
  - 当然，出于安全上的原因，或者是支持 GET 和 POST 之外的方法的客户端没有广泛普及之类的原因，一般我们并不会碰到这样的用法。

### 生成 HTTP 请求消息

对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。  
HTTP 消息在格式上是有严格规定的，因此浏览器会按照规定的格式来生成请求消息。  

#### HTTP 请求消息的格式

|内容|名称|
|<方法><空格><URI><空格><HTTP版本>|请求行|
|---|---|
|<字段名>:<字段值>|消息头|
|...|消息头|
|...|消息头|
|...|消息头|
|<空行>||
|<消息体>|消息体|

- 请求行：通过这一行可以大致了解请求的内容；  
- 消息头：每行包含一个头字段，用于表示请求的附加信息。消息头的行数根据具体情况可变，一直延伸到空行为止；  
- 消息体：包含客户端向服务器发送的数据，例如用 POST 方法向 Web 服务器发送的网页表单数据。  

#### 写一个请求消息

请求行的重点是最开头的方法，方法可以告诉 Web 服务器它应该进行怎样的操作。但是方法有很多种，必须先判断应该选用其中的哪一种。  
选择的关键在于浏览器的工作状态，浏览器并非只有在这一种场景下才会向 Web 服务器发送请求消息。  
  - 比如点击网页中的超级链接，或者在表单中填写信息后点击“提交”按钮，这些场景都会触发浏览器的工作，而选用哪种方法也是根据场景来确定的。  

在地址栏中输入网址并显示网页，应该使用 GET 方法。  
点击超级链接的场景中也是使用 GET 方法。  
如果是表单，在 HTML 源代码中会在表单的属性中指定使用哪种方法来发送请求，可能是 GET 也可能是 POST。  
  - GET 方法能够发送的数据只有几百个字节，如果表单中的数据超过这一长度，则必须使用 POST 方法来发送。

写好方法之后，加一个空格，然后写 URI。URI 部分的格式如下，一般是文件和程序的路径名。
  - /\<目录名\>/…/\<文件名\>

第一行的末尾需要写上 HTTP 的版本号，这是为了表示该消息是基于哪个版本的 HTTP 规格编写的。到此为止，第一行就结束了。  

第二行开始为消息头。  
  - 尽管通过第一行我们就可以大致理解请求的内容，但有些情况下还需要一些额外的详细信息，而消息头的功能就是用来存放这些信息；
  - 消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等；
    - 这些项目表示的都是非常细节的信息。
  - 消息头中的内容随着浏览器类型、版本号、设置等的不同而不同，大多数情况下消息头的长度为几行到十几行不等。

写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据。这一部分称为消息体，也就是消息的主体。  
  - 不过，在使用 GET 方法的情况下，仅凭方法和 URI，Web 服务器就能够判断需要进行怎样的操作，因此消息体中不需要填写任何数据。
  - 当使用 POST 方法时，需要将表单中填写的信息写在消息体中。

到此为止，请求消息的生成操作就全部完成了。  

### 发送请求后会收到响应

这里先粗略地了解一下：响应消息的格式以及基本思路和请求消息是相同的，差别只在第一行上。  
  - 在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错；
  - 状态码和响应短语表示的内容一致，但它们的用途不同；
  - 状态码是一个数字，它主要用来向程序告知执行的结果；
  - 相对地，响应短语则是一段文字，用来向人们告知执行的结果。

#### HTTP 状态码概要

状态码的第一位数字表示状态类型，第二、三位数字表示具体的情况。下表列举了第一位数字的含义。  

|状态码|含义|
|---|---|
|1xx|告知请求的处理进度和情况|
|2xx|成功|
|3xx|表示需要进一步操作|
|4xx|客户端错误|
|5xx|服务器错误|

返回响应消息之后，浏览器会将数据提取出来并显示在屏幕上，我们就能够看到网页的样子了。  
如果网页的内容只有文字，那么到这里就全部处理完毕了，但如果网页中还包括图片等资源，则还有下文。  

#### 当网页包含图片时

当网页中包含图片时，会在网页中的相应位置嵌入表示图片文件的标签的控制信息。  
浏览器会在显示文字时搜索相应的标签，当遇到图片相关的标签时，会在屏幕上留出用来显示图片的空间，然后再次访问 Web 服务器，  
按照标签中指定的文件名向 Web 服务器请求获取相应的图片并显示在预留的空间中。  
这个步骤和获取网页文件时一样，只要在 URI 部分写上图片的文件名并生成和发送请求消息就可以了。  

> 1 条请求消息中只能写 1 个 URI。如果需要获取多个文件，必须对每个文件单独发送 1 条请求。
  - 比如 1 个网页中包含 3 张图片，那么获取网页加上获取图片，一共需要向 Web 服务器发送 4 条请求。
  判断所需的文件，然后获取这些文件并显示在屏幕上，这一系列工作的整体指挥也是浏览器的任务之一，而 Web 服务器却毫不知情。
  Web 服务器完全不关心这 4 条请求获取的文件到底是 1 个网页上的还是不同网页上的，它的任务就是对每一条单独的请求返回 1 条响应而已。

## 向 DNS 服务器查询 Web 服务器的 IP 地址

### IP 地址的基本知识

生成 HTTP 消息之后，需要根据域名查询 IP 地址将其交给操作系统，然后委托操作系统将消息发送给 Web 服务器。  
  - 尽管浏览器能够解析网址并生成 HTTP 消息，但它本身并不具备将消息发送到网络中的功能，因此这一功能需要委托操作系统来实现。  

互联网和公司内部的局域网都是基于 TCP/IP 的思路来设计的，TCP/IP 的结构就是由一些小的子网，通过路由器连接起来组成一个大的网络。  
  - 这里的子网可以理解为用集线器连接起来的几台计算机，我们将它看作一个单位，称为子网；
  - 将子网通过路由器连接起来，就形成了一个网络。

在网络中，所有的设备都会被分配一个地址。这个地址就相当于现实中某条路上的“ ×× 号 ×× 室”。  
  - “号”对应的号码是分配给整个子网的，“室”对应的号码是分配给子网中的计算机的，这就是网络中的地址；
  - “号”对应的号码称为网络号，“室”对应的号码称为主机号，这个地址的整体称为 IP 地址。
通过 IP 地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。  

#### 消息传送的具体过程

在后面的章节中会详细讲解，现在先简单了解一下。  
- 发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上；  
- 接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器；    
  - 即消息再次经过子网内的集线器被转发到下一个路由器。
- 前面的过程不断重复，最终消息就被传送到了目的地。  

#### 实际的 IP 地址

实际的 IP 地址是一串 32 比特的数字，按照 8 比特（ 1 字节）为一组分成 4 组，分别用十进制表示然后再用圆点隔开。  
这就是我们平常经常见到的 IP 地址格式，但仅凭这一串数字我们无法区分哪部分是网络号，哪部分是主机号。  
  - 在 IP 地址的规则中，网络号和主机号连起来总共是 32 比特，但这两部分的具体结构是不固定的。  
  
##### 子网掩码
  
在组建网络时，用户可以自行决定网络号和主机号在 32 比特之间的分配关系，因此，我们还需要另外的附加信息来表示 IP 地址的内部结构。  
  - 这一附加信息称为子网掩码。  

子网掩码表示网络号与主机号之间的边界。  

例：  
`10.11.12.13/255.255.255.0`  

|IP 地址：|10.|1.|2.|3|
|---|---|---|---|---|
|子网掩码：|255.|255.|255.|0|

将上面的十进制转换成比特后:  
|IP 地址：|00001010.|00000001.|00000010.|00000011|
|---|---|---|---|---|
|子网掩码：|11111111.|11111111.|11111111.|00000000|

其中，子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号。  
这种写法太长，我们也可以把 1 的部分的比特数用十进制表示并写在 IP 地址的右侧。  
  - 写成`10.11.12.13/24`。

顺带一提，IP 地址中主机号部分的比特全部为 0 或者全部为 1 时代表两种特殊的含义。  
  - 主机号部分全部为 0 代表整个子网而不是子网中的某台设备；
  - 主机号部分全部为 1 代表向子网上所有设备发送包，即广播。

### 域名和 IP 地址并用的理由

TCP/IP 网络是通过 IP 地址来确定通信对象的，在网址中使用服务器名称而不是 IP 地址是因为服务器名称好记。  
而不用服务器名称来确定通信对象是因为 IP 地址长度为 4 字节即 32 比特，而域名最短几十个字节，最长甚至255字节，使用域名来确定定位会大大增加路由器的负担。  

于是，现在我们使用的方案是让人来使用名称，让路由器来使用 IP 地址。  
为了填补两者之间的障碍，需要有一个机制能够通过名称来查询 IP 地址，或者通过 IP 地址来查询名称，  
这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。这个机制就是 DNS。  

### Socket 库提供查询 IP 地址的功能

查询 IP 地址的方法非常简单，只要询问最近的 DNS 服务器“www.lab.glasscom.com 的 IP 地址是什么”就可以了，DNS 服务器会回答说“该服务器的 IP 地址为xxx.xxx.xxx.xxx”。  

#### DNS

##### 向 DNS 服务器发送查询消息

向 DNS 服务器发出查询，也就是向 DNS 服务器发送查询消息，并接收服务器返回的响应消息。  
换句话说，对于 DNS 服务器，我们的计算机上一定有相应的 DNS 客户端，而相当于 DNS 客户端的部分称为 DNS 解析器，或者简称解析器。  
通过 DNS 查询 IP 地址的操作称为域名解析，因此负责执行解析（resolution）这一操作的就叫解析器（resolver）了。  
  - 解析器实际上是一段程序，它包含在操作系统的 Socket 库中。  

###### Socket 库

库就是一堆通用程序组件的集合，其他的应用程序都需要使用其中的组件。  
  - 使用现成的组件搭建应用程序可以节省编程工作量；
  - 多个程序使用相同的组件可以实现程序的标准化。

Socket 库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是这个库中的其中一种程序组件。  
Socket 库是用于调用网络功能的程序组件集合。  

##### 通过解析器向 DNS 服务器发出查询

解析器的用法非常简单。Socket 库中的程序都是标准组件，只要从应用程序中进行调用就可以了。  
具体来说，在编写浏览器等应用程序的时候，只要写上解析器的程序名称以及 Web 服务器的域名就可以了，这样就完成了对解析器的调用。  

调用解析器后，解析器会向 DNS 服务器发送查询消息，然后 DNS 服务器会返回响应消息。  
响应消息中包含查询到的 IP 地址，解析器会取出IP地址，并将其写入浏览器指定的内存地址中。  
接下来，浏览器在向 Web 服务器发送消息时，只要从该内存地址取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统就可以了。  

根据域名查询 IP 地址时，浏览器会使用 Socket 库中的解析器。  

###### 解析器的内部原理

解析器内部是怎样工作的：  
1. 网络应用程序（在我们的场景中就是指浏览器）调用解析器时，程序的控制流程就会转移到解析器的内部；
2. 当控制流程转移到解析器后，解析器调用协议栈，控制流程再次转移，协议栈会执行发送消息的操作，然后会生成要发送给 DNS 服务器的查询消息并通过网卡发送给 DNS 服务器；
   - 解析器会根据 DNS 的规格，生成一条表示“请告诉我 www.lab.glasscom.com 的 IP 地址”的数据，并将它发送给 DNS 服务器；
   - 发送消息这个操作并不是由解析器自身来执行，而是要委托给操作系统内部的协议栈来执行。
3. 当DNS 服务器收到查询消息后，它会根据消息中的查询内容进行查询；
   - 如果要访问的Web 服务器已经在DNS 服务器上注册，那么这条记录就能够被找到，然后其 IP 地址会被写入响应消息并返回给客户端。
4. 接下来，消息经过网络到达客户端，再经过协议栈被传递给解析器；
5. 解析器读取出消息取出 IP 地址，并将 IP 地址传递给应用程序；
   - 实际上，解析器会将取出的 IP 地址写入应用程序指定的内存地址中。
6. 到这里，解析器的工作就完成了，控制流程重新回到应用程序（浏览器），现在应用程序已经能够从内存中取出 IP 地址了。

计算机的内部结构就是这样一层一层的。也就是说，很多程序组成不同的层次，彼此之间分工协作。  
当接到上层委派的操作时，本层的程序并不会完成所有的工作，而是会完成一部分工作，再将剩下的部分委派到下层来完成。  

顺带一提，向 DNS 服务器发送消息时，我们当然也需要知道 DNS 服务器的 IP 地址。只不过这个 IP 地址是作为 TCP/IP 的一个设置项目事先设置好的，不需要再去查询了。  
不同的操作系统中 TCP/IP 的设置方法也有差异，像 Windows 可以设置自动获得 DNS 服务器地址或主动分配一个，解析器会根据设置的 DNS 服务器 IP 地址来发送消息。  

####### 控制流程转移

一般来说，应用程序编写的操作内容是从上往下按顺序执行的，当到达需要调用解析器的部分时，对应的那一行程序就会被执行，应用程序本身的工作就会暂停。  
然后，Socket 库中的解析器开始运行，完成应用程序委托的操作。  
像这样，由于调用了其他程序，原本运行的程序进入暂停状态，而被调用的程序开始运行，这就是“控制流程转移”。  

## 全世界 DNS 服务器的大接力

### DNS 服务器的基本工作

DNS 服务器的基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响应。  
其中，来自客户端的查询消息包含以下 3 种信息：  
1. 域名；
   - 服务器、邮件服务器（邮件地址中@ 后面的部分）的名称。
2.  Class；
   - 在最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而Class 就是用来识别网络的信息；
   - 不过，如今除了互联网并没有其他的网络了，因此 Class 的值永远是代表互联网的 IN。
3. 记录类型。
   - 表示域名对应何种类型的记录。例如：
     - 当类型为 A 时，表示域名对应的是 IP 地址；
     - 当类型为 MX 时，表示域名对应的是邮件服务器；
     - 对于不同的记录类型，服务器向客户端返回的信息也会不同。

DNS 服务器上事先保存有前面这 3 种信息对应的记录数据，DNS 服务器就是根据这些记录查找符合查询请求的内容并对客户端作出响应的。  
DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址。  

例如，如果要查询 www.lab.glasscom.com 这个域名对应的 IP 地址，客户端会向 DNS 服务器发送包含以下信息的查询消息。  
（a） 域名 = www.lab.glasscom.com；  
（b） Class = IN；  
（c） 记录类型 = A。  
然后，DNS 服务器会从已有的记录中查找域名、Class 和记录类型全部匹配的记录。  

### 域名的层次结构

如果是在像公司内部网络这样Web 和邮件服务器数量有限的环境中，所有的信息都可以保存在一台 DNS 服务器中，其工作方式也就完全符合我们前面讲解的内容。  
然而，互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台 DNS 服务器中是不可能的，因此一定会出现在 DNS 服务器中找不到要查询的信息的情况。  

此时 DNS 服务器的工作方式：  
将信息分布保存在多台 DNS 服务器中，这些 DNS 服务器相互接力配合，从而查找出要查询的信息。  

#### 信息是如何在 DNS 服务器上注册并保存的

DNS 服务器中的所有信息都是按照域名以分层次的结构来保存的。  
DNS 中的域名都是用句点来分隔的，比如 www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已。  
在域名中，越靠右的位置表示其层级越高，比如 www.lab.glasscom.com 这个域名如果按照公司里的组织结构来说，大概就是“com 事业集团 glasscom 部 lab 科的www”这样。  
其中，相当于一个层级的部分称为域。因此，com 域的下一层是 glasscom 域，再下一层是 lab 域，再下面才是 www 这个名字。  

这种具有层次结构的域名信息会注册到 DNS 服务器中，而每个域都是作为一个整体来处理的。  
换句话说就是，一个域的信息是作为一个整体存放在 DNS 服务器中的，不能将一个域拆开来存放在多台 DNS 服务器中。  
不过，DNS 服务器和域之间的关系也并不总是一对一的，一台DNS 服务器中也可以存放多个域的信息。  

### 寻找相应的 DNS 服务器并获取 IP 地址

如何找到 DNS 服务器中存放的信息的关键在于如何找到我们要访问的 Web 服务器的信息归哪一台 DNS 服务器管。  
互联网中有数万台 DNS 服务器，肯定不能一台一台挨个去找，我们可以采用下面的办法。  

首先，将负责管理下级域的 DNS 服务器的 IP 地址注册到它们的上级 DNS 服务器中，然后上级 DNS 服务器的 IP 地址再注册到更上一级的 DNS 服务器中，以此类推。  
这样，我们就可以通过上级 DNS 服务器查询出下级 DNS 服务器的 IP 地址，也就可以向下级 DNS 服务器发送查询请求了。  

也就是说，负责管理 lab.glasscom.com 这个域的 DNS 服务器的 IP 地址需要注册到 glasscom.com 域的 DNS 服务器中，  
而 glasscom.com 域的 DNS 服务器的IP 地址又需要注册到 com 域的 DNS 服务器中。  

#### 根域

在前面的讲解中，似乎com、jp 这些域（称为顶级域）就是最顶层了，它们各自负责保存下级DNS 服务器的信息，但实际上并非如此。在互联网中，com 和jp 的上面还有一级域，称为根域。  
根域不像 com、jp 那样有自己的名字，因此在一般书写域名时经常被省略；  
如果要明确表示根域，应该像 www.lab.glasscom.com. 这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。  

不过，一般都不写最后那个句点，因此根域的存在往往被忽略，但根域毕竟是真实存在的，根域的 DNS 服务器中保管着 com、jp 等的 DNS 服务器的信息。  
由于上级 DNS 服务器保管着所有下级 DNS 服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的 DNS 服务器。  

除此之外还需要完成另一项工作，那就是将根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。  
这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。  
因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。  

分配给根域 DNS 服务器的 IP 地址在全世界仅有 13 个，而且这些地址几乎不发生变化，因此将这些地址保存在所有的 DNS 服务器中也并不是一件难事。  
实际上，根域 DNS 服务器的相关信息已经包含在 DNS 服务器程序的配置文件中了，因此只要安装了 DNS 服务器程序，这些信息也就被自动配置好了。  

#### 具体实现流程

假设我们要查询 www.lab.glasscom.com 这台 Web 服务器的相关信息。  

1. 客户端首先会访问最近的一台 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）；
2. 由于最近的 DNS 服务器中没有存放 www.lab.glasscom.com 这一域名对应的信息，所以我们需要从顶层开始向下查找。
   - 最近的 DNS 服务器中保存了根域 DNS 服务器的信息，因此它会将来自客户端的查询消息转发给根域 DNS 服务器
3. 根域服务器中也没有 www.lab.glasscom.com 这个域名，但根据域名结构可以判断这个域名属于 com 域，因此根域 DNS 服务器会返回它所管理的 com 域中的 DNS 服务器的 IP 地址；
4. 最近的 DNS 服务器又会向 com 域的 DNS 服务器发送查询消息；
5. com 域中也没有 www.lab.glasscom.com这个域名的信息，和刚才一样，com 域服务器会返回它下面的 glasscom.com 域的 DNS 服务器的 IP 地址；
6. 以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标 DNS 服务器；
7. 只要向目标 DNS 服务器发送查询消息，就能够得到我们需要的答案，也就是 www.lab.glasscom.com 的 IP 地址了。
8. 收到客户端的查询消息之后，DNS 服务器会按照前面的方法来查询 IP 地址，并返回给客户端；
9. 这样，客户端就知道了 Web 服务器的 IP 地址，也就能够对其进行访问了。

### 通过缓存加快 DNS 服务器的响应

以上展示的是基本原理，与真实互联网中的工作方式还是有一些区别的。  
在真实的互联网中，一台 DNS 服务器可以管理多个域的信息，现实中上级域和下级域有可能共享同一台 DNS 服务器。  
在这种情况下，访问上级 DNS 服务器时就可以向下跳过一级 DNS 服务器，直接返回再下一级 DNS 服务器的相关信息。  

此外，有时候并不需要从最上级的根域开始查找，因为 DNS 服务器有一个缓存功能，可以记住之前查询过的域名。  
如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。  
相比每次都从根域找起来说，缓存可以减少查询所需的时间。  
并且，当要查询的域名不存在时，“不存在”这一响应结果也会被缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。  

这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。  
因此，DNS 服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。  
而且，在对查询进行响应时，DNS 服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的 DNS 服务器。  

## 委托协议栈发送消息

### 数据收发操作概览

知道了 IP 地址之后，就可以委托操作系统内部的协议栈向这个目标 IP 地址，也就是我们要访问的 Web 服务器发送消息了。  
要发送给 Web 服务器的 HTTP 消息是一种数字信息（digital data），因此也可以说是委托协议栈来发送数字信息。  
  - 收发数字信息这一操作不仅限于浏览器，对于各种使用网络的应用程序来说都是共通的；
  - 因此，这一操作的过程也不仅适用于 Web，而是适用于任何网络应用程序。

和向 DNS 服务器查询 IP 地址的操作一样，收发数字信息这一操作也需要使用 Socket 库中的程序组件。  
不过，查询 IP 地址只需要调用一个程序组件就可以了，而这里需要按照指定的顺序调用多个程序组件，这个过程有点复杂。  
发送数据是一系列操作相结合来实现的。  

使用 Socket 库来收发数据的操作过程，简单来说，就像收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。  
我们可以把数据通道想象成一条管道，将数据从一端送入管道，数据就会到达管道的另一端然后被取出。  
  - 数据可以从任何一端被送入管道，数据的流动是双向的。
  - 不过，这并不是说现实中真的有这么一条管道，只是为了帮助大家理解数据收发操作的全貌。
收发数据的整体思路就是这样，但还有一点也非常重要。  
在进行收发数据操作之前，双方需要先建立起这条管道才行。  
  - 建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字。我们需要先创建套接字，然后再将套接字连接起来形成管道。  

实际的过程是下面这样的：  
1. 服务器一方先创建套接字，然后等待客户端向该套接字连接管道；
   - 服务器程序一般会在启动后就创建好套接字并等待客户端连接管道。
2. 当服务器进入等待状态时，客户端就可以连接管道了；
   - 客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务器端的套接字上。
3. 当双方的套接字连接起来之后，通信准备就完成了；
4. 接下来，只要将数据送入套接字就可以收发数据了；
5. 当数据全部发送完毕之后，连接的管道将会被断开；
   - 管道在连接时是由客户端发起的，但在断开时可以由客户端或服务器任意一方发起。
   - 其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。
6. 到此为止，通信操作就结束了。

综上所述，收发数据的操作分为若干个阶段，可以大致总结为以下 4 个。  
1. 创建套接字（创建套接字阶段）；
2. 将管道连接到服务器端的套接字上（连接阶段）；
3. 收发数据（通信阶段）；
4. 断开管道并删除套接字（断开阶段）。

在每个阶段，Socket 库中的程序组件都会被调用来执行相关的数据收发操作。  
前面这 4 个操作都是由操作系统中的协议栈来执行的，浏览器等应用程序并不会自己去做连接管道、放入数据这些工作，而是委托协议栈来代劳。  
本章只介绍“委托”这个操作。关于协议栈收到委托之后具体是如何连接管道和放入数据的将在第 2 章介绍。  

此外，这些委托的操作都是通过调用 Socket 库中的程序组件来执行的。  
但这些数据通信用的程序组件其实仅仅充当了一个桥梁的角色，并不执行任何实质性的操作，应用程序的委托内容最终会被原原本本地传递给协议栈。  
因此，我们无法形象地展示这些程序组件到底完成了怎样的工作，与其勉强强调 Socket 库的存在，还不如将 Socket 库和协议栈看成一个整体并讲解它们的整体行为让人更容易理解。  
因此，后文将会采用这样的讲法。不过，请大家不要忘记 Socket 库这一桥梁的存在。  

### 创建套接字阶段

应用程序（浏览器）委托收发数据的过程关键点就是像对 DNS 服务器发送查询一样，  
调用 Socket 库中的特定程序组件访问 DNS 服务器时我们调用的是一个叫作 gethostbyname 的程序组件（也就是解析器），而这一次则需要按照一定的顺序调用若干个程序组件。  

首先是套接字创建阶段。客户端创建套接字的操作非常简单，只要调用 Socket 库中的 socket 程序组件就可以了。  
  - 调用 Socket 库中的程序组件的思路和调用解析器是一样的，调用解析器是在程序中直接写解析器的程序名`gethostbyname`即可；  
  - 和调用解析器一样，调用 socket 之后，控制流程会转移到socket 内部并执行创建套接字的操作，完成之后控制流程又会被移交回应用程序。
套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中；  
  - 描述符是用来识别不同的套接字的；
  - 因为同一台计算机上可能同时存在多个套接字，在这样的情况下，我们就需要一种方法来识别出某个特定的套接字，这种方法就是描述符。
当创建套接字后，我们就可以使用这个套接字来执行收发数据的操作了。  
  - 这时，只要我们出示描述符，协议栈就能够判断出我们希望用哪一个套接字来连接或者收发数据了；
  - 应用程序是通过“描述符”这一类似号码牌的东西来识别套接字的。

### 连接阶段：把管道接上去

接下来，我们需要委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序通过调用 Socket 库中的名为 connect 的程序组件来完成这一操作。  
这里的要点是当调用 connect 时，需要指定描述符、服务器 IP 地址和端口号这 3 个参数。  

1. 描述符；
   - 就是在创建套接字的时候由协议栈返回的那个描述符。
     - connect 会将应用程序指定的描述符告知协议栈，然后协议栈根据这个描述符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接的操作。
2. 服务器 IP 地址；
   - 就是通过 DNS 服务器查询得到的我们要访问的服务器的 IP 地址。
3. 端口号。
   - IP 地址是为了区分网络中的各个计算机而分配的数值。因此，只要知道了 IP 地址，我们就可以识别出网络上的某台计算机；
   - 但是，连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行，而仅凭 IP 地址是无法做到这一点的；
   - 当同时指定 IP 地址和端口号时，就可以明确识别出某台具体的计算机上的某个具体的套接字。

#### 端口号

能否使用描述符来识别套接字？  
描述符是和委托创建套接字的应用程序进行交互时使用的，并不是用来告诉网络连接的另一方的，因此另一方并不知道这个描述符。  
同样地，客户端也无法知道服务器上的描述符。因此，客户端也无法通过服务器端的描述符去确定位于服务器上的某一个套接字。  

所以，我们需要另外一个对客户端也同样适用的机制，而这个机制就是端口号。  
如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。  

##### 实现规定好的端口号

服务器上所使用的端口号是根据应用的种类事先规定好的，仅此而已。比如 Web 是 80 号端口，电子邮件是 25 号端口。  
关于端口号，我们将在第 6 章探索服务器内部工作的时候进行介绍，这里大家只要这样记住就行了：只要指定了事先规定好的端口号，就可以连接到相应的服务器程序的套接字。  
也就是说，浏览器访问 Web 服务器时使用 80 号端口，这是已经规定好的。  

端口号的规则是全球统一的，为了避免重复和冲突，端口号和 IP 地址一样都是由 IANA（Internet Assigned Number Authority，互联网编号管理局）这一组织来统一管理的。  

##### 客户端的端口

既然确定连接对象的套接字需要使用端口号，那么服务器也得知道客户端的套接字号码才行吧，这个问题是怎么解决的呢？  
事情是这样的，首先，客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。  
接下来，当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。  
  - 这部分内容我们会在第2 章探索协议栈内部工作时进行介绍。
  - 在创建套接字时，服务器也可以自行指定端口号，但一般并不常用。

总而言之，就是当调用 connect 时，协议栈就会执行连接操作。  
当连接成功后，协议栈会将对方的 IP 地址和端口号等信息保存在套接字中，这样我们就可以开始收发数据了。  

### 通信阶段：传递消息

当套接字连接起来之后，剩下的事情就简单了。只要将数据送入套接字，数据就会被发送到对方的套接字中。
当然，应用程序无法直接控制套接字，因此还是要通过 Socket 库委托协议栈来完成这个操作。
这个操作需要使用 write 这个程序组件，具体过程如下：
1. 当调用 write 时，需要指定描述符和发送数据，然后协议栈就会将数据发送到服务器。
   - 应用程序需要在内存中准备好要发送的数据，根据用户输入的网址生成的 HTTP 请求消息就是我们要发送的数据。
   - 由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。
2. 当发送数据会通过网络到达我们要访问的服务器，服务器执行接收操作，解析收到的数据内容并执行相应的操作，向客户端返回响应消息；
3. 当消息返回后，需要执行的是接收消息的操作。
   - 接收消息的操作是通过 Socket 库中的 read 程序组件委托协议栈来完成的。
   - 调用 read 时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。
4. 当服务器返回响应消息时，read 就会负责将接收到的响应消息存放到接收缓冲区中。
   - 由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。

### 断开阶段：收发数据结束

当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需要调用Socket 库的 close 程序组件进入断开阶段。  
最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。  

断开的过程如下：  
1. Web 使用的 HTTP 协议规定，当 Web 服务器发送完响应消息之后，应该主动执行断开操作，因此 Web 服务器会首先调用 close 来断开连接。
2. 断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。
3. 接下来，当浏览器调用 read 执行接收数据操作时，read 会告知浏览器收发数据操作已结束，连接已经断开。
4. 浏览器得知后，也会调用 close 进入断开阶段。

这就是 HTTP 的工作过程。HTTP 协议将HTML 文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。  
因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。  
对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。  
在HTTP 版本1.1 中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。  

> 本章我们探索了浏览器与 Web 服务器之间收发消息的过程，但实际负责收发消息的是协议栈、网卡驱动和网卡，只有这 3 者相互配合，数据才能够在网络中流动起来。
  下一章我们将对这一部分进行探索。

>	zongjie
	1. 浏览器解析URL，并根据 HTTP 协议进行客户端和服务器之间交互的消息内容和步骤
	2. 生成请求信息：包括方法和 URI
	3. 解析器调用协议栈，协议栈向最近的 DNS 服务器发送查询 Web 服务器的 IP 地址的信息
	4. 一层层查下去直到查到对应域名的 IP 地址
	5. 信息传回客户端，协议栈传回解析器，解析器传回应用程序
	6. 得知 IP 地址，客户端根据端口、描述符、IP 地址找到对应 IP 地址的套接字，
	7. 告知对应设备客户端的套接字信息
	8. 两个套接字连接
	9. 使用 write 发送信息进入客户端的套接字传送到服务器的套接字
	10. 服务器发回信息，使用 read 把返回信息放到接收缓存区
	11. 发送结束服务器断开，接着客户端断开，接着浏览器断开

# 用电信号传输 TCP/IP 数据

## 热身问答

1. 一般情况下，以太网的头部（网络包开头的控制信息）格式并非遵循国际标准（IEEE802.3/802.2），而是遵循一个更古老的规格（以太网第 2 版，又称 DIX 规格），  
   相对地，国际标准（IEEE802.3/802.2）的头部格式由于长度太长、效率降低而没有普及。  
2. 最早的 TCP/IP 协议原型设计相当于现在的 TCP 和 IP 合在一起的样子，后来才拆分成为 TCP 和 IP 两个协议。  
3. 在网络包出现之前，通信都是像电话一样把线路连接起来进行的。但是，连接线路的通信方式只能和固定的对象进行通信，无法发挥计算机可以处理多种工作的特点。  
   为了解决这个问题，人们设计出了使用网络包来进行通信的方式。  

## 看点

### 创建套接字

从应用程序收到委托后，协议栈通过 TCP 协议收发数据的操作可以分为 4 个阶段。  
首先是创建套接字，在这个阶段，我们将介绍协议栈的内部结构、套接字的实体，以及创建套接字的操作过程。  

### 连接服务器

接下来是客户端套接字向服务器套接字进行连接的阶段。  
我们将介绍“连接”具体是进行怎样的操作，在这个过程中协议栈到底是如何工作的，以及客户端和服务器是如何进行交互的。  

### 收发数据

两端的套接字完成连接之后，就进入收发消息的阶段了。在这个阶段，协议栈会将从应用程序收到的数据切成小块并发送给服务器。  
考虑到通信过程中可能会出错导致网络包丢失，协议栈还需要确认切分出的每个包是否已经送达服务器，  对于没有送达的包要重新发送一次。  

### 从服务器断开连接并删除套接字

收发消息的操作全部结束之后，接下来要断开服务器的连接并删除套接字。  
断开操作的本质是当消息收发完成后客户端和服务器相互进行确认的过程，但这个过程并不只是相互确认并删除套接字那么简单。  

### IP 与以太网的包收发操作

在介绍 TCP 协议收发消息的操作之后，我们再来看看实际的网络包是如何进行收发的。  
协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号或者光信号发送出去。  

### 用 UDP 协议收发数据的操作

TCP 协议有很多方便的功能，比如网络包出错丢失时可以重发，因此很多应用程序都是使用 TCP 协议来收发数据的，但这些方便的功能也有帮倒忙的时候。  
在这种情况下我们还有另外一种叫 UDP 的协议。这里我们将介绍 UDP 的必要性以及它与 TCP 的差异。  

## 创建套接字

本章将说明操作系统中的网络控制软件（协议栈）和网络硬件（网卡）是如何将浏览器的消息发送给服务器的。  

### 协议栈的内部结构

和浏览器不同的是，协议栈的工作我们从表面上是看不见的，可能比较难以想象。  

协议栈的内部分为几个部分，分别承担不同的功能。  
1. 协议栈的上半部分有两块；
   - 分别是负责用 TCP 协议收发数据的部分；
   - 负责用 UDP 协议收发数据的部分；
   - TCP 协议和 UDP 协议会接受应用程序的委托执行收发数据的操作；
   - 像浏览器、邮件等一般的应用程序都是使用 TCP 收发数据的，而像 DNS 查询等收发较短的控制数据的时候则使用 UDP。  
2. 下面一半是用 IP 协议控制网络包收发操作的部分。
  - 在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由 IP 来负责的；
  - 此外，IP 中还包括 ICMP 协议和 ARP 协议；
  - ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息；
  - ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

#### TCP/IP 软件的分层结构

TCP/IP 软件采用分层结构，包括应用程序、操作系统、驱动程序、硬件四个部分，四部分由上而下。  
上面的部分会向下面的部分委派工作，下面的部分接受委派的工作并实际执行。  
当然，这一上下关系只是一个总体的规则，其中也有一部分上下关系不明确，或者上下关系相反的情况，所以也不必过于纠结。  

1. 最上面的部分是网络应用程序；
   - 也就是浏览器、电子邮件客户端、Web 服务器、电子邮件服务器等程序，它们会将收发数据等工作委派给下层的部分来完成。
   - 除了浏览器之外，其他应用程序在网络上收发数据的操作也都是类似上面这样的
     - 也就是说，尽管不同的应用程序收发的数据内容不同，但收发数据的操作是共通的。
     - 因此，下面介绍的内容不仅适用于浏览器，也适用于各种应用程序。
2. 应用程序的下面是 Socket 库，其中包括解析器，解析器用来向 DNS 服务器发出查询；
3. 再下面就是操作系统内部了，其中包括协议栈；
4. IP 下面的网卡驱动程序负责控制网卡硬件，
5. 最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。

### 套接字的实体就是通信控制信息

在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP 地址、端口号、通信操作的进行状态等。  
本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。  

协议栈在执行操作时需要参阅这些控制信息。  
例如，在发送数据时，需要看一看套接字中的通信对象 IP 地址和端口号，以便向指定的 IP 地址和端口发送数据。  
在发送数据之后，协议栈需要等待对方返回收到数据的响应信息，但数据也可能在中途丢失，永远也等不到对方的响应。  
在这样的情况下，我们不能一直等下去，需要在等待一定时间之后重新发送丢失的数据，这就需要协议栈能够知道执行发送数据操作后过了多长时间。  
为此，套接字中必须要记录是否已经收到响应，以及发送数据后经过了多长时间，才能根据这些信息按照需要执行重发操作。  

上面说的只是其中一个例子。套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。  
协议栈是根据套接字中记录的控制信息来工作的。  

### 调用 socket 时的操作

当浏览器调用socket、connect 等 Socket 库中的程序组件时，协议栈内部是如何工作的。

1. 首先是创建套接字的阶段；
应用程序调用 socket 申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。  
在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。  
  - 用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们先要开辟出这样一块空间来，这相当于为控制信息准备一个容器；
  - 但光一个容器并没有什么用，还需要往里面存入控制信息。
套接字刚刚创建时，数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。  
到这里，创建套接字的操作就完成了。  

2. 接下来，需要将表示这个套接字的描述符告知应用程序；  
   - 描述符相当于用来区分协议栈中的多个套接字的号码牌。

3. 收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。
由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息。  
这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。  

## 连接服务器

### 连接是什么意思









































































































































































































































































































