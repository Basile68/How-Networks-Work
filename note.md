要实现应用程序之间的交互，我们需要一个能够在浏览器和Web服务器之间传递请求和响应的机制。  
由于请求和相应都是由 0 和 1 组成的数字信息，所以可以说，我们需要的是一种能够将数字信息搬运到指定目的地的机制。  
这种机制是由操作系统中的网络控制软件，以及交换机、路由器等设备分工合作来实现的，它的基本思路是将数字信息分割成一个一个的小块，然后装入一些被称为“包”（Packet）的容器中来运送。  
这个负责搬运数字信息的机制，再加上浏览器和Web服务器这些网络应用程序，这两部分就组成了网络。  

# 章节主要内容

## 第1章 Web 浏览器

首先介绍浏览器的工作方式，当输入网址时，浏览器就会按照一定的规则去分析这个网址的含义，然后根据其含义生成请求消息。  
接着浏览器就会委托操作系统中的网络控制软件将消息发送给服务器。  

## 第2章 协议栈、网卡

介绍探索搬运数据的机制。  
首先介绍协议栈（网络控制软件叫作协议栈）。这个软件会将从浏览器接收到的消息打包，然后加上目的地址等控制信息。  
接下来，协议栈会将包交给网卡（负责以太网或无线网络通信的硬件）。  
然后，网卡会将包转换为电信号并通过网线发送出去。这样一来，包就进入到网络之中了。  

## 第3章 集线器、交换机、路由器

本章假设客户端计算机是连接到家庭或公司的局域网中，然后再通过 ADSL 和光纤到户（FTTH）等宽带线路接入互联网。  
在这样的场景中，网卡发送的包会经过交换机等设备，到达用来接入互联网的路由器。路由器的后面就是互联网，网络运营商会负责将包送到目的地。  

## 第4章 接入网、网络运营商

数据从用来接入互联网的路由器出发，进入了互联网的内部。互联网的入口线路称为接入网。  
在骨干网中存在很多运营商和大量的路由器，这些路由器相互连接，组成一张巨大的网，而我们的网络包就在其中经过若干路由器的接力，最终被发送到目标Web服务器上。  

## 第5章 防火墙、缓存服务器

通过骨干网之后，网络包最终到达了 Web 服务器所在的局域网中。  
接着，它会遇到防火墙，防火墙会对进入的包进行检查。  
检查完之后，网络包接下来可能还会遇到缓存服务器。  
此外，在大型网站中，可能还会配备将消息分布到多台 Web 服务器上的负载均衡器，还有可能会使用通过分布在整个互联网中的缓存服务器来分发内容的服务。  
经过这些机制之后，网络包才会到达 Web 服务器。  

## 第6章 Web服务器

当网络包到达 Web 服务器后，数据会被解包并还原为原始的请求消息，然后交给 Web 服务器程序。  
接下来，Web 服务器程序分析请求消息的含义，并按照其中的指示将数据装入响应消息中，然后发回给客户端。  
  - 响应消息回到客户端的过程和之前我们介绍的过程正好相反。
当响应到达客户端之后，浏览器会从中读取出网页的数据并在屏幕上显示出来。  

# 涉及到的主要关键词

## 第1章 浏览器生成消息

浏览器、Web服务器、网址（URL）、HTTP、HTML、协议、URI、请求消息、解析器、Socket库、DNS服务器、域名  

## 第2章 用电信号传输TCP/IP数据

TCP/IP、套接字、协议栈、IP地址、端口号、包、头部、网卡、网卡驱动、MAC地址、以太网控制器、ICMP、UDP  

## 第3章 从网线到网络设备

局域网（LAN）、双绞线、串扰、中继式集线器、MDI、MDI-X、交换式集线器、全双工、半双工、碰撞、自动协商、路由器、  
路由表、子网掩码、默认网关、分片、地址转换、公有地址、私有地址  

## 第4章 通过接入网进入互联网内部

ADSL、FTTH、光纤、接入网、ADSL􀀀Modem集成式路由器、ATM、信元、正交振幅调制、分离器、DSLAM、宽带接入服务器、  
远程接入服务器、PPP、网络运行中心（NOC）、光纤、IX（Internet􀀀eXchange，互联网交换）  

## 第5章 服务器端的局域网中有什么玄机

防火墙、包过滤、数据中心、轮询、负载均衡器、缓存服务器、代理、代理服务器、内容分发服务、重定向  

## 第6章 请求到达Web服务器，响应返回浏览器

响应消息、多任务、多线程、虚拟目录、CGI、表单、访问控制、密码、数据格式、MIME  

# 第1章 浏览器生成消息——探索浏览器内部

## 热身问答

1. `http://www.nikkeibp.co.jp/`中的`www`只是Web服务器上的一种命名。  
   World Wide Web是Web的提出者最早开发的浏览器兼HTML编辑器的名字。  

2. 如果是`.com`、`.net`、`.org`、`.jp`（除`co.jp`、`ne.jp`等`xx.jp`格式的域名外）等没有对注册对象范围进行限制的域名，任何个人都可以申请注册。  
   - 在中国的情况，个人可以申请“`.cn`”域名，但“`.com.cn`”“`.net.cn`”等域名则是不开放给个人注册的。
   - 日本的域名体系中，`.jp`下级的域名用的是两个字母的命名，例如`.co.jp`、`.ne.jp`。
   此外，也有一种`.name`域名是专门为个人申请者准备的。  
   
3. 应用程序并不是自己去控制网络，而是委托操作系统来控制网络。  

## 看点

### 生成HTTP请求消息

用户在浏览器输入网址（URL） -\> 浏览器解析网址 -\> 浏览器根据网址含义生成请求信息

### 向DNS服务器查询Web服务器的IP地址

请求消息生成之后，浏览器会委托操作系统向 Web 服务器发送请求，但浏览器必须告诉操作系统接收方的 IP 地址才行，因此浏览器必须先查出 Web 服务器的 IP 地址。  
网址中只有 Web 服务器的域名，因此浏览器需要向 DNS 服务器查询域名对应的IP地址。  

### 全世界 DNS 服务器的大接力

全世界共有上万台 DNS 服务器，它们相互接力才能完成IP地址的查询，而它们进行接力的方法也是本章看点之一。  

### 委托协议栈发送消息

查询到 IP 地址之后，浏览器就可以将消息委托给操作系统发送给Web服务器了，但这个委托到底是如何完成的呢？这也是本章看点之一。  
理解了向操作系统进行委托时的规则，我们就能够明白做出某个委托时操作系统会给我们怎样的反馈，这可以说是相当于具体地理解了网络的潜在能力。  

## 生成 HTTP 请求消息

### 输入网址

#### 网址的定义

网址，准确来说应该叫 URL，是以`http://` 开头的那一串东西；  
实际上除了`http:`，网址还可以以其他一些文字开头，例如“`ftp:`、`file:`、`mailto:`等。  

浏览器是一个具备多种客户端功能的综合性客户端软件，因此它需要一些东西来判断应该使用其中哪种功能来访问相应的数据，而各种不同的 URL 就是用来干这个的，比如访问 Web 服务器时用`http:`，而访问 FTP 服务器下载和上传文件时用`ftp:`。  

#### 网址的格式

根据访问目标的不同，URL 的写法也会不同。  
  - 在访问 Web 服务器和 FTP 服务器时，URL 中会包含服务器的域名和要访问的文件的路径名等；
  - 发邮件的 URL 则包含收件人的邮件地址。
此外，根据需要，URL 中还会包含用户名、密码、服务器端口号等信息。  

##### URL的各种格式

用HTTP协议访问Web服务器时：  
|http://|user|:|password|@|www.glasscom.com|:80|/dir/file1.htm|  
|---|---|---|---|---|---|---|---|  
||用户名（可省略）||密码（可省略）||Web服务器域名|端口号（可省略）|文件的路径名|

用FTP协议下载和上传文件时：  
|ftp://|user|:|password|@|ftp.glasscom.com|:21|/dir/file1.htm|
|---|---|---|---|---|---|---|---|
|协议|用户名（可省略）||密码（可省略）||FTP服务器域名|端口号（可省略）|文件的路径名|

读取客户端计算机本地文件时:  
|file://|localhost|/c:/path/file1.zip|
|---|---|---|
||计算机名（可省略）|文件的路径名|

发送电子邮件时：  
|mailto:|tone@glasscom.com|
|---|---|
||邮件地址|

阅读新闻组的文章时:  
|news:|comp.protocols.tcp-ip|
|---|---|
||新闻组名|

尽管 URL 有各种不同的写法，但它们有一个共同点，那就是 URL 开头的文字，即`http:`、`ftp:`、`file:`、`mailto:`这部分文字都表示浏览器应当使用的访问方法。  
  - 访问 Web 服务器时应该使用 HTTP 协议；
  - 访问 FTP 服务器时则应该使用 FTP 协议。
因此，我们可以把这部分理解为访问时使用的协议类型。  
尽管后面部分的写法各不相同，但开头部分的内容决定了后面部分的写法，因此并不会造成混乱。  

> 1. HTTP：Hypertext Transfer Protocol，超文本传送协议。
  2. 协议：通信操作的规则定义称为协议（protocol）。

### 解析网址

浏览器要做的第一步工作就是对 URL 进行解析，从而生成发送给 Web 服务器的请求消息。  
具体步骤：  
1. 按照 URL 规格对字符串进行解析；
2. 将 URL 拆分为各个组成元素；
3. 分别理解各个元素的语义含义；
   - 主机名用于确定要访问的服务器；
   - 路径名用于确定服务器上要访问的具体资源位置。
4. 根据解析结果确定访问目标。

### 省略文件名的情况

URL 可以省略文件名，进一步省略目录名，再进一步省略结尾的`/`。这些写法都是允许的。  
当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是`/index.html`或者`/default.htm`这些文件。  

例：http://www.lab.glasscom.com/whatisthis  
一般来说，这种情况会按照下面的惯例进行处理：
如果Web 服务器上存在名为 whatisthis 的文件，则将 whatisthis 作为文件名来处理；  
如果存在名为 whatisthis 的目录，则将 whatisthis 作为目录名来处理。  

### HTTP 的基本思路

解析完 URL 之后，浏览器会使用 HTTP 协议来访问 Web 服务器。  

HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤，其基本思路非常简单。  
首先，客户端会向服务器发送请求消息。请求消息中包含的内容是“对什么”和“进行怎样的操作”两个部分。  
收到请求消息之后，Web 服务器会对其中的内容进行解析，通过 URI 和方法来判断“对什么”“进行怎样的操作”，并根据这些要求来完成自己的工作，然后将结果存放在响应消息中。  


#### URI 和方法

- 相当于“对什么”的部分称为 URI；
  - 一般来说，URI 的内容是一个存放网页数据的文件名或者是一个 CGI 程序的文件名，例如“/dir1/file1.html”“/dir1/program1.cgi”等。
  - 不过，URI 不仅限于此，也可以直接使用“http:”开头的 URL 来作为 URI。换句话说就是，这里可以写各种访问目标，而这些访问目标统称为URI。

- “进行怎样的操作”的部分称为方法。
  - 方法表示需要让 Web 服务器完成怎样的工作，其中典型的例子包括读取 URI 表示的数据、将客户端输入的数据发送给 URI 表示的程序等。

#### HTTP 的主要方法：  

|方法|含义|
|---|---|
|GET|获取 URI 指定的信息。如果 URI 指定的是文件，则返回文件的内容；如果 URI 指定的是 CGI 程序，则返回该程序的输出数据|
|POST|从客户端向服务器发送数据。一般用于发送表单中填写的数据等情况下|
|HEAD|和 GET 基本相同。不过它只返回 HTTP 的消息头（message header），而并不返回数据的内容。用于获取文件最后更新时间等属性信息|
|OPTIONS|用于通知或查询通信选项|
|PUT|替换 URI 指定的服务器上的文件。如果 URI 指定的文件不存在，则创建该文件|
|DELETE|删除 URI 指定的服务器上的文件|
|TRACE|将服务器收到的请求行和头部（header）直接返回给客户端。用于在使用代理的环境中检查改写请求的情况|
|CONNECT|使用代理传输加密消息时使用的方法|

除了表中的内容之外，HTTP 消息中还有一些用来表示附加信息的头字段。客户端向 Web 服务器发送数据时，会先发送头字段，然后再发送数据。不过，头字段属于可有可无的附加信息。  

#### 响应消息

在响应消息的开头有一个状态码，它用来表示操作的执行结果是成功还是发生了错误。  
  - 当我们访问 Web 服务器时，遇到找不到的文件就会显示出404 Not Found 的错误信息，其实这就是状态码。
状态码后面就是头字段和网页数据。响应消息会被发送回客户端，客户端收到之后，浏览器会从消息中读出所需的数据并显示在屏幕上。到这里，HTTP 的整个工作就完成了。  

#### 补充知识

上表列出的 HTTP 方法中最常用的就是`GET`方法，所以一般的访问过程是：  
1. 在请求消息中写上 GET 方法，然后在 URI 中写上存放网页数据的文件名“/dir1/file1.html”；
   - 表示我们需要获取 /dir1/file1.html 文件中的数据。
2. 当 Web 服务器收到消息后，会打开 /dir1/file1.html 文件并读取出里面的数据；
3. 将读出的数据存放到响应消息中，并返回给客户端；
4. 最后，客户端浏览器会收到这些数据并显示在屏幕上。

还有一个经常使用的方法就是`POST`，在表单中填写数据并将其发送给 Web 服务器时就会使用这个方法。
  - 当我们在网上商城填写收货地址和姓名，或者是在网上填写问卷时，都会遇到带有输入框的网页，而这些可以输入信息的部分就是表单。
1. 使用POST 方法时，URI 会指向 Web 服务器中运行的一个应用程序的文件名；
   - 典型的例子包括“index.cgi”“index.php”等。
2. 在请求消息中，除了方法和 URI 之外，还要加上传递给应用程序和脚本的数据；
   - 这里的数据也就是用户在输入框里填写的信息。
3. 当服务器收到消息后，Web 服务器会将请求消息中的数据发送给 URI 指定的应用程序；
4. Web 服务器从应用程序接收输出的结果，会将它存放到响应消息中并返回给客户端；
5. 最后，客户端浏览器会收到这些数据并显示在屏幕上。

前面两个方法属于 HTTP 的典型用法，除此之外的其他方法在互联网上几乎见不到使用的例子。  

如果只有 GET 和 POST 方法，我们就只能从 Web 服务器中获取网页数据，以及将网页输入框中的信息发送给 Web 服务器。  
而有了 PUT 和 DELETE 方法，就能够从客户端修改或者删除 Web 服务器上的文件。  
有了这些功能，我们甚至可以将 Web 服务器当成文件服务器来用。  
  - 当然，出于安全上的原因，或者是支持 GET 和 POST 之外的方法的客户端没有广泛普及之类的原因，一般我们并不会碰到这样的用法。

### 生成 HTTP 请求消息

对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。  
HTTP 消息在格式上是有严格规定的，因此浏览器会按照规定的格式来生成请求消息。  

#### HTTP 请求消息的格式

|内容|名称|
|<方法><空格><URI><空格><HTTP版本>|请求行|
|---|---|
|<字段名>:<字段值>|消息头|
|...|消息头|
|...|消息头|
|...|消息头|
|<空行>||
|<消息体>|消息体|

- 请求行：通过这一行可以大致了解请求的内容；  
- 消息头：每行包含一个头字段，用于表示请求的附加信息。消息头的行数根据具体情况可变，一直延伸到空行为止；  
- 消息体：包含客户端向服务器发送的数据，例如用 POST 方法向 Web 服务器发送的网页表单数据。  

#### 写一个请求消息

请求行的重点是最开头的方法，方法可以告诉 Web 服务器它应该进行怎样的操作。但是方法有很多种，必须先判断应该选用其中的哪一种。  
选择的关键在于浏览器的工作状态，浏览器并非只有在这一种场景下才会向 Web 服务器发送请求消息。  
  - 比如点击网页中的超级链接，或者在表单中填写信息后点击“提交”按钮，这些场景都会触发浏览器的工作，而选用哪种方法也是根据场景来确定的。  

在地址栏中输入网址并显示网页，应该使用 GET 方法。  
点击超级链接的场景中也是使用 GET 方法。  
如果是表单，在 HTML 源代码中会在表单的属性中指定使用哪种方法来发送请求，可能是 GET 也可能是 POST。  
  - GET 方法能够发送的数据只有几百个字节，如果表单中的数据超过这一长度，则必须使用 POST 方法来发送。

写好方法之后，加一个空格，然后写 URI。URI 部分的格式如下，一般是文件和程序的路径名。
  - /\<目录名\>/…/\<文件名\>

第一行的末尾需要写上 HTTP 的版本号，这是为了表示该消息是基于哪个版本的 HTTP 规格编写的。到此为止，第一行就结束了。  

第二行开始为消息头。  
  - 尽管通过第一行我们就可以大致理解请求的内容，但有些情况下还需要一些额外的详细信息，而消息头的功能就是用来存放这些信息；
  - 消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等；
    - 这些项目表示的都是非常细节的信息。
  - 消息头中的内容随着浏览器类型、版本号、设置等的不同而不同，大多数情况下消息头的长度为几行到十几行不等。

写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据。这一部分称为消息体，也就是消息的主体。  
  - 不过，在使用 GET 方法的情况下，仅凭方法和 URI，Web 服务器就能够判断需要进行怎样的操作，因此消息体中不需要填写任何数据。
  - 当使用 POST 方法时，需要将表单中填写的信息写在消息体中。

到此为止，请求消息的生成操作就全部完成了。  

### 发送请求后会收到响应

这里先粗略地了解一下：响应消息的格式以及基本思路和请求消息是相同的，差别只在第一行上。  
  - 在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错；
  - 状态码和响应短语表示的内容一致，但它们的用途不同；
  - 状态码是一个数字，它主要用来向程序告知执行的结果；
  - 相对地，响应短语则是一段文字，用来向人们告知执行的结果。

#### HTTP 状态码概要

状态码的第一位数字表示状态类型，第二、三位数字表示具体的情况。下表列举了第一位数字的含义。  

|状态码|含义|
|---|---|
|1xx|告知请求的处理进度和情况|
|2xx|成功|
|3xx|表示需要进一步操作|
|4xx|客户端错误|
|5xx|服务器错误|

返回响应消息之后，浏览器会将数据提取出来并显示在屏幕上，我们就能够看到网页的样子了。  
如果网页的内容只有文字，那么到这里就全部处理完毕了，但如果网页中还包括图片等资源，则还有下文。  

#### 当网页包含图片时

当网页中包含图片时，会在网页中的相应位置嵌入表示图片文件的标签的控制信息。  
浏览器会在显示文字时搜索相应的标签，当遇到图片相关的标签时，会在屏幕上留出用来显示图片的空间，然后再次访问 Web 服务器，  
按照标签中指定的文件名向 Web 服务器请求获取相应的图片并显示在预留的空间中。  
这个步骤和获取网页文件时一样，只要在 URI 部分写上图片的文件名并生成和发送请求消息就可以了。  

> 1 条请求消息中只能写 1 个 URI。如果需要获取多个文件，必须对每个文件单独发送 1 条请求。
  - 比如 1 个网页中包含 3 张图片，那么获取网页加上获取图片，一共需要向 Web 服务器发送 4 条请求。
  判断所需的文件，然后获取这些文件并显示在屏幕上，这一系列工作的整体指挥也是浏览器的任务之一，而 Web 服务器却毫不知情。
  Web 服务器完全不关心这 4 条请求获取的文件到底是 1 个网页上的还是不同网页上的，它的任务就是对每一条单独的请求返回 1 条响应而已。

## 向 DNS 服务器查询 Web 服务器的 IP 地址

### IP 地址的基本知识

生成 HTTP 消息之后，需要根据域名查询 IP 地址将其交给操作系统，然后委托操作系统将消息发送给 Web 服务器。  
  - 尽管浏览器能够解析网址并生成 HTTP 消息，但它本身并不具备将消息发送到网络中的功能，因此这一功能需要委托操作系统来实现。  

互联网和公司内部的局域网都是基于 TCP/IP 的思路来设计的，TCP/IP 的结构就是由一些小的子网，通过路由器连接起来组成一个大的网络。  
  - 这里的子网可以理解为用集线器连接起来的几台计算机，我们将它看作一个单位，称为子网；
  - 将子网通过路由器连接起来，就形成了一个网络。

在网络中，所有的设备都会被分配一个地址。这个地址就相当于现实中某条路上的“ ×× 号 ×× 室”。  
  - “号”对应的号码是分配给整个子网的，“室”对应的号码是分配给子网中的计算机的，这就是网络中的地址；
  - “号”对应的号码称为网络号，“室”对应的号码称为主机号，这个地址的整体称为 IP 地址。
通过 IP 地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。  

#### 消息传送的具体过程

在后面的章节中会详细讲解，现在先简单了解一下。  
- 发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上；  
- 接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器；    
  - 即消息再次经过子网内的集线器被转发到下一个路由器。
- 前面的过程不断重复，最终消息就被传送到了目的地。  

#### 实际的 IP 地址

实际的 IP 地址是一串 32 比特的数字，按照 8 比特（ 1 字节）为一组分成 4 组，分别用十进制表示然后再用圆点隔开。  
这就是我们平常经常见到的 IP 地址格式，但仅凭这一串数字我们无法区分哪部分是网络号，哪部分是主机号。  
  - 在 IP 地址的规则中，网络号和主机号连起来总共是 32 比特，但这两部分的具体结构是不固定的。  
  
##### 子网掩码
  
在组建网络时，用户可以自行决定网络号和主机号在 32 比特之间的分配关系，因此，我们还需要另外的附加信息来表示 IP 地址的内部结构。  
  - 这一附加信息称为子网掩码。  

子网掩码表示网络号与主机号之间的边界。  

例：  
`10.11.12.13/255.255.255.0`  

|IP 地址：|10.|1.|2.|3|
|---|---|---|---|---|
|子网掩码：|255.|255.|255.|0|

将上面的十进制转换成比特后:  
|IP 地址：|00001010.|00000001.|00000010.|00000011|
|---|---|---|---|---|
|子网掩码：|11111111.|11111111.|11111111.|00000000|

其中，子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号。  
这种写法太长，我们也可以把 1 的部分的比特数用十进制表示并写在 IP 地址的右侧。  
  - 写成`10.11.12.13/24`。

顺带一提，IP 地址中主机号部分的比特全部为 0 或者全部为 1 时代表两种特殊的含义。  
  - 主机号部分全部为 0 代表整个子网而不是子网中的某台设备；
  - 主机号部分全部为 1 代表向子网上所有设备发送包，即广播。

### 域名和 IP 地址并用的理由

TCP/IP 网络是通过 IP 地址来确定通信对象的，在网址中使用服务器名称而不是 IP 地址是因为服务器名称好记。  
而不用服务器名称来确定通信对象是因为 IP 地址长度为 4 字节即 32 比特，而域名最短几十个字节，最长甚至255字节，使用域名来确定定位会大大增加路由器的负担。  

于是，现在我们使用的方案是让人来使用名称，让路由器来使用 IP 地址。  
为了填补两者之间的障碍，需要有一个机制能够通过名称来查询 IP 地址，或者通过 IP 地址来查询名称，  
这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。这个机制就是 DNS。  

### Socket 库提供查询 IP 地址的功能

查询 IP 地址的方法非常简单，只要询问最近的 DNS 服务器“www.lab.glasscom.com 的 IP 地址是什么”就可以了，DNS 服务器会回答说“该服务器的 IP 地址为xxx.xxx.xxx.xxx”。  

#### DNS

##### 向 DNS 服务器发送查询消息

向 DNS 服务器发出查询，也就是向 DNS 服务器发送查询消息，并接收服务器返回的响应消息。  
换句话说，对于 DNS 服务器，我们的计算机上一定有相应的 DNS 客户端，而相当于 DNS 客户端的部分称为 DNS 解析器，或者简称解析器。  
通过 DNS 查询 IP 地址的操作称为域名解析，因此负责执行解析（resolution）这一操作的就叫解析器（resolver）了。  
  - 解析器实际上是一段程序，它包含在操作系统的 Socket 库中。  

###### Socket 库

库就是一堆通用程序组件的集合，其他的应用程序都需要使用其中的组件。  
  - 使用现成的组件搭建应用程序可以节省编程工作量；
  - 多个程序使用相同的组件可以实现程序的标准化。

Socket 库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是这个库中的其中一种程序组件。  
Socket 库是用于调用网络功能的程序组件集合。  

##### 通过解析器向 DNS 服务器发出查询

解析器的用法非常简单。Socket 库中的程序都是标准组件，只要从应用程序中进行调用就可以了。  
具体来说，在编写浏览器等应用程序的时候，只要写上解析器的程序名称以及 Web 服务器的域名就可以了，这样就完成了对解析器的调用。  

调用解析器后，解析器会向 DNS 服务器发送查询消息，然后 DNS 服务器会返回响应消息。  
响应消息中包含查询到的 IP 地址，解析器会取出IP地址，并将其写入浏览器指定的内存地址中。  
接下来，浏览器在向 Web 服务器发送消息时，只要从该内存地址取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统就可以了。  

根据域名查询 IP 地址时，浏览器会使用 Socket 库中的解析器。  

###### 解析器的内部原理

解析器内部是怎样工作的：  
1. 网络应用程序（在我们的场景中就是指浏览器）调用解析器时，程序的控制流程就会转移到解析器的内部；
2. 当控制流程转移到解析器后，解析器调用协议栈，控制流程再次转移，协议栈会执行发送消息的操作，然后会生成要发送给 DNS 服务器的查询消息并通过网卡发送给 DNS 服务器；
   - 解析器会根据 DNS 的规格，生成一条表示“请告诉我 www.lab.glasscom.com 的 IP 地址”的数据，并将它发送给 DNS 服务器；
   - 发送消息这个操作并不是由解析器自身来执行，而是要委托给操作系统内部的协议栈来执行。
3. 当DNS 服务器收到查询消息后，它会根据消息中的查询内容进行查询；
   - 如果要访问的Web 服务器已经在DNS 服务器上注册，那么这条记录就能够被找到，然后其 IP 地址会被写入响应消息并返回给客户端。
4. 接下来，消息经过网络到达客户端，再经过协议栈被传递给解析器；
5. 解析器读取出消息取出 IP 地址，并将 IP 地址传递给应用程序；
   - 实际上，解析器会将取出的 IP 地址写入应用程序指定的内存地址中。
6. 到这里，解析器的工作就完成了，控制流程重新回到应用程序（浏览器），现在应用程序已经能够从内存中取出 IP 地址了。

计算机的内部结构就是这样一层一层的。也就是说，很多程序组成不同的层次，彼此之间分工协作。  
当接到上层委派的操作时，本层的程序并不会完成所有的工作，而是会完成一部分工作，再将剩下的部分委派到下层来完成。  

顺带一提，向 DNS 服务器发送消息时，我们当然也需要知道 DNS 服务器的 IP 地址。只不过这个 IP 地址是作为 TCP/IP 的一个设置项目事先设置好的，不需要再去查询了。  
不同的操作系统中 TCP/IP 的设置方法也有差异，像 Windows 可以设置自动获得 DNS 服务器地址或主动分配一个，解析器会根据设置的 DNS 服务器 IP 地址来发送消息。  

####### 控制流程转移

一般来说，应用程序编写的操作内容是从上往下按顺序执行的，当到达需要调用解析器的部分时，对应的那一行程序就会被执行，应用程序本身的工作就会暂停。  
然后，Socket 库中的解析器开始运行，完成应用程序委托的操作。  
像这样，由于调用了其他程序，原本运行的程序进入暂停状态，而被调用的程序开始运行，这就是“控制流程转移”。  

## 全世界 DNS 服务器的大接力

### DNS 服务器的基本工作

DNS 服务器的基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响应。  
其中，来自客户端的查询消息包含以下 3 种信息：  
1. 域名；
   - 服务器、邮件服务器（邮件地址中@ 后面的部分）的名称。
2.  Class；
   - 在最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而Class 就是用来识别网络的信息；
   - 不过，如今除了互联网并没有其他的网络了，因此 Class 的值永远是代表互联网的 IN。
3. 记录类型。
   - 表示域名对应何种类型的记录。例如：
     - 当类型为 A 时，表示域名对应的是 IP 地址；
     - 当类型为 MX 时，表示域名对应的是邮件服务器；
     - 对于不同的记录类型，服务器向客户端返回的信息也会不同。

DNS 服务器上事先保存有前面这 3 种信息对应的记录数据，DNS 服务器就是根据这些记录查找符合查询请求的内容并对客户端作出响应的。  
DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址。  

例如，如果要查询 www.lab.glasscom.com 这个域名对应的 IP 地址，客户端会向 DNS 服务器发送包含以下信息的查询消息。  
（a） 域名 = www.lab.glasscom.com；  
（b） Class = IN；  
（c） 记录类型 = A。  
然后，DNS 服务器会从已有的记录中查找域名、Class 和记录类型全部匹配的记录。  

### 域名的层次结构

如果是在像公司内部网络这样Web 和邮件服务器数量有限的环境中，所有的信息都可以保存在一台 DNS 服务器中，其工作方式也就完全符合我们前面讲解的内容。  
然而，互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台 DNS 服务器中是不可能的，因此一定会出现在 DNS 服务器中找不到要查询的信息的情况。  

此时 DNS 服务器的工作方式：  
将信息分布保存在多台 DNS 服务器中，这些 DNS 服务器相互接力配合，从而查找出要查询的信息。  

#### 信息是如何在 DNS 服务器上注册并保存的

DNS 服务器中的所有信息都是按照域名以分层次的结构来保存的。  
DNS 中的域名都是用句点来分隔的，比如 www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已。  
在域名中，越靠右的位置表示其层级越高，比如 www.lab.glasscom.com 这个域名如果按照公司里的组织结构来说，大概就是“com 事业集团 glasscom 部 lab 科的www”这样。  
其中，相当于一个层级的部分称为域。因此，com 域的下一层是 glasscom 域，再下一层是 lab 域，再下面才是 www 这个名字。  

这种具有层次结构的域名信息会注册到 DNS 服务器中，而每个域都是作为一个整体来处理的。  
换句话说就是，一个域的信息是作为一个整体存放在 DNS 服务器中的，不能将一个域拆开来存放在多台 DNS 服务器中。  
不过，DNS 服务器和域之间的关系也并不总是一对一的，一台DNS 服务器中也可以存放多个域的信息。  

### 寻找相应的 DNS 服务器并获取 IP 地址

如何找到 DNS 服务器中存放的信息的关键在于如何找到我们要访问的 Web 服务器的信息归哪一台 DNS 服务器管。  
互联网中有数万台 DNS 服务器，肯定不能一台一台挨个去找，我们可以采用下面的办法。  

首先，将负责管理下级域的 DNS 服务器的 IP 地址注册到它们的上级 DNS 服务器中，然后上级 DNS 服务器的 IP 地址再注册到更上一级的 DNS 服务器中，以此类推。  
这样，我们就可以通过上级 DNS 服务器查询出下级 DNS 服务器的 IP 地址，也就可以向下级 DNS 服务器发送查询请求了。  

也就是说，负责管理 lab.glasscom.com 这个域的 DNS 服务器的 IP 地址需要注册到 glasscom.com 域的 DNS 服务器中，  
而 glasscom.com 域的 DNS 服务器的IP 地址又需要注册到 com 域的 DNS 服务器中。  

#### 根域

在前面的讲解中，似乎com、jp 这些域（称为顶级域）就是最顶层了，它们各自负责保存下级DNS 服务器的信息，但实际上并非如此。在互联网中，com 和jp 的上面还有一级域，称为根域。  
根域不像 com、jp 那样有自己的名字，因此在一般书写域名时经常被省略；  
如果要明确表示根域，应该像 www.lab.glasscom.com. 这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。  

不过，一般都不写最后那个句点，因此根域的存在往往被忽略，但根域毕竟是真实存在的，根域的 DNS 服务器中保管着 com、jp 等的 DNS 服务器的信息。  
由于上级 DNS 服务器保管着所有下级 DNS 服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的 DNS 服务器。  

除此之外还需要完成另一项工作，那就是将根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。  
这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。  
因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。  

分配给根域 DNS 服务器的 IP 地址在全世界仅有 13 个，而且这些地址几乎不发生变化，因此将这些地址保存在所有的 DNS 服务器中也并不是一件难事。  
实际上，根域 DNS 服务器的相关信息已经包含在 DNS 服务器程序的配置文件中了，因此只要安装了 DNS 服务器程序，这些信息也就被自动配置好了。  

#### 具体实现流程

假设我们要查询 www.lab.glasscom.com 这台 Web 服务器的相关信息。  

1. 客户端首先会访问最近的一台 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）；
2. 由于最近的 DNS 服务器中没有存放 www.lab.glasscom.com 这一域名对应的信息，所以我们需要从顶层开始向下查找。
   - 最近的 DNS 服务器中保存了根域 DNS 服务器的信息，因此它会将来自客户端的查询消息转发给根域 DNS 服务器
3. 根域服务器中也没有 www.lab.glasscom.com 这个域名，但根据域名结构可以判断这个域名属于 com 域，因此根域 DNS 服务器会返回它所管理的 com 域中的 DNS 服务器的 IP 地址；
4. 最近的 DNS 服务器又会向 com 域的 DNS 服务器发送查询消息；
5. com 域中也没有 www.lab.glasscom.com这个域名的信息，和刚才一样，com 域服务器会返回它下面的 glasscom.com 域的 DNS 服务器的 IP 地址；
6. 以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标 DNS 服务器；
7. 只要向目标 DNS 服务器发送查询消息，就能够得到我们需要的答案，也就是 www.lab.glasscom.com 的 IP 地址了。
8. 收到客户端的查询消息之后，DNS 服务器会按照前面的方法来查询 IP 地址，并返回给客户端；
9. 这样，客户端就知道了 Web 服务器的 IP 地址，也就能够对其进行访问了。

### 通过缓存加快 DNS 服务器的响应

以上展示的是基本原理，与真实互联网中的工作方式还是有一些区别的。  
在真实的互联网中，一台 DNS 服务器可以管理多个域的信息，现实中上级域和下级域有可能共享同一台 DNS 服务器。  
在这种情况下，访问上级 DNS 服务器时就可以向下跳过一级 DNS 服务器，直接返回再下一级 DNS 服务器的相关信息。  

此外，有时候并不需要从最上级的根域开始查找，因为 DNS 服务器有一个缓存功能，可以记住之前查询过的域名。  
如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。  
相比每次都从根域找起来说，缓存可以减少查询所需的时间。  
并且，当要查询的域名不存在时，“不存在”这一响应结果也会被缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。  

这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。  
因此，DNS 服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。  
而且，在对查询进行响应时，DNS 服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的 DNS 服务器。  

## 委托协议栈发送消息

### 数据收发操作概览

知道了 IP 地址之后，就可以委托操作系统内部的协议栈向这个目标 IP 地址，也就是我们要访问的 Web 服务器发送消息了。  
要发送给 Web 服务器的 HTTP 消息是一种数字信息（digital data），因此也可以说是委托协议栈来发送数字信息。  
  - 收发数字信息这一操作不仅限于浏览器，对于各种使用网络的应用程序来说都是共通的；
  - 因此，这一操作的过程也不仅适用于 Web，而是适用于任何网络应用程序。

和向 DNS 服务器查询 IP 地址的操作一样，收发数字信息这一操作也需要使用 Socket 库中的程序组件。  
不过，查询 IP 地址只需要调用一个程序组件就可以了，而这里需要按照指定的顺序调用多个程序组件，这个过程有点复杂。  
发送数据是一系列操作相结合来实现的。  

使用 Socket 库来收发数据的操作过程，简单来说，就像收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。  
我们可以把数据通道想象成一条管道，将数据从一端送入管道，数据就会到达管道的另一端然后被取出。  
  - 数据可以从任何一端被送入管道，数据的流动是双向的。
  - 不过，这并不是说现实中真的有这么一条管道，只是为了帮助大家理解数据收发操作的全貌。
收发数据的整体思路就是这样，但还有一点也非常重要。  
在进行收发数据操作之前，双方需要先建立起这条管道才行。  
  - 建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字。我们需要先创建套接字，然后再将套接字连接起来形成管道。  

实际的过程是下面这样的：  
1. 服务器一方先创建套接字，然后等待客户端向该套接字连接管道；
   - 服务器程序一般会在启动后就创建好套接字并等待客户端连接管道。
2. 当服务器进入等待状态时，客户端就可以连接管道了；
   - 客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务器端的套接字上。
3. 当双方的套接字连接起来之后，通信准备就完成了；
4. 接下来，只要将数据送入套接字就可以收发数据了；
5. 当数据全部发送完毕之后，连接的管道将会被断开；
   - 管道在连接时是由客户端发起的，但在断开时可以由客户端或服务器任意一方发起。
   - 其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。
6. 到此为止，通信操作就结束了。

综上所述，收发数据的操作分为若干个阶段，可以大致总结为以下 4 个。  
1. 创建套接字（创建套接字阶段）；
2. 将管道连接到服务器端的套接字上（连接阶段）；
3. 收发数据（通信阶段）；
4. 断开管道并删除套接字（断开阶段）。

在每个阶段，Socket 库中的程序组件都会被调用来执行相关的数据收发操作。  
前面这 4 个操作都是由操作系统中的协议栈来执行的，浏览器等应用程序并不会自己去做连接管道、放入数据这些工作，而是委托协议栈来代劳。  
本章只介绍“委托”这个操作。关于协议栈收到委托之后具体是如何连接管道和放入数据的将在第 2 章介绍。  

此外，这些委托的操作都是通过调用 Socket 库中的程序组件来执行的。  
但这些数据通信用的程序组件其实仅仅充当了一个桥梁的角色，并不执行任何实质性的操作，应用程序的委托内容最终会被原原本本地传递给协议栈。  
因此，我们无法形象地展示这些程序组件到底完成了怎样的工作，与其勉强强调 Socket 库的存在，还不如将 Socket 库和协议栈看成一个整体并讲解它们的整体行为让人更容易理解。  
因此，后文将会采用这样的讲法。不过，请大家不要忘记 Socket 库这一桥梁的存在。  

### 创建套接字阶段

应用程序（浏览器）委托收发数据的过程关键点就是像对 DNS 服务器发送查询一样，  
调用 Socket 库中的特定程序组件访问 DNS 服务器时我们调用的是一个叫作 gethostbyname 的程序组件（也就是解析器），而这一次则需要按照一定的顺序调用若干个程序组件。  

首先是套接字创建阶段。客户端创建套接字的操作非常简单，只要调用 Socket 库中的 socket 程序组件就可以了。  
  - 调用 Socket 库中的程序组件的思路和调用解析器是一样的，调用解析器是在程序中直接写解析器的程序名`gethostbyname`即可；  
  - 和调用解析器一样，调用 socket 之后，控制流程会转移到socket 内部并执行创建套接字的操作，完成之后控制流程又会被移交回应用程序。
套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中；  
  - 描述符是用来识别不同的套接字的；
  - 因为同一台计算机上可能同时存在多个套接字，在这样的情况下，我们就需要一种方法来识别出某个特定的套接字，这种方法就是描述符。
当创建套接字后，我们就可以使用这个套接字来执行收发数据的操作了。  
  - 这时，只要我们出示描述符，协议栈就能够判断出我们希望用哪一个套接字来连接或者收发数据了；
  - 应用程序是通过“描述符”这一类似号码牌的东西来识别套接字的。

### 连接阶段：把管道接上去

接下来，我们需要委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序通过调用 Socket 库中的名为 connect 的程序组件来完成这一操作。  
这里的要点是当调用 connect 时，需要指定描述符、服务器 IP 地址和端口号这 3 个参数。  

1. 描述符；
   - 就是在创建套接字的时候由协议栈返回的那个描述符。
     - connect 会将应用程序指定的描述符告知协议栈，然后协议栈根据这个描述符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接的操作。
2. 服务器 IP 地址；
   - 就是通过 DNS 服务器查询得到的我们要访问的服务器的 IP 地址。
3. 端口号。
   - IP 地址是为了区分网络中的各个计算机而分配的数值。因此，只要知道了 IP 地址，我们就可以识别出网络上的某台计算机；
   - 但是，连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行，而仅凭 IP 地址是无法做到这一点的；
   - 当同时指定 IP 地址和端口号时，就可以明确识别出某台具体的计算机上的某个具体的套接字。

#### 端口号

能否使用描述符来识别套接字？  
描述符是和委托创建套接字的应用程序进行交互时使用的，并不是用来告诉网络连接的另一方的，因此另一方并不知道这个描述符。  
同样地，客户端也无法知道服务器上的描述符。因此，客户端也无法通过服务器端的描述符去确定位于服务器上的某一个套接字。  

所以，我们需要另外一个对客户端也同样适用的机制，而这个机制就是端口号。  
如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。  

##### 实现规定好的端口号

服务器上所使用的端口号是根据应用的种类事先规定好的，仅此而已。比如 Web 是 80 号端口，电子邮件是 25 号端口。  
关于端口号，我们将在第 6 章探索服务器内部工作的时候进行介绍，这里大家只要这样记住就行了：只要指定了事先规定好的端口号，就可以连接到相应的服务器程序的套接字。  
也就是说，浏览器访问 Web 服务器时使用 80 号端口，这是已经规定好的。  

端口号的规则是全球统一的，为了避免重复和冲突，端口号和 IP 地址一样都是由 IANA（Internet Assigned Number Authority，互联网编号管理局）这一组织来统一管理的。  

##### 客户端的端口

既然确定连接对象的套接字需要使用端口号，那么服务器也得知道客户端的套接字号码才行吧，这个问题是怎么解决的呢？  
事情是这样的，首先，客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。  
接下来，当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。  
  - 这部分内容我们会在第2 章探索协议栈内部工作时进行介绍。
  - 在创建套接字时，服务器也可以自行指定端口号，但一般并不常用。

总而言之，就是当调用 connect 时，协议栈就会执行连接操作。  
当连接成功后，协议栈会将对方的 IP 地址和端口号等信息保存在套接字中，这样我们就可以开始收发数据了。  

### 通信阶段：传递消息

当套接字连接起来之后，剩下的事情就简单了。只要将数据送入套接字，数据就会被发送到对方的套接字中。
当然，应用程序无法直接控制套接字，因此还是要通过 Socket 库委托协议栈来完成这个操作。
这个操作需要使用 write 这个程序组件，具体过程如下：
1. 当调用 write 时，需要指定描述符和发送数据，然后协议栈就会将数据发送到服务器。
   - 应用程序需要在内存中准备好要发送的数据，根据用户输入的网址生成的 HTTP 请求消息就是我们要发送的数据。
   - 由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。
2. 当发送数据会通过网络到达我们要访问的服务器，服务器执行接收操作，解析收到的数据内容并执行相应的操作，向客户端返回响应消息；
3. 当消息返回后，需要执行的是接收消息的操作。
   - 接收消息的操作是通过 Socket 库中的 read 程序组件委托协议栈来完成的。
   - 调用 read 时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。
4. 当服务器返回响应消息时，read 就会负责将接收到的响应消息存放到接收缓冲区中。
   - 由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。

### 断开阶段：收发数据结束

当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需要调用Socket 库的 close 程序组件进入断开阶段。  
最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。  

断开的过程如下：  
1. Web 使用的 HTTP 协议规定，当 Web 服务器发送完响应消息之后，应该主动执行断开操作，因此 Web 服务器会首先调用 close 来断开连接。
2. 断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。
3. 接下来，当浏览器调用 read 执行接收数据操作时，read 会告知浏览器收发数据操作已结束，连接已经断开。
4. 浏览器得知后，也会调用 close 进入断开阶段。

这就是 HTTP 的工作过程。HTTP 协议将HTML 文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。  
因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。  
对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。  
在HTTP 版本1.1 中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。  

> 本章我们探索了浏览器与 Web 服务器之间收发消息的过程，但实际负责收发消息的是协议栈、网卡驱动和网卡，只有这 3 者相互配合，数据才能够在网络中流动起来。
  下一章我们将对这一部分进行探索。

>	zongjie
	1. 浏览器解析URL，并根据 HTTP 协议进行客户端和服务器之间交互的消息内容和步骤
	2. 生成请求信息：包括方法和 URI
	3. 解析器调用协议栈，协议栈向最近的 DNS 服务器发送查询 Web 服务器的 IP 地址的信息
	4. 一层层查下去直到查到对应域名的 IP 地址
	5. 信息传回客户端，协议栈传回解析器，解析器传回应用程序
	6. 得知 IP 地址，客户端根据端口、描述符、IP 地址找到对应 IP 地址的套接字，
	7. 告知对应设备客户端的套接字信息
	8. 两个套接字连接
	9. 使用 write 发送信息进入客户端的套接字传送到服务器的套接字
	10. 服务器发回信息，使用 read 把返回信息放到接收缓存区
	11. 发送结束服务器断开，接着客户端断开，接着浏览器断开

# 用电信号传输 TCP/IP 数据

## 热身问答

1. 一般情况下，以太网的头部（网络包开头的控制信息）格式并非遵循国际标准（IEEE802.3/802.2），而是遵循一个更古老的规格（以太网第 2 版，又称 DIX 规格），  
   相对地，国际标准（IEEE802.3/802.2）的头部格式由于长度太长、效率降低而没有普及。  
2. 最早的 TCP/IP 协议原型设计相当于现在的 TCP 和 IP 合在一起的样子，后来才拆分成为 TCP 和 IP 两个协议。  
3. 在网络包出现之前，通信都是像电话一样把线路连接起来进行的。但是，连接线路的通信方式只能和固定的对象进行通信，无法发挥计算机可以处理多种工作的特点。  
   为了解决这个问题，人们设计出了使用网络包来进行通信的方式。  

## 看点

### 创建套接字

从应用程序收到委托后，协议栈通过 TCP 协议收发数据的操作可以分为 4 个阶段。  
首先是创建套接字，在这个阶段，我们将介绍协议栈的内部结构、套接字的实体，以及创建套接字的操作过程。  

### 连接服务器

接下来是客户端套接字向服务器套接字进行连接的阶段。  
我们将介绍“连接”具体是进行怎样的操作，在这个过程中协议栈到底是如何工作的，以及客户端和服务器是如何进行交互的。  

### 收发数据

两端的套接字完成连接之后，就进入收发消息的阶段了。在这个阶段，协议栈会将从应用程序收到的数据切成小块并发送给服务器。  
考虑到通信过程中可能会出错导致网络包丢失，协议栈还需要确认切分出的每个包是否已经送达服务器，  对于没有送达的包要重新发送一次。  

### 从服务器断开连接并删除套接字

收发消息的操作全部结束之后，接下来要断开服务器的连接并删除套接字。  
断开操作的本质是当消息收发完成后客户端和服务器相互进行确认的过程，但这个过程并不只是相互确认并删除套接字那么简单。  

### IP 与以太网的包收发操作

在介绍 TCP 协议收发消息的操作之后，我们再来看看实际的网络包是如何进行收发的。  
协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号或者光信号发送出去。  

### 用 UDP 协议收发数据的操作

TCP 协议有很多方便的功能，比如网络包出错丢失时可以重发，因此很多应用程序都是使用 TCP 协议来收发数据的，但这些方便的功能也有帮倒忙的时候。  
在这种情况下我们还有另外一种叫 UDP 的协议。这里我们将介绍 UDP 的必要性以及它与 TCP 的差异。  

## 创建套接字

本章将说明操作系统中的网络控制软件（协议栈）和网络硬件（网卡）是如何将浏览器的消息发送给服务器的。  

### 协议栈的内部结构

和浏览器不同的是，协议栈的工作我们从表面上是看不见的，可能比较难以想象。  

协议栈的内部分为几个部分，分别承担不同的功能。  
1. 协议栈的上半部分有两块；
   - 分别是负责用 TCP 协议收发数据的部分；
   - 负责用 UDP 协议收发数据的部分；
   - TCP 协议和 UDP 协议会接受应用程序的委托执行收发数据的操作；
   - 像浏览器、邮件等一般的应用程序都是使用 TCP 收发数据的，而像 DNS 查询等收发较短的控制数据的时候则使用 UDP。  
2. 下面一半是用 IP 协议控制网络包收发操作的部分。
  - 在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由 IP 来负责的；
  - 此外，IP 中还包括 ICMP 协议和 ARP 协议；
  - ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息；
  - ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

#### TCP/IP 软件的分层结构

TCP/IP 软件采用分层结构，包括应用程序、操作系统、驱动程序、硬件四个部分，四部分由上而下。  
上面的部分会向下面的部分委派工作，下面的部分接受委派的工作并实际执行。  
当然，这一上下关系只是一个总体的规则，其中也有一部分上下关系不明确，或者上下关系相反的情况，所以也不必过于纠结。  

1. 最上面的部分是网络应用程序；
   - 也就是浏览器、电子邮件客户端、Web 服务器、电子邮件服务器等程序，它们会将收发数据等工作委派给下层的部分来完成。
   - 除了浏览器之外，其他应用程序在网络上收发数据的操作也都是类似上面这样的
     - 也就是说，尽管不同的应用程序收发的数据内容不同，但收发数据的操作是共通的。
     - 因此，下面介绍的内容不仅适用于浏览器，也适用于各种应用程序。
2. 应用程序的下面是 Socket 库，其中包括解析器，解析器用来向 DNS 服务器发出查询；
3. 再下面就是操作系统内部了，其中包括协议栈；
4. IP 下面的网卡驱动程序负责控制网卡硬件，
5. 最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。

### 套接字的实体就是通信控制信息

在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP 地址、端口号、通信操作的进行状态等。  
本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。  

协议栈在执行操作时需要参阅这些控制信息。  
例如，在发送数据时，需要看一看套接字中的通信对象 IP 地址和端口号，以便向指定的 IP 地址和端口发送数据。  
在发送数据之后，协议栈需要等待对方返回收到数据的响应信息，但数据也可能在中途丢失，永远也等不到对方的响应。  
在这样的情况下，我们不能一直等下去，需要在等待一定时间之后重新发送丢失的数据，这就需要协议栈能够知道执行发送数据操作后过了多长时间。  
为此，套接字中必须要记录是否已经收到响应，以及发送数据后经过了多长时间，才能根据这些信息按照需要执行重发操作。  

上面说的只是其中一个例子。套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。  
协议栈是根据套接字中记录的控制信息来工作的。  

### 调用 socket 时的操作

当浏览器调用socket、connect 等 Socket 库中的程序组件时，协议栈内部是如何工作的。

1. 首先是创建套接字的阶段；
应用程序调用 socket 申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。  
在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。  
  - 用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们先要开辟出这样一块空间来，这相当于为控制信息准备一个容器；
  - 但光一个容器并没有什么用，还需要往里面存入控制信息。
套接字刚刚创建时，数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。  
到这里，创建套接字的操作就完成了。  

2. 接下来，需要将表示这个套接字的描述符告知应用程序；  
   - 描述符相当于用来区分协议栈中的多个套接字的号码牌。

3. 收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。
由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息。  
这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。  

## 连接服务器

### 连接是什么意思

创建套接字之后，应用程序（浏览器）就会调用 connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。  
连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作。  
  - 所谓控制信息，就是用来控制数据收发操作所需的一些信息，IP 地址和端口号就是典型的例子。

网线是一直连接着的，随时都有信号从中流过，如果通信过程只是将数据转换为电信号，那么这一操作随时都可以进行。  
不过，在这个时间点，也就是套接字刚刚创建完成时，当应用程序委托发送数据的时候，协议栈会如何操作呢？  

对于客户端方面来说，套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。  
在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。  
浏览器可以根据网址来查询服务器的 IP 地址，而且根据规则也知道应该使用 80 号端口，但只有浏览器知道这些必要的信息是不够的；  
因为在调用 socket 创建套接字时，这些信息并没有传递给协议栈。  
因此，我们需要把服务器的 IP 地址和端口号等信息告知协议栈，这是连接操作的目的之一。  

此时服务器上也会创建套接字，但服务器上的协议栈和客户端一样，只创建套接字是不知道应该和谁进行通信的。  
而且，和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁，这样下去永远也没法开始通信。  
于是，我们需要让客户端向服务器告知必要的信息，比如“我想和你开始通信，我的IP 地址是xxx.xxx.xxx.xxx，端口号是yyyy。”  
可见，客户端向服务器传达开始通信的请求，也是连接操作的目的之一。  

连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备。  
此外，当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的。  

上面这些就是“连接”这个词代表的具体含义。  

### 负责保存控制信息的头部

控制信息其实可以大体上分为两类。  

第一类是客户端和服务器相互联络时交换的控制信息。  
这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程中都需要，  
这些内容在 TCP 协议的规格中进行了定义。  

这些字段是固定的，在连接、收发、断开等各个阶段中，每次客户端和服务器之间进行通信时，都需要提供这些控制信息。  
具体来说，这些信息会被添加在客户端与服务器之间传递的网络包的开头。在连接阶段，由于数据收发还没有开始，所以网络包中没有实际的数据，只有控制信息。  

这些控制信息位于网络包的开头，因此被称为头部。
此外，以太网和 IP 协议也有自己的控制信息，这些信息也叫头部，为了避免各种不同的头部发生混淆，我们一般会记作 TCP 头部、以太网头部、IP 头部。
客户端和服务器在通信中会将必要的信息记录在头部并相互确认。  
头部的信息非常重要，理解了头部各字段的含义，就等于理解了整个通信的过程。  

TCP 头部格式：  
|字段名称|长度（比特）|含义|
|---|---|---|
|发送方端口号|16|发送网络包的程序的端口号|
|接收方端口号|16|网络包的接收方程序的端口号|
|序号（发送数据的顺序编号）|32|发送方告知接收方该网络包发送的数据相当于所有发送数据的第几个字节|
|ACK 号（接收数据的顺序编号）|32|接收方告知发送方接收方已经收到了所有数据的第几个字节。其中，ACK 是acknowledge 的缩写|
|数据偏移量|4|表示数据部分的起始位置，也可以认为表示头部的长度|
|保留|6|该字段为保留，现在未使用|
|控制位|6|该字段中的每个比特分别表示以下通信控制含义。
URG：表示紧急指针字段有效
ACK：表示接收数据序号字段有效，一般表示数据已被接收方收到
PSH：表示通过 flush 操作发送的数据
RST：强制断开连接，用于异常中断的情况
SYN：发送方和接收方相互确认序号，表示连接操作
FIN：表示断开连接|
|窗口|16|接收方告知发送方窗口大小（即无需等待确认可一起发送的数据量）|
|校验和|16|用来检查是否出现错误|
|紧急指针|16|表示应紧急处理的数据位置|
|可选字段|可变长度|除了上面的固定头部字段之外，还可以添加可选字段，但除了连接操作之外，很少使用可选字段|

控制信息的第二类是保存在套接字中，用来控制协议栈操作的信息。  
应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。  

我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的，因此，“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同，但这并没有什么问题。  
因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。  
例如，Windows 和 Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同。  
但即便如此，两种系统之间依然能够互相通信，同样地，计算机和手机之间也能够互相通信。  
正如前面所说，协议栈的实现不同，因此我们无法具体说明协议栈里到底保存了哪些控制信息，但可以用命令来显示一些重要的套接字控制信息，  
这些信息无论何种操作系统的协议栈都是共通的，通过理解这些重要信息，就能够理解协议栈的工作方式了。  

> 网络包的结构是“以太网和 IP 的控制信息” + “ TCP 的控制信息” + “数据块”。

### 连接操作的实际过程

连接的具体操作过程是从应用程序调用Socket 库的connect 开始的。  
`connect（< 描述符>, < 服务器IP 地址和端口号>, …）`  
上面的调用提供了服务器的 IP 地址和端口号，这些信息会传递给协议栈中的 TCP 模块。  
然后，TCP 模块会与该 IP 地址对应的对象，也就是与服务器的 TCP 模块交换控制信息，这一交互过程包括下面几个步骤。  

1. 客户端先创建一个包含表示开始数据收发操作的控制信息的头部；
   - 头部包含很多字段，这里要关注的重点是发送方和接收方的端口号；
   - 这样，客户端（发送方）的套接字就准确找到了服务器（接收方）的套接字，也就是搞清楚了我应该连接哪个套接字；
   - 我们将头部中的控制位的 SYN 比特设置为 1，大家可以认为它表示连接。此外还需要设置适当的序号和窗口大小。
2. 当 TCP 头部创建好之后，接下来 TCP 模块会将信息传递给 IP 模块并委托它进行发送；
3. IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器；
4. 然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块，服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字；
   - 也就是说，从处于等待连接状态的套接字中找到与 TCP 头部中记录的端口号相同的套接字就可以了。
5. 当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接；
6. 上述操作完成后，服务器的 TCP 模块会返回响应，这个过程和客户端一样，需要在 TCP 头部中设置发送方和接收方端口号以及 SYN 比特；
   - 此外，在返回响应时还需要将 ACK 控制位设为1，这表示已经接收到相应的网络包；
   - 网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达，而设置 ACK 比特就是用来进行这一确认的；
   - 客户端向服务器发送第一个网络包时，由于服务器还没有接收过网络包，所以需要将 ACK 比特设为0。
7. 接下来，服务器 TCP 模块会将 TCP 头部传递给 IP 模块，并委托 IP 模块向客户端返回响应；
8. 然后，网络包就会返回到客户端，通过 IP 模块到达 TCP 模块，并通过 TCP 头部的信息确认连接服务器的操作是否成功；
   - 如果 SYN 为 1 则表示连接成功，这时会向套接字中写入服务器的 IP 地址、端口号等信息，同时还会将状态改为连接完毕；
   - 到这里，客户端的操作就已经完成。
9. 刚才服务器返回响应时将 ACK 比特设置为 1，相应地，客户端也需要将 ACK 比特设置为 1 并发回服务器，告诉服务器刚才的响应包已经收到。
   - 当这个服务器收到这个返回包之后，连接操作才算全部完成。

头部和套接字之间的关系是？

## 收发数据

### 将 HTTP 请求消息交给协议栈

当控制流程从 connect 回到应用程序之后，接下来就进入数据收发阶段了。  
数据收发操作是从应用程序调用 write 将要发送的数据交给协议栈开始的，协议栈收到数据后执行发送操作，这一操作包含如下要点：  

1. 协议栈并不关心应用程序传来的数据是什么内容；  
   - 应用程序在调用 write 时会指定发送数据的长度，在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已。

2. 协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。  
   - 这样做是有道理的。应用程序交给协议栈发送的数据长度是由应用程序本身来决定的，不同的应用程序在实现上有所不同。
     - 有些程序会一次性传递所有的数据，有些程序则会逐字节或者逐行传递数据；
     - 总之，一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为；
     - 在这样的情况下，如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。

至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的：  

1. 每个网络包能容纳的数据长度；  
   - 协议栈会根据一个叫作MTU（Maximum Transmission Unit，最大传输单元）的参数来进行判断。
     - MTU 表示一个网络包的最大长度，在以太网中一般是1500 字节。
   - MTU 是包含头部的总长度，因此需要从MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作MSS（Maximum Segment Size，最大分段大小）。
   - 当从应用程序收到的数据长度超过或者接近MSS 时再发送出去，就可以避免发送大量小包的问题了。

2. 时间。
   - 当应用程序发送数据的频率不高的时候，如果每次都等到长度接近MSS 时再发送，可能会因为等待时间太长而造成发送延迟，
     - 这种情况下，即便缓冲区中的数据长度没有达到MSS，也应该果断发送出去。
   - 为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去，这个时间并没有多长，是以毫秒为单位来计算的。

判断要素就是这两个，但它们其实是互相矛盾的。  
- 如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟；
- 如果时间优先，那么延迟时间会变少，但又会降低网络的效率。
- 因此，在进行发送操作时需要综合考虑这两个要素以达到平衡。
不过，TCP 协议规格中并没有告诉我们怎样才能平衡，因此实际如何判断是由协议栈的开发者来决定的，  
也正是由于这个原因，不同种类和版本的操作系统在相关操作上也就存在差异。  

正如前面所说，如果仅靠协议栈来判断发送的时机可能会带来一些问题，因此协议栈也给应用程序保留了控制发送时机的余地。  
应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。  
像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。  

### 对较大的数据进行拆分

HTTP 请求消息一般不会很长，一个网络包就能装得下，  
但如果其中要提交表单数据，长度就可能超过一个网络包所能容纳的数据量，比如在博客或者论坛上发表一篇长文就属于这种情况。  

这种情况下，发送缓冲区中的数据就会超过 MSS 的长度，这时我们当然不需要继续等待后面的数据了。  
发送缓冲区中的数据会被以 MSS 长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。  
根据发送缓冲区中的数据拆分的情况，当判断需要发送这些数据时，就在每一块数据前面加上 TCP 头部，并根据套接字中记录的控制信息标记发送方和接收方的端口号，  
然后交给 IP 模块来执行发送数据的操作，IP 模块会在网络包前面添加 IP 头部和以太网的 MAC 头部后发送网络包。  

### 使用 ACK 号确认网络包已收到

到这里，网络包已经装好数据并发往服务器了，但数据发送操作还没有结束。  
TCP 具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作。  

确认的原理：  

首先，TCP 模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在 TCP 头部中，“序号”字段就是派在这个用场上的。  
然后，发送数据的长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。  
有了上面两个数值，我们就可以知道发送的数据是从第几个字节开始，长度是多少了。  

通过这些信息，接收方还能够检查收到的网络包有没有遗漏。  
例如，假设上次接收到第 1460 字节，那么接下来如果收到序号为 1461 的包，说明中间没有遗漏；但如果收到的包序号为 2921，那就说明中间有包遗漏了。  
像这样，如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入 TCP 头部的 ACK 号中发送给发送方。  
  - 返回 ACK 号时，除了要设置 ACK 号的值以外，还需要将控制位中的 ACK 比特设为 1，这代表 ACK 号字段有效，接收方也就可以知道这个网络包是用来告知 ACK 号的。
这个返回 ACK 号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据。  
  - 在实际的通信中，序号并不是从 1 开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。
    - 但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。

> 在刚才讲过的连接过程中，有一个将 SYN 控制位设为 1 并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。  
  实际上，在将 SYN 设为1 的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值 SYN 为 1 表示进行连接，  
  这是因为将 SYN 设为 1 并告知初始序号这一操作仅在连接过程中出现，因此发送 SYN 为 1 的网络包就表示发起连接的意思。  
  实际上，SYN 是 Synchronize（同步）的缩写，意思是通过告知初始序号使通信双方保持步调一致，以便完成后续的数据收发检查，这才是SYN 原本的含义。  

前面介绍了通过序号和 ACK 号来进行数据确认的思路，但仅凭这些还不够。  
因为刚刚只考虑了单向的数据传输，但 TCP 数据收发是双向的，在客户端向服务器发送数据的同时，服务器也会向客户端发送数据，因此必须要想办法应对这样的情况。  
不过，这其实也不难，只要增加一种左右相反的情形就可以了。  
首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算 ACK 号并返回给客户端。  
相反地，服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算 ACK 号并返回给服务器。  
此外，客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。  

#### 实际工作流程

1. 首先，客户端在连接时需要计算出与从客户端到服务器方向通信相关的序号初始值，并将这个值发送给服务器；
2. 接下来，服务器会通过这个初始值计算出 ACK 号并返回给客户端，同时，服务器也需要计算出与从服务器到客户端方向通信相关的序号初始值，并将这个值发送给客户端；
   - 初始值有可能在通信过程中丢失，因此当服务器收到初始值后需要返回 ACK 号作为确认。
3. 接下来像刚才一样，客户端也需要根据服务器发来的初始值计算出 ACK 号并返回给服务器；
4. 到这里，序号和 ACK 号都已经准备完成了，接下来就可以进入数据收发阶段了。

数据收发操作本身是可以双向同时进行的，但 Web 中是先由客户端向服务器发送请求，序号也会跟随数据一起发送；  
然后，服务器收到数据后再返回 ACK 号；  
从服务器向客户端发送数据的过程则正好相反。  

TCP 采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的 ACK 号，那么就重新发送这些包。  
通过这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）。  
反过来说，有了这一机制，我们就不需要在其他地方对错误进行补救了。  

因此，网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。  
应用程序也是一样，因为采用 TCP 传输，即便发生一些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好了。  

不过，如果发生网络中断、服务器宕机等问题，那么无论 TCP 怎样重传都不管用。  
这种情况下，无论如何尝试都是徒劳，因此 TCP 会在尝试几次重传无效之后强制结束通信，并向应用程序报错。  

### 根据网络包平均往返时间调整 ACK 号等待时间

返回 ACK 号的等待时间（这个等待时间叫超时时间）。  

当网络传输繁忙时就会发生拥塞，ACK 号的返回会变慢，这时我们就必须将等待时间设置得稍微长一点，否则可能会发生已经重传了包之后，前面的 ACK 号才姗姗来迟的情况。  
这样的重传是多余的，看上去只是多发一个包而已，但它造成的后果却没那么简单。  
- 因为 ACK 号的返回变慢大多是由于网络拥塞引起的，因此如果此时再出现很多多余的重传，对于本来就很拥塞的网络来说无疑是雪上加霜；
- 不过如果某一个包被重复发送多次，接收方可以根据序号判断出这个包是重复的，因此并不会造成网络异常。

但如果等待时间过长，那么包的重传就会出现很大的延迟，也会导致网络速度变慢。  

等待时间需要设为一个合适的值，不能太长也不能太短，但这并不容易。  
根据服务器物理距离的远近，ACK 号的返回时间也会产生很大的波动，而且我们还必须考虑到拥塞带来的影响。  
- 例如，在公司里的局域网环境下，几毫秒就可以返回 ACK 号，但在互联网环境中，当遇到拥塞时需要几百毫秒才能返回ACK 号也并不稀奇。

正因为波动如此之大，所以将等待时间设置为一个固定值并不是一个好办法。  
因此，TCP 采用了动态调整等待时间的方法，这个等待时间是根据 ACK 号返回所需的时间来判断的。  
- 具体来说，TCP 会在发送数据的过程中持续测量ACK 号的返回时间，
  - 如果ACK 号返回变慢，则相应延长等待时间；
  - 相对地，如果ACK 号马上就能返回，则相应缩短等待时间。
- 由于计算机的时间测量精度较低，ACK 返回时间过短时无法被正确测量，因此等待时间有一个最小值，这个值在每个操作系统上不一样，基本上是在0.5 秒到1 秒之间。

### 使用窗口有效管理 ACK 号

每发送一个包就等待一个 ACK 号的方式是最简单也最容易理解的，但在等待 ACK 号的这段时间中，如果什么都不做那实在太浪费了。  
为了减少这样的浪费，TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作。  
- 所谓滑动窗口，就是在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。
- 这样一来，等待 ACK 号的这段时间就被有效利用起来了。

虽然这样做能够减少等待 ACK 号时的时间浪费，但有一些问题需要注意。  
在一来一回方式中，接收方完成接收操作后返回 ACK 号，然后发送方收到 ACK 号之后才继续发送下一个包，因此不会出现发送的包太多接收方处理不过来的情况。  
但如果不等返回 ACK 号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况。  

具体解释一下。  
当接收方的 TCP 收到包后，会先将数据存放到接收缓冲区中。  
然后，接收方需要计算 ACK 号，将数据块组装起来还原成原本的数据并传递给应用程序，如果这些操作还没完成下一个包就到了也不用担心，因为下一个包也会被暂存在接收缓冲区中。  
如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。  
缓冲区溢出之后，后面的数据就进不来了，因此接收方就收不到后面的包了，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力。  

可以通过下面的方法来避免这种情况的发生。  
首先，接收方需要告诉发送方自己最多能接收多少数据；  
然后发送方根据这个值对数据发送操作进行控制；  
这就是滑动窗口方式的基本思路。  

#### 滑动窗口的具体工作方式

接收方将数据暂存到接收缓冲区中并执行接收操作；  
当接收操作完成后，接收缓冲区中的空间会被释放出来，也就可以接收更多的数据了；  
这时接收方会通过TCP 头部中的窗口字段将自己能接收的数据量告知发送方；  
这样一来，发送方就不会发送过多的数据，导致超出接收方的处理能力了。  

接收方在收到数据之后马上就会开始进行处理，如果接收方的性能高，处理速度比包的到达速率还快，缓冲区马上就会被清空，并通过窗口字段告知发送方。  

能够接收的最大数据量称为窗口大小。  

### ACK 与窗口的合并

要提高收发数据的效率，还需要考虑另一个问题，那就是返回 ACK 号和更新窗口的时机。

首先，对于更新窗口大小的时机；
当收到的数据刚刚开始填入缓冲区时，其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度。
因此，更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候。
  - 这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作，
    - 因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机。

当接收方收到数据时，如果确认内容没有问题，就应该向发送方返回 ACK 号，因此我们可以认为收到数据之后马上就应该进行这一操作。

如果将前面两个因素结合起来看：  
首先，发送方的数据到达接收方，在接收操作完成之后就需要向发送方返回 ACK 号，而再经过一段时间，当数据传递给应用程序之后才需要更新窗口大小。

但如果根据这样的设计来实现，每收到一个包，就需要向发送方分别发送 ACK 号和窗口更新这两个单独的包。
这样一来，接收方发给发送方的包就太多了，导致网络效率下降。
因此，接收方在发送ACK 号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了。

举些例子：
- 在等待发送 ACK 号的时候正好需要更新窗口，这时就可以把 ACK 号和窗口更新放在一个包里发送，从而减少包的数量；
- 当需要连续发送多个 ACK 号时，也可以减少包的数量，只要发送最后一个ACK 号就可以了，中间的可以全部省略；
  - 这是因为 ACK 号表示的是已收到的数据量，也就是说，它是告诉发送方目前已接收的数据的最后位置在哪里，
- 当需要连续发送多个窗口更新时也可以减少包的数量，这种情况和 ACK 号一样，可以省略中间过程，只要发送最终的结果就可以了。
  - 连续发生窗口更新说明应用程序连续请求了数据，接收缓冲区的剩余空间连续增加。

### 接收 HTTP 响应消息

至此讲解完协议栈接到浏览器委托后发送 HTTP 请求消息的一系列操作过程了。  
不过，浏览器的工作并非到此为止。发送 HTTP 请求消息后，接下来还需要等待 Web 服务器返回响应消息。  
对于响应消息，浏览器需要进行接收操作，这一操作也需要协议栈的参与。  

首先，浏览器在委托协议栈发送请求消息之后，会调用 read 程序来获取响应消息。  
然后，控制流程会通过 read 转移到协议栈，  
然后协议栈会执行接下来的操作。  

和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下：  
首先，协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。  
响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。  
这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作。  

> 大家可以认为这时协议栈会进入暂停状态，但实际上并非如此。  
  协议栈会负责处理来自很多应用程序的工作，因此挂起其中一项工作并不意味着协议栈就完全暂停了，协议栈会继续执行其他的工作。  
  在执行其他工作的时候，挂起的工作并没有在执行，因此看上去和暂停是一样的。  

之前有说过协议栈接收数据的具体操作，这里进行简单总结：  
首先，协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号；  
然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序；  
- 具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。
将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新。  
- 如果窗口更新能够和 ACK 号等合并的话，在这里就会发送合并后的包。

## 从服务器断开并删除套接字

### 数据发送完毕后断开连接

应用程序判断所有数据都已经发送完毕时，数据发送完毕的一方会发起断开过程，但不同的应用程序会选择不同的断开时机。  

以 Web 为例：  
浏览器向 Web 服务器发送请求消息，Web 服务器再返回响应消息，这时收发数据的过程就全部结束了，服务器一方会发起断开过程。  
  - 这里讲的是 HTTP 1.0 的情形；
  - 在 HTTP 1.1 中，服务器返回响应消息之后，客户端还可以继续发起下一个请求消息，如果接下来没有请求要发送了，客户端一方会发起断开过程。

也有一些程序是客户端发送完数据就结束了，不用等服务器响应，这时客户端会先发起断开过程。  
这一判断是应用程序作出的，协议栈在设计上允许任何一方先发起断开过程。  

无论哪种情况，完成数据发送的一方会发起断开过程，这里我们以服务器一方发起断开过程为例来进行讲解。  
首先，服务器一方的应用程序会调用 Socket 库的 close 程序。  
然后，服务器的协议栈会生成包含断开信息的 TCP 头部，具体来说就是将控制位中的 FIN 比特设为 1。  
接下来，协议栈会委托IP 模块向客户端发送数据。  
- 同时，服务器的套接字中也会记录下断开操作的相关信息。

接下来轮到客户端了。  
当收到服务器发来的 FIN 为 1 的 TCP 头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态；  
然后，为了告知服务器已收到 FIN 为 1 的包，客户端会向服务器返回一个 ACK 号；  
这些操作完成后，协议栈就可以等待应用程序来取数据了；  
过了一会儿，应用程序就会调用 read 来读取数据；
- 这时，协议栈不会向应用程序传递数据，而是会告知应用程序（浏览器）来自服务器的数据已经全部收到了；
- 根据规则，服务器返回请求之后，Web 通信操作就全部结束了，因此只要收到服务器返回的所有数据，客户端的操作也就随之结束了。
客户端应用程序会调用 close 来结束数据收发操作；  
这时客户端的协议栈也会和服务器一样，生成一个 FIN 比特为 1 的 TCP 包，然后委托 IP 模块发送给服务器；  
一段时间之后，服务器就会返回 ACK 号；  
到这里，客户端和服务器的通信就全部结束了。  

### 删除套接字

和服务器的通信结束之后，用来通信的套接字也就不会再使用了，这时我们就可以删除这个套接字了。  
不过，套接字并不会立即被删除，而是会等待一段时间之后再被删除。  

等待这段时间是为了防止误操作，引发误操作的原因有很多，这里无法全部列举，下面来举一个最容易理解的例子。  

假设是客户端先发起断开，则断开的操作顺序如下：  
1. 客户端发送 FIN；
2. 服务器返回 ACK 号；
3. 服务器发送 FIN；
4. 客户端返回 ACK 号。

如果最后客户端返回的 ACK 号丢失了，服务器没有接收到 ACK 号，可能会重发一次 FIN ；  
但如果这时客户端的套接字已经删除了，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来；  
这时如果别的应用程序要创建套接字，新套接字碰巧又被分配到了同一个端口号，而服务器重发的 FIN 正好到达；  
本来这个 FIN 是要发给之前被删掉的套接字的，但新套接字有同样的端口号，于是这个 FIN 就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。  
之所以不马上删除套接字，就是为了防止这样的误操作。  

至于具体等待多长时间，这和包重传的操作方式有关。  
网络包丢失之后会进行重传，这个操作通常要持续几分钟。  
如果重传了几分钟之后依然无效，则停止重传。  
在这段时间内，网络中可能存在重传的包，也就有可能发生前面讲到的这种误操作，因此需要等待到重传完全结束。  
协议中对于这个等待时间没有明确的规定，一般来说会等待几分钟之后再删除套接字。  

### 数据收发操作小结

数据收发操作的步骤：

1. 创建套接字；
   - 一般来说，服务器一方的应用程序在启动时就会创建好套接字并进入等待连接的状态；
   - 客户端则一般是在用户触发特定动作，需要访问服务器的时候创建套接字；
   - 在这个阶段，还没有开始传输网络包。
2. 客户端会向服务器发起连接操作；
   - 首先，客户端会生成一个 SYN 为 1 的 TCP 包并发送给服务器；
     - 这个 TCP 包的头部还包含了客户端向服务器发送数据时使用的初始序号，以及服务器向客户端发送数据时需要用到的窗口大小。
   - 当这个包到达服务器之后，服务器会返回一个 SYN 为 1 的 TCP 包；
     - 这个包的头部中也包含了序号和窗口大小，此外还包含表示确认已收到客户端发送的 TCP 包的 ACK 号。
   - 当这个包到达客户端时，客户端会向服务器返回一个包含表示确认的 ACK 号的 TCP 包；
   - 到这里，连接操作就完成了，双方进入数据收发阶段。
3. 数据收发阶段；
数据收发阶段的操作根据应用程序的不同而有一些差异，以 Web 为例：  
   - 首先客户端会向服务器发送请求消息；
     - TCP 会将请求消息切分成一定大小的块，并在每一块前面加上 TCP 头部，然后发送给服务器；
     - TCP 头部中包含序号，它表示当前发送的是第几个字节的数据。
   - 当服务器收到数据时，会向客户端返回 ACK 号；
     - 在最初的阶段，服务器只是不断接收数据，随着数据收发的进行，数据不断传递给应用程序，接收缓冲区就会被逐步释放。这时，服务器需要将新的窗口大小告知客户端。
   - 当服务器收到客户端的请求消息后，会向客户端返回响应消息，这个过程和刚才的过程正好相反。
4. 断开操作。
服务器的响应消息发送完毕之后，数据收发操作就结束了，这时就会开始执行断开操作。  
以 Web 为例：  
   - 服务器会先发起断开过程；
   - 在这个过程中，服务器先发送一个 FIN 为 1 的 TCP 包；
   - 然后客户端返回一个表示确认收到的 ACK 号；
   - 接下来，双方还会交换一组方向相反的 FIN 为 1 的 TCP 包和包含 ACK 号的 TCP 包；
   - 最后，在等待一段时间后，套接字会被删除。

## IP 与以太网的包收发操作

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成包发送给通信对象。  

### 包的基本知识

包是由头部和数据两部分构成的。  
- 头部包含目的地址等控制信息；
- 头部后面就是委托方要发送给对方的数据。

TCP/IP包：  
|MAC头部|IP头部|TCP头部|数据块|
|---|---|---|---|
|MAC头部：以太网控制信息|IP头部：IP控制信息|||

一般来说 TCP 头部和数据块加起来就是包的内容；  
IP 头部加 TCP 头部加数据块是 IP 包；  
IP 包加 MAC 头部是以太网包。  

#### 包发往目的地的过程

1. 首先，发送方的网络设备会负责创建包；  
   - 创建包的过程就是生成含有正确控制信息的头部，然后再附加上要发送的数据。
2. 接下来，包会被发往最近的网络转发设备；  
   - 当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里。
   - 这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个方向。
3. 接下来，包在向目的地移动的过程中，又会到达下一个转发设备，然后又会按照同样的方式被发往下一个转发设备。  
   - 就这样，经过多个转发设备的接力之后，包最终就会到达接收方的网络设备。

当然，发送方向接收方发送一个包，接收方可能也会向发送方返回一个包，此时的发送方到了接下来的某个时刻就会变成接收方。  
因此，我们不需要把发送方和接收方明确区分开来，在这里我们把发送方和接收方统称为终端节点。  
- 相应地，转发设备被称为转发节点或者中间节点。


网络中有路由器和集线器两种不同的转发设备，它们在传输网络包时有着各自的分工。  
1. 路由器根据目标地址判断下一个路由器的位置；
2. 集线器在子网中将网络包传输到下一个路由。

实际上，集线器是按照以太网规则传输包的设备，而路由器是按照 IP 规则传输包的设备，因此我们也可以作如下理解。  
1. IP 协议根据目标地址判断下一个 IP 转发设备的位置；
2. 子网中的以太网协议将包传输到下一个转发设备。

TCP/IP 包包含如下两个头部：  
1. MAC 头部（用于以太网协议）；
2. IP 头部（用于 IP 协议）。

这两个头部分别具有不同的作用。 
 
1. 首先，发送方将包的目的地，也就是要访问的服务器的 IP 地址写入 IP 头部中；  
   - 这样一来，我们就知道这个包应该发往哪里，IP 协议就可以根据这一地址查找包的传输方向，从而找到下一个路由器的位置。  
2. 接下来，IP 协议会委托以太网协议将包传输过去；  
   - 这时，IP 协议会查找下一个路由器的以太网地址（ MAC 地址），并将这个地址写入 MAC 头部中；
   - 这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。  
3. 网络包在传输过程中会经过集线器，集线器是根据以太网协议工作的设备;  
   - 为了判断包接下来应该向什么地方传输，集线器里有一张表（用于以太网协议的表），可根据以太网头部中记录的目的地信息查出相应的传输方向;
   - 当存在多个集线器时，网络包会按顺序逐一通过这些集线器进行传输。  
4. 接下来，包会到达下一个路由器；
   - 路由器中有一张 IP 协议的表，可根据这张表以及 IP 头部中记录的目的地信息查出接下来应该发往哪个路由器;
   - 为了将包发到下一个路由器，我们还需要查出下一个路由器的 MAC 地址，并记录到 MAC 头部中，大家可以理解为改写了 MAC 头部;
   - 这样，网络包就又被发往下一个节点了;
   - 更准确地说，收到包的时候 MAC 头部会被舍弃，而当再次发送的时候又会加上包含新 MAC 地址的新 MAC 头部。
5. 这个过程不断重复，最终网络包就会被送到目的地。
   - 当目的地设备成功接收之后，网络包的传输过程就结束了。

这就是一个网络包从出发到到达目的地的全过程。  

虽然看起来有点复杂，不过设计这样的分工是有原因的。  
其中以太网的部分也可以替换成其他的东西，例如无线局域网、ADSL、FTTH 等，它们都可以替代以太网的角色帮助 IP 协议来传输网络包。  
- 当使用除以太网之外的其他网络进行传输时，MAC 头部也会被替换为适合所选通信规格的其他头部。
因此，将 IP 和负责传输的网络分开，可以更好地根据需要使用各种通信技术。像互联网这样庞大复杂的网络，在架构上需要保证灵活性，这就是设计这种分工方式的原因。  

### 在协议栈中 IP 模块如何完成包收发操作概览

尽管之前说 IP 模块负责将包发给对方，但实际上将包从发送方传输到接收方的工作是由集线器、路由器等网络设备来完成的，  
因此 IP 模块仅仅是整个包传输过程的入口而已。即便如此，IP 模块还是有很多工作需要完成。  

1. 包收发操作的起点是 TCP 模块委托 IP 模块发送包的操作；
   - 这个委托的过程就是 TCP 模块在数据块的前面加上 TCP 头部，然后整个传递给 IP 模块，这部分就是网络包的内容。
   - 与此同时，TCP 模块还需要指定通信对象的 IP 地址，也就是需要写清楚“将什么内容发给谁”。
2. 收到委托后，IP 模块会将包的内容当作一整块数据，在前面加上包含控制信息的头部，即 IP 头部和 MAC 头部这两种头部；
   - IP 头部中包含 IP 协议规定的、根据 IP 地址将包发往目的地所需的控制信息；
   - MAC 头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息；
   - 加上这两个头部之后，一个包就封装好了，这些就是 IP 模块负责的工作。
     - 凡是局域网所使用的头部都叫 MAC 头部，但其内容根据局域网的类型有所不同；
     - 此外，对于除局域网之外的其他通信技术，还有不同名称的各种头部，但它们只是名字不叫 MAC 头部而已，承担的作用和 MAC 头部是相同的。
3. 接下来，封装好的包会被交给网络硬件，例如以太网、无线局域网等；
   - 网络硬件可能是插在计算机主板上的板卡，也可能是笔记本电脑上的 PCMCIA 卡，或者是计算机主板上集成的芯片；
   - 不同形态的硬件名字也不一样，本书将它们统称为网卡。
4. 传递给网卡的网络包是由一连串 0 和 1 组成的数字信息，网卡会将这些数字信息转换为电信号或光信号，并通过网线（或光纤）发送出去；
5. 然后这些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步地送达接收方；
6. 包送达对方之后，对方会作出响应；
7. 返回的包也会通过转发设备发送回来，然后我们需要接收这个包；
   - 接收的过程和发送的过程是相反的，信息先以电信号的形式从网线传输进来，然后由网卡将其转换为数字信息并传递给 IP 模块；
   - 接下来，IP 模块会将 MAC 头部和 IP 头部后面的内容，也就是 TCP 头部加上数据块，传递给 TCP 模块。
8. 接下来的操作就是我们之前讲过的 TCP 模块负责的部分了。

在这个过程中，有2个关键的点。  
1. IP 的包收发操作都是相同的，并不会因包本身而有所区别；  
   - 因为 IP 模块会将 TCP 头部和数据块看作一整块二进制数据，在执行收发操作时并不关心其中的内容。
2. IP 模块也不关心 TCP 的操作阶段，对于包的乱序和丢失也一概不知。  
   - 总之，IP 的职责就是将委托的东西打包送到对方手里，或者是将对方送来的包接收下来，仅此而已。

### 生成包含接收方 IP 地址的 IP 头部

IP 模块接受 TCP 模块的委托负责包的收发工作，它会生成 IP 头部并附加在 TCP 头部前面。  

IP 头部最重要的内容就是 IP 地址，它表示这个包应该发到哪里去；  
- 这个地址是由 TCP 模块告知的，而 TCP 又是在执行连接操作时从应用程序那里获得这个地址的，因此这个地址的最初来源就是应用程序。
- IP 不会自行判断包的目的地，而是将包发往应用程序指定的接收方，即便应用程序指定了错误的 IP 地址，IP 模块也只能照做。

IP 头部中还需要填写发送方的IP 地址；  
- 一般的客户端计算机上只有一块网卡，因此也就只有一个 IP 地址，这种情况下我们可以认为这个 IP 地址就是计算机的 IP 地址；
- 但如果计算机上有多个网卡，情况就没那么简单了。
  - IP 地址实际上并不是分配给计算机的，而是分配给网卡的，因此当计算机上存在多块网卡时，每一块网卡都会有自己的 IP 地址；
  - 很多服务器上都会安装多块网卡，这时一台计算机就有多个 IP 地址，在填写发送方 IP 地址时就需要判断到底应该填写哪个地址；
  - 这个判断相当于在多块网卡中判断应该使用哪一块网卡来发送这个包，也就相当于判断应该把包发往哪个路由器；
  - 因为只要确定了目标路由器，也就确定了应该使用哪块网卡，也就确定了发送方的 IP 地址。
>（因为 IP 表，即路由表（Routing Table）中目标路由器的 IP 和转发路由器的 IP 和网卡这样的网络接口是有对应关系的。）

接下来还需要填写协议号。
- 它表示包的内容是来自哪个模块的
  - 如果是TCP 模块委托的内容，则设置为06（十六进制）；
  - 如果是UDP 模块委托的内容，则设置为17（十六进制）；
  - 这些值都是按照规则来设置的。

### 生成以太网用的MAC 头部

生成了IP 头部之后，接下来IP 模块还需要在IP 头部的前面加上
MAC 头部
IP 头部中的接收方IP 地址表示网络包的目的地，通
过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，TCP/
IP 的这个思路是行不通的。
以太网在判断网络包目的地时和TCP/IP 的方
式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而
MAC 头部就是干这个用的。

IP 模块在生成IP 头部之后，会在它前面再加上MAC 头部。MAC 头
部是以太网使用的头部，它包含了接收方和发送方的MAC 地址等信息。

MAC 头部的开头是
接收方和发送方的MAC 地址，大家可以认为它们和IP 头部中的接收方和
发送方IP 地址的功能差不多，只不过IP 地址的长度为32 比特，而MAC地址为48 比特。
此外，IP 地址是类似多少弄多少号这种现实中地址的层
次化的结构，而MAC 地址中的48 比特可以看作是一个整体。

尽管有上述
差异，但从表示接收方和发送方的意义上来说，MAC 地址和IP 地址是没
有区别的，因此可以暂且先把它们当成是一回事。

第3 个以太类型字
段和IP 头部中的协议号类似。在IP 中，协议号表示IP 头部后面的包内容
的类型；而在以太网中，我们可以认为以太网类型后面就是以太网包的内
容，而以太类型就表示后面内容的类型。以太网包的内容可以是IP、ARP
等协议的包，它们都有对应的值，这也是根据规则来确定的。

MAC 头部的字段：
|字段名称|长度（比特）|含义|
|---|---|---|
|接收方 MAC 地址|48|网络包接收方的 MAC 地址，在局域网中使用这一地址来传输网络包|

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































