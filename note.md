要实现应用程序之间的交互，我们需要一个能够在浏览器和Web服务器之间传递请求和响应的机制。  
由于请求和相应都是由 0 和 1 组成的数字信息，所以可以说，我们需要的是一种能够将数字信息搬运到指定目的地的机制。  
这种机制是由操作系统中的网络控制软件，以及交换机、路由器等设备分工合作来实现的，它的基本思路是将数字信息分割成一个一个的小块，然后装入一些被称为“包”（Packet）的容器中来运送。  
这个负责搬运数字信息的机制，再加上浏览器和Web服务器这些网络应用程序，这两部分就组成了网络。  

# 章节主要内容

## 第1章 Web 浏览器

首先介绍浏览器的工作方式，当输入网址时，浏览器就会按照一定的规则去分析这个网址的含义，然后根据其含义生成请求消息。  
接着浏览器就会委托操作系统中的网络控制软件将消息发送给服务器。  

## 第2章 协议栈、网卡

介绍探索搬运数据的机制。  
首先介绍协议栈（网络控制软件叫作协议栈）。这个软件会将从浏览器接收到的消息打包，然后加上目的地址等控制信息。  
接下来，协议栈会将包交给网卡（负责以太网或无线网络通信的硬件）。  
然后，网卡会将包转换为电信号并通过网线发送出去。这样一来，包就进入到网络之中了。  

## 第3章 集线器、交换机、路由器

本章假设客户端计算机是连接到家庭或公司的局域网中，然后再通过 ADSL 和光纤到户（FTTH）等宽带线路接入互联网。  
在这样的场景中，网卡发送的包会经过交换机等设备，到达用来接入互联网的路由器。路由器的后面就是互联网，网络运营商会负责将包送到目的地。  

## 第4章 接入网、网络运营商

数据从用来接入互联网的路由器出发，进入了互联网的内部。互联网的入口线路称为接入网。  
在骨干网中存在很多运营商和大量的路由器，这些路由器相互连接，组成一张巨大的网，而我们的网络包就在其中经过若干路由器的接力，最终被发送到目标Web服务器上。  

## 第5章 防火墙、缓存服务器

通过骨干网之后，网络包最终到达了 Web 服务器所在的局域网中。  
接着，它会遇到防火墙，防火墙会对进入的包进行检查。  
检查完之后，网络包接下来可能还会遇到缓存服务器。  
此外，在大型网站中，可能还会配备将消息分布到多台 Web 服务器上的负载均衡器，还有可能会使用通过分布在整个互联网中的缓存服务器来分发内容的服务。  
经过这些机制之后，网络包才会到达 Web 服务器。  

## 第6章 Web服务器

当网络包到达 Web 服务器后，数据会被解包并还原为原始的请求消息，然后交给 Web 服务器程序。  
接下来，Web 服务器程序分析请求消息的含义，并按照其中的指示将数据装入响应消息中，然后发回给客户端。  
  - 响应消息回到客户端的过程和之前我们介绍的过程正好相反。
当响应到达客户端之后，浏览器会从中读取出网页的数据并在屏幕上显示出来。  

# 涉及到的主要关键词

## 第1章 浏览器生成消息

浏览器、Web服务器、网址（URL）、HTTP、HTML、协议、URI、请求消息、解析器、Socket库、DNS服务器、域名  

## 第2章 用电信号传输TCP/IP数据

TCP/IP、套接字、协议栈、IP地址、端口号、包、头部、网卡、网卡驱动、MAC地址、以太网控制器、ICMP、UDP  

## 第3章 从网线到网络设备

局域网（LAN）、双绞线、串扰、中继式集线器、MDI、MDI-X、交换式集线器、全双工、半双工、碰撞、自动协商、路由器、  
路由表、子网掩码、默认网关、分片、地址转换、公有地址、私有地址  

## 第4章 通过接入网进入互联网内部

ADSL、FTTH、光纤、接入网、ADSL􀀀Modem集成式路由器、ATM、信元、正交振幅调制、分离器、DSLAM、宽带接入服务器、  
远程接入服务器、PPP、网络运行中心（NOC）、光纤、IX（Internet􀀀eXchange，互联网交换）  

## 第5章 服务器端的局域网中有什么玄机

防火墙、包过滤、数据中心、轮询、负载均衡器、缓存服务器、代理、代理服务器、内容分发服务、重定向  

## 第6章 请求到达Web服务器，响应返回浏览器

响应消息、多任务、多线程、虚拟目录、CGI、表单、访问控制、密码、数据格式、MIME  

# 第1章 浏览器生成消息——探索浏览器内部

## 热身问答

1. `http://www.nikkeibp.co.jp/`中的`www`只是Web服务器上的一种命名。  
   World Wide Web是Web的提出者最早开发的浏览器兼HTML编辑器的名字。  

2. 如果是`.com`、`.net`、`.org`、`.jp`（除`co.jp`、`ne.jp`等`xx.jp`格式的域名外）等没有对注册对象范围进行限制的域名，任何个人都可以申请注册。  
   - 在中国的情况，个人可以申请“`.cn`”域名，但“`.com.cn`”“`.net.cn`”等域名则是不开放给个人注册的。
   - 日本的域名体系中，`.jp`下级的域名用的是两个字母的命名，例如`.co.jp`、`.ne.jp`。
   此外，也有一种`.name`域名是专门为个人申请者准备的。  
   
3. 应用程序并不是自己去控制网络，而是委托操作系统来控制网络。  

## 看点

### 生成HTTP请求消息

用户在浏览器输入网址（URL） -\> 浏览器解析网址 -\> 浏览器根据网址含义生成请求信息

### 向DNS服务器查询Web服务器的IP地址

请求消息生成之后，浏览器会委托操作系统向 Web 服务器发送请求，但浏览器必须告诉操作系统接收方的 IP 地址才行，因此浏览器必须先查出 Web 服务器的 IP 地址。  
网址中只有 Web 服务器的域名，因此浏览器需要向 DNS 服务器查询域名对应的IP地址。  

### 全世界 DNS 服务器的大接力

全世界共有上万台 DNS 服务器，它们相互接力才能完成IP地址的查询，而它们进行接力的方法也是本章看点之一。  

### 委托协议栈发送消息

查询到 IP 地址之后，浏览器就可以将消息委托给操作系统发送给Web服务器了，但这个委托到底是如何完成的呢？这也是本章看点之一。  
理解了向操作系统进行委托时的规则，我们就能够明白做出某个委托时操作系统会给我们怎样的反馈，这可以说是相当于具体地理解了网络的潜在能力。  

## 生成 HTTP 请求消息

### 输入网址

#### 网址的定义

网址，准确来说应该叫 URL，是以`http://` 开头的那一串东西；  
实际上除了`http:`，网址还可以以其他一些文字开头，例如“`ftp:`、`file:`、`mailto:`等。  

浏览器是一个具备多种客户端功能的综合性客户端软件，因此它需要一些东西来判断应该使用其中哪种功能来访问相应的数据，而各种不同的 URL 就是用来干这个的，比如访问 Web 服务器时用`http:`，而访问 FTP 服务器下载和上传文件时用`ftp:`。  

#### 网址的格式

根据访问目标的不同，URL 的写法也会不同。  
  - 在访问 Web 服务器和 FTP 服务器时，URL 中会包含服务器的域名和要访问的文件的路径名等；
  - 发邮件的 URL 则包含收件人的邮件地址。
此外，根据需要，URL 中还会包含用户名、密码、服务器端口号等信息。  

##### URL的各种格式

用HTTP协议访问Web服务器时：  
|http://|user|:|password|@|www.glasscom.com|:80|/dir/file1.htm|  
|---|---|---|---|---|---|---|---|  
||用户名（可省略）||密码（可省略）||Web服务器域名|端口号（可省略）|文件的路径名|

用FTP协议下载和上传文件时：  
|ftp://|user|:|password|@|ftp.glasscom.com|:21|/dir/file1.htm|
|---|---|---|---|---|---|---|---|
|协议|用户名（可省略）||密码（可省略）||FTP服务器域名|端口号（可省略）|文件的路径名|

读取客户端计算机本地文件时:  
|file://|localhost|/c:/path/file1.zip|
|---|---|---|
||计算机名（可省略）|文件的路径名|

发送电子邮件时：  
|mailto:|tone@glasscom.com|
|---|---|
||邮件地址|

阅读新闻组的文章时:  
|news:|comp.protocols.tcp-ip|
|---|---|
||新闻组名|

尽管 URL 有各种不同的写法，但它们有一个共同点，那就是 URL 开头的文字，即`http:`、`ftp:`、`file:`、`mailto:`这部分文字都表示浏览器应当使用的访问方法。  
  - 访问 Web 服务器时应该使用 HTTP 协议；
  - 访问 FTP 服务器时则应该使用 FTP 协议。
因此，我们可以把这部分理解为访问时使用的协议类型。  
尽管后面部分的写法各不相同，但开头部分的内容决定了后面部分的写法，因此并不会造成混乱。  

> 1. HTTP：Hypertext Transfer Protocol，超文本传送协议。
  2. 协议：通信操作的规则定义称为协议（protocol）。

### 解析网址

浏览器要做的第一步工作就是对 URL 进行解析，从而生成发送给 Web 服务器的请求消息。  
具体步骤：  
1. 按照 URL 规格对字符串进行解析；
2. 将 URL 拆分为各个组成元素；
3. 分别理解各个元素的语义含义；
   - 主机名用于确定要访问的服务器；
   - 路径名用于确定服务器上要访问的具体资源位置。
4. 根据解析结果确定访问目标。

### 省略文件名的情况

URL 可以省略文件名，进一步省略目录名，再进一步省略结尾的`/`。这些写法都是允许的。  
当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是`/index.html`或者`/default.htm`这些文件。  

例：http://www.lab.glasscom.com/whatisthis  
一般来说，这种情况会按照下面的惯例进行处理：
如果Web 服务器上存在名为 whatisthis 的文件，则将 whatisthis 作为文件名来处理；  
如果存在名为 whatisthis 的目录，则将 whatisthis 作为目录名来处理。  

### HTTP 的基本思路

解析完 URL 之后，浏览器会使用 HTTP 协议来访问 Web 服务器。  

HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤，其基本思路非常简单。  
首先，客户端会向服务器发送请求消息。请求消息中包含的内容是“对什么”和“进行怎样的操作”两个部分。  
收到请求消息之后，Web 服务器会对其中的内容进行解析，通过 URI 和方法来判断“对什么”“进行怎样的操作”，并根据这些要求来完成自己的工作，然后将结果存放在响应消息中。  


#### URI 和方法

- 相当于“对什么”的部分称为 URI；
  - 一般来说，URI 的内容是一个存放网页数据的文件名或者是一个 CGI 程序的文件名，例如“/dir1/file1.html”“/dir1/program1.cgi”等。
  - 不过，URI 不仅限于此，也可以直接使用“http:”开头的 URL 来作为 URI。换句话说就是，这里可以写各种访问目标，而这些访问目标统称为URI。

- “进行怎样的操作”的部分称为方法。
  - 方法表示需要让 Web 服务器完成怎样的工作，其中典型的例子包括读取 URI 表示的数据、将客户端输入的数据发送给 URI 表示的程序等。

#### HTTP 的主要方法：  

|方法|含义|
|---|---|
|GET|获取 URI 指定的信息。如果 URI 指定的是文件，则返回文件的内容；如果 URI 指定的是 CGI 程序，则返回该程序的输出数据|
|POST|从客户端向服务器发送数据。一般用于发送表单中填写的数据等情况下|
|HEAD|和 GET 基本相同。不过它只返回 HTTP 的消息头（message header），而并不返回数据的内容。用于获取文件最后更新时间等属性信息|
|OPTIONS|用于通知或查询通信选项|
|PUT|替换 URI 指定的服务器上的文件。如果 URI 指定的文件不存在，则创建该文件|
|DELETE|删除 URI 指定的服务器上的文件|
|TRACE|将服务器收到的请求行和头部（header）直接返回给客户端。用于在使用代理的环境中检查改写请求的情况|
|CONNECT|使用代理传输加密消息时使用的方法|

除了表中的内容之外，HTTP 消息中还有一些用来表示附加信息的头字段。客户端向 Web 服务器发送数据时，会先发送头字段，然后再发送数据。不过，头字段属于可有可无的附加信息。  

#### 响应消息

在响应消息的开头有一个状态码，它用来表示操作的执行结果是成功还是发生了错误。  
  - 当我们访问 Web 服务器时，遇到找不到的文件就会显示出404 Not Found 的错误信息，其实这就是状态码。
状态码后面就是头字段和网页数据。响应消息会被发送回客户端，客户端收到之后，浏览器会从消息中读出所需的数据并显示在屏幕上。到这里，HTTP 的整个工作就完成了。  

#### 补充知识

上表列出的 HTTP 方法中最常用的就是`GET`方法，所以一般的访问过程是：  
1. 在请求消息中写上 GET 方法，然后在 URI 中写上存放网页数据的文件名“/dir1/file1.html”；
   - 表示我们需要获取 /dir1/file1.html 文件中的数据。
2. 当 Web 服务器收到消息后，会打开 /dir1/file1.html 文件并读取出里面的数据；
3. 将读出的数据存放到响应消息中，并返回给客户端；
4. 最后，客户端浏览器会收到这些数据并显示在屏幕上。

还有一个经常使用的方法就是`POST`，在表单中填写数据并将其发送给 Web 服务器时就会使用这个方法。
  - 当我们在网上商城填写收货地址和姓名，或者是在网上填写问卷时，都会遇到带有输入框的网页，而这些可以输入信息的部分就是表单。
1. 使用POST 方法时，URI 会指向 Web 服务器中运行的一个应用程序的文件名；
   - 典型的例子包括“index.cgi”“index.php”等。
2. 在请求消息中，除了方法和 URI 之外，还要加上传递给应用程序和脚本的数据；
   - 这里的数据也就是用户在输入框里填写的信息。
3. 当服务器收到消息后，Web 服务器会将请求消息中的数据发送给 URI 指定的应用程序；
4. Web 服务器从应用程序接收输出的结果，会将它存放到响应消息中并返回给客户端；
5. 最后，客户端浏览器会收到这些数据并显示在屏幕上。

前面两个方法属于 HTTP 的典型用法，除此之外的其他方法在互联网上几乎见不到使用的例子。  

如果只有 GET 和 POST 方法，我们就只能从 Web 服务器中获取网页数据，以及将网页输入框中的信息发送给 Web 服务器。  
而有了 PUT 和 DELETE 方法，就能够从客户端修改或者删除 Web 服务器上的文件。  
有了这些功能，我们甚至可以将 Web 服务器当成文件服务器来用。  
  - 当然，出于安全上的原因，或者是支持 GET 和 POST 之外的方法的客户端没有广泛普及之类的原因，一般我们并不会碰到这样的用法。

### 生成 HTTP 请求消息

对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。  
HTTP 消息在格式上是有严格规定的，因此浏览器会按照规定的格式来生成请求消息。  

#### HTTP 请求消息的格式

|内容|名称|
|<方法><空格><URI><空格><HTTP版本>|请求行|
|---|---|
|<字段名>:<字段值>|消息头|
|...|消息头|
|...|消息头|
|...|消息头|
|<空行>||
|<消息体>|消息体|

- 请求行：通过这一行可以大致了解请求的内容；  
- 消息头：每行包含一个头字段，用于表示请求的附加信息。消息头的行数根据具体情况可变，一直延伸到空行为止；  
- 消息体：包含客户端向服务器发送的数据，例如用 POST 方法向 Web 服务器发送的网页表单数据。  

#### 写一个请求消息

请求行的重点是最开头的方法，方法可以告诉 Web 服务器它应该进行怎样的操作。但是方法有很多种，必须先判断应该选用其中的哪一种。  
选择的关键在于浏览器的工作状态，浏览器并非只有在这一种场景下才会向 Web 服务器发送请求消息。  
  - 比如点击网页中的超级链接，或者在表单中填写信息后点击“提交”按钮，这些场景都会触发浏览器的工作，而选用哪种方法也是根据场景来确定的。  

在地址栏中输入网址并显示网页，应该使用 GET 方法。  
点击超级链接的场景中也是使用 GET 方法。  
如果是表单，在 HTML 源代码中会在表单的属性中指定使用哪种方法来发送请求，可能是 GET 也可能是 POST。  
  - GET 方法能够发送的数据只有几百个字节，如果表单中的数据超过这一长度，则必须使用 POST 方法来发送。

写好方法之后，加一个空格，然后写 URI。URI 部分的格式如下，一般是文件和程序的路径名。
  - /\<目录名\>/…/\<文件名\>

第一行的末尾需要写上 HTTP 的版本号，这是为了表示该消息是基于哪个版本的 HTTP 规格编写的。到此为止，第一行就结束了。  

第二行开始为消息头。  
  - 尽管通过第一行我们就可以大致理解请求的内容，但有些情况下还需要一些额外的详细信息，而消息头的功能就是用来存放这些信息；
  - 消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等；
    - 这些项目表示的都是非常细节的信息。
  - 消息头中的内容随着浏览器类型、版本号、设置等的不同而不同，大多数情况下消息头的长度为几行到十几行不等。

写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据。这一部分称为消息体，也就是消息的主体。  
  - 不过，在使用 GET 方法的情况下，仅凭方法和 URI，Web 服务器就能够判断需要进行怎样的操作，因此消息体中不需要填写任何数据。
  - 当使用 POST 方法时，需要将表单中填写的信息写在消息体中。

到此为止，请求消息的生成操作就全部完成了。  

### 发送请求后会收到响应

这里先粗略地了解一下：响应消息的格式以及基本思路和请求消息是相同的，差别只在第一行上。  
  - 在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错；
  - 状态码和响应短语表示的内容一致，但它们的用途不同；
  - 状态码是一个数字，它主要用来向程序告知执行的结果；
  - 相对地，响应短语则是一段文字，用来向人们告知执行的结果。

#### HTTP 状态码概要

状态码的第一位数字表示状态类型，第二、三位数字表示具体的情况。下表列举了第一位数字的含义。  

|状态码|含义|
|---|---|
|1xx|告知请求的处理进度和情况|
|2xx|成功|
|3xx|表示需要进一步操作|
|4xx|客户端错误|
|5xx|服务器错误|

返回响应消息之后，浏览器会将数据提取出来并显示在屏幕上，我们就能够看到网页的样子了。  
如果网页的内容只有文字，那么到这里就全部处理完毕了，但如果网页中还包括图片等资源，则还有下文。  

#### 当网页包含图片时

当网页中包含图片时，会在网页中的相应位置嵌入表示图片文件的标签的控制信息。  
浏览器会在显示文字时搜索相应的标签，当遇到图片相关的标签时，会在屏幕上留出用来显示图片的空间，然后再次访问 Web 服务器，  
按照标签中指定的文件名向 Web 服务器请求获取相应的图片并显示在预留的空间中。  
这个步骤和获取网页文件时一样，只要在 URI 部分写上图片的文件名并生成和发送请求消息就可以了。  

> 1 条请求消息中只能写 1 个 URI。如果需要获取多个文件，必须对每个文件单独发送 1 条请求。
  - 比如 1 个网页中包含 3 张图片，那么获取网页加上获取图片，一共需要向 Web 服务器发送 4 条请求。
  判断所需的文件，然后获取这些文件并显示在屏幕上，这一系列工作的整体指挥也是浏览器的任务之一，而 Web 服务器却毫不知情。
  Web 服务器完全不关心这 4 条请求获取的文件到底是 1 个网页上的还是不同网页上的，它的任务就是对每一条单独的请求返回 1 条响应而已。

## 向 DNS 服务器查询 Web 服务器的 IP 地址

### IP 地址的基本知识

生成 HTTP 消息之后，需要根据域名查询 IP 地址将其交给操作系统，然后委托操作系统将消息发送给 Web 服务器。  
  - 尽管浏览器能够解析网址并生成 HTTP 消息，但它本身并不具备将消息发送到网络中的功能，因此这一功能需要委托操作系统来实现。  

互联网和公司内部的局域网都是基于 TCP/IP 的思路来设计的，TCP/IP 的结构就是由一些小的子网，通过路由器连接起来组成一个大的网络。  
  - 这里的子网可以理解为用集线器连接起来的几台计算机，我们将它看作一个单位，称为子网；
  - 将子网通过路由器连接起来，就形成了一个网络。

在网络中，所有的设备都会被分配一个地址。这个地址就相当于现实中某条路上的“ ×× 号 ×× 室”。  
  - “号”对应的号码是分配给整个子网的，“室”对应的号码是分配给子网中的计算机的，这就是网络中的地址；
  - “号”对应的号码称为网络号，“室”对应的号码称为主机号，这个地址的整体称为 IP 地址。
通过 IP 地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。  

#### 消息传送的具体过程

在后面的章节中会详细讲解，现在先简单了解一下。  
- 发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上；  
- 接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器；    
  - 即消息再次经过子网内的集线器被转发到下一个路由器。
- 前面的过程不断重复，最终消息就被传送到了目的地。  

#### 实际的 IP 地址

实际的 IP 地址是一串 32 比特的数字，按照 8 比特（ 1 字节）为一组分成 4 组，分别用十进制表示然后再用圆点隔开。  
这就是我们平常经常见到的 IP 地址格式，但仅凭这一串数字我们无法区分哪部分是网络号，哪部分是主机号。  
  - 在 IP 地址的规则中，网络号和主机号连起来总共是 32 比特，但这两部分的具体结构是不固定的。  
  
##### 子网掩码
  
在组建网络时，用户可以自行决定网络号和主机号在 32 比特之间的分配关系，因此，我们还需要另外的附加信息来表示 IP 地址的内部结构。  
  - 这一附加信息称为子网掩码。  

子网掩码表示网络号与主机号之间的边界。  

例：  
`10.11.12.13/255.255.255.0`  

|IP 地址：|10.|1.|2.|3|
|---|---|---|---|---|
|子网掩码：|255.|255.|255.|0|

将上面的十进制转换成比特后:  
|IP 地址：|00001010.|00000001.|00000010.|00000011|
|---|---|---|---|---|
|子网掩码：|11111111.|11111111.|11111111.|00000000|

其中，子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号。  
这种写法太长，我们也可以把 1 的部分的比特数用十进制表示并写在 IP 地址的右侧。  
  - 写成`10.11.12.13/24`。

顺带一提，IP 地址中主机号部分的比特全部为 0 或者全部为 1 时代表两种特殊的含义。  
  - 主机号部分全部为 0 代表整个子网而不是子网中的某台设备；
  - 主机号部分全部为 1 代表向子网上所有设备发送包，即广播。

### 域名和 IP 地址并用的理由

TCP/IP 网络是通过 IP 地址来确定通信对象的，在网址中使用服务器名称而不是 IP 地址是因为服务器名称好记。  
而不用服务器名称来确定通信对象是因为 IP 地址长度为 4 字节即 32 比特，而域名最短几十个字节，最长甚至255字节，使用域名来确定定位会大大增加路由器的负担。  

于是，现在我们使用的方案是让人来使用名称，让路由器来使用 IP 地址。  
为了填补两者之间的障碍，需要有一个机制能够通过名称来查询 IP 地址，或者通过 IP 地址来查询名称，  
这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。这个机制就是 DNS。  

### Socket 库提供查询 IP 地址的功能

查询 IP 地址的方法非常简单，只要询问最近的 DNS 服务器“www.lab.glasscom.com 的 IP 地址是什么”就可以了，DNS 服务器会回答说“该服务器的 IP 地址为xxx.xxx.xxx.xxx”。  

#### DNS

##### 向 DNS 服务器发送查询消息

向 DNS 服务器发出查询，也就是向 DNS 服务器发送查询消息，并接收服务器返回的响应消息。  
换句话说，对于 DNS 服务器，我们的计算机上一定有相应的 DNS 客户端，而相当于 DNS 客户端的部分称为 DNS 解析器，或者简称解析器。  
通过 DNS 查询 IP 地址的操作称为域名解析，因此负责执行解析（resolution）这一操作的就叫解析器（resolver）了。  
  - 解析器实际上是一段程序，它包含在操作系统的 Socket 库中。  

###### Socket 库

库就是一堆通用程序组件的集合，其他的应用程序都需要使用其中的组件。  
  - 使用现成的组件搭建应用程序可以节省编程工作量；
  - 多个程序使用相同的组件可以实现程序的标准化。

Socket 库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是这个库中的其中一种程序组件。  
Socket 库是用于调用网络功能的程序组件集合。  

##### 通过解析器向 DNS 服务器发出查询

解析器的用法非常简单。Socket 库中的程序都是标准组件，只要从应用程序中进行调用就可以了。  
具体来说，在编写浏览器等应用程序的时候，只要写上解析器的程序名称以及 Web 服务器的域名就可以了，这样就完成了对解析器的调用。  

调用解析器后，解析器会向 DNS 服务器发送查询消息，然后 DNS 服务器会返回响应消息。  
响应消息中包含查询到的 IP 地址，解析器会取出IP地址，并将其写入浏览器指定的内存地址中。  
接下来，浏览器在向 Web 服务器发送消息时，只要从该内存地址取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统就可以了。  

根据域名查询 IP 地址时，浏览器会使用 Socket 库中的解析器。  

###### 解析器的内部原理

解析器内部是怎样工作的：  
1. 网络应用程序（在我们的场景中就是指浏览器）调用解析器时，程序的控制流程就会转移到解析器的内部；
2. 当控制流程转移到解析器后，解析器调用协议栈，控制流程再次转移，协议栈会执行发送消息的操作，然后会生成要发送给 DNS 服务器的查询消息并通过网卡发送给 DNS 服务器；
   - 解析器会根据 DNS 的规格，生成一条表示“请告诉我 www.lab.glasscom.com 的 IP 地址”的数据，并将它发送给 DNS 服务器；
   - 发送消息这个操作并不是由解析器自身来执行，而是要委托给操作系统内部的协议栈来执行。
3. 当DNS 服务器收到查询消息后，它会根据消息中的查询内容进行查询；
   - 如果要访问的Web 服务器已经在DNS 服务器上注册，那么这条记录就能够被找到，然后其 IP 地址会被写入响应消息并返回给客户端。
4. 接下来，消息经过网络到达客户端，再经过协议栈被传递给解析器；
5. 解析器读取出消息取出 IP 地址，并将 IP 地址传递给应用程序；
   - 实际上，解析器会将取出的 IP 地址写入应用程序指定的内存地址中。
6. 到这里，解析器的工作就完成了，控制流程重新回到应用程序（浏览器），现在应用程序已经能够从内存中取出 IP 地址了。

计算机的内部结构就是这样一层一层的。也就是说，很多程序组成不同的层次，彼此之间分工协作。  
当接到上层委派的操作时，本层的程序并不会完成所有的工作，而是会完成一部分工作，再将剩下的部分委派到下层来完成。  

顺带一提，向 DNS 服务器发送消息时，我们当然也需要知道 DNS 服务器的 IP 地址。只不过这个 IP 地址是作为 TCP/IP 的一个设置项目事先设置好的，不需要再去查询了。  
不同的操作系统中 TCP/IP 的设置方法也有差异，像 Windows 可以设置自动获得 DNS 服务器地址或主动分配一个，解析器会根据设置的 DNS 服务器 IP 地址来发送消息。  

####### 控制流程转移

一般来说，应用程序编写的操作内容是从上往下按顺序执行的，当到达需要调用解析器的部分时，对应的那一行程序就会被执行，应用程序本身的工作就会暂停。  
然后，Socket 库中的解析器开始运行，完成应用程序委托的操作。  
像这样，由于调用了其他程序，原本运行的程序进入暂停状态，而被调用的程序开始运行，这就是“控制流程转移”。  

## 全世界 DNS 服务器的大接力

### DNS 服务器的基本工作

DNS 服务器的基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响应。  
其中，来自客户端的查询消息包含以下 3 种信息：  
1. 域名；
   - 服务器、邮件服务器（邮件地址中@ 后面的部分）的名称。
2.  Class；
   - 在最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而Class 就是用来识别网络的信息；
   - 不过，如今除了互联网并没有其他的网络了，因此 Class 的值永远是代表互联网的 IN。
3. 记录类型。
   - 表示域名对应何种类型的记录。例如：
     - 当类型为 A 时，表示域名对应的是 IP 地址；
     - 当类型为 MX 时，表示域名对应的是邮件服务器；
     - 对于不同的记录类型，服务器向客户端返回的信息也会不同。

DNS 服务器上事先保存有前面这 3 种信息对应的记录数据，DNS 服务器就是根据这些记录查找符合查询请求的内容并对客户端作出响应的。  
DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址。  

例如，如果要查询 www.lab.glasscom.com 这个域名对应的 IP 地址，客户端会向 DNS 服务器发送包含以下信息的查询消息。  
（a） 域名 = www.lab.glasscom.com；  
（b） Class = IN；  
（c） 记录类型 = A。  
然后，DNS 服务器会从已有的记录中查找域名、Class 和记录类型全部匹配的记录。  

### 域名的层次结构

如果是在像公司内部网络这样Web 和邮件服务器数量有限的环境中，所有的信息都可以保存在一台 DNS 服务器中，其工作方式也就完全符合我们前面讲解的内容。  
然而，互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台 DNS 服务器中是不可能的，因此一定会出现在 DNS 服务器中找不到要查询的信息的情况。  

此时 DNS 服务器的工作方式：  
将信息分布保存在多台 DNS 服务器中，这些 DNS 服务器相互接力配合，从而查找出要查询的信息。  

#### 信息是如何在 DNS 服务器上注册并保存的

DNS 服务器中的所有信息都是按照域名以分层次的结构来保存的。  
DNS 中的域名都是用句点来分隔的，比如 www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已。  
在域名中，越靠右的位置表示其层级越高，比如 www.lab.glasscom.com 这个域名如果按照公司里的组织结构来说，大概就是“com 事业集团 glasscom 部 lab 科的www”这样。  
其中，相当于一个层级的部分称为域。因此，com 域的下一层是 glasscom 域，再下一层是 lab 域，再下面才是 www 这个名字。  

这种具有层次结构的域名信息会注册到 DNS 服务器中，而每个域都是作为一个整体来处理的。  
换句话说就是，一个域的信息是作为一个整体存放在 DNS 服务器中的，不能将一个域拆开来存放在多台 DNS 服务器中。  
不过，DNS 服务器和域之间的关系也并不总是一对一的，一台DNS 服务器中也可以存放多个域的信息。  

### 寻找相应的 DNS 服务器并获取 IP 地址

如何找到 DNS 服务器中存放的信息的关键在于如何找到我们要访问的 Web 服务器的信息归哪一台 DNS 服务器管。  
互联网中有数万台 DNS 服务器，肯定不能一台一台挨个去找，我们可以采用下面的办法。  

首先，将负责管理下级域的 DNS 服务器的 IP 地址注册到它们的上级 DNS 服务器中，然后上级 DNS 服务器的 IP 地址再注册到更上一级的 DNS 服务器中，以此类推。  
这样，我们就可以通过上级 DNS 服务器查询出下级 DNS 服务器的 IP 地址，也就可以向下级 DNS 服务器发送查询请求了。  

也就是说，负责管理 lab.glasscom.com 这个域的 DNS 服务器的 IP 地址需要注册到 glasscom.com 域的 DNS 服务器中，  
而 glasscom.com 域的 DNS 服务器的IP 地址又需要注册到 com 域的 DNS 服务器中。  

#### 根域

在前面的讲解中，似乎com、jp 这些域（称为顶级域）就是最顶层了，它们各自负责保存下级DNS 服务器的信息，但实际上并非如此。在互联网中，com 和jp 的上面还有一级域，称为根域。  
根域不像 com、jp 那样有自己的名字，因此在一般书写域名时经常被省略；  
如果要明确表示根域，应该像 www.lab.glasscom.com. 这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。  

不过，一般都不写最后那个句点，因此根域的存在往往被忽略，但根域毕竟是真实存在的，根域的 DNS 服务器中保管着 com、jp 等的 DNS 服务器的信息。  
由于上级 DNS 服务器保管着所有下级 DNS 服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的 DNS 服务器。  

除此之外还需要完成另一项工作，那就是将根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。  
这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。  
因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。  

分配给根域 DNS 服务器的 IP 地址在全世界仅有 13 个，而且这些地址几乎不发生变化，因此将这些地址保存在所有的 DNS 服务器中也并不是一件难事。  
实际上，根域 DNS 服务器的相关信息已经包含在 DNS 服务器程序的配置文件中了，因此只要安装了 DNS 服务器程序，这些信息也就被自动配置好了。  

#### 具体实现流程

假设我们要查询 www.lab.glasscom.com 这台 Web 服务器的相关信息。  

1. 客户端首先会访问最近的一台 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）；
2. 由于最近的 DNS 服务器中没有存放 www.lab.glasscom.com 这一域名对应的信息，所以我们需要从顶层开始向下查找。
   - 最近的 DNS 服务器中保存了根域 DNS 服务器的信息，因此它会将来自客户端的查询消息转发给根域 DNS 服务器
3. 根域服务器中也没有 www.lab.glasscom.com 这个域名，但根据域名结构可以判断这个域名属于 com 域，因此根域 DNS 服务器会返回它所管理的 com 域中的 DNS 服务器的 IP 地址；
4. 最近的 DNS 服务器又会向 com 域的 DNS 服务器发送查询消息；
5. com 域中也没有 www.lab.glasscom.com这个域名的信息，和刚才一样，com 域服务器会返回它下面的 glasscom.com 域的 DNS 服务器的 IP 地址；
6. 以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标 DNS 服务器；
7. 只要向目标 DNS 服务器发送查询消息，就能够得到我们需要的答案，也就是 www.lab.glasscom.com 的 IP 地址了。
8. 收到客户端的查询消息之后，DNS 服务器会按照前面的方法来查询 IP 地址，并返回给客户端；
9. 这样，客户端就知道了 Web 服务器的 IP 地址，也就能够对其进行访问了。

### 通过缓存加快 DNS 服务器的响应

以上展示的是基本原理，与真实互联网中的工作方式还是有一些区别的。  
在真实的互联网中，一台 DNS 服务器可以管理多个域的信息，现实中上级域和下级域有可能共享同一台 DNS 服务器。  
在这种情况下，访问上级 DNS 服务器时就可以向下跳过一级 DNS 服务器，直接返回再下一级 DNS 服务器的相关信息。  

此外，有时候并不需要从最上级的根域开始查找，因为 DNS 服务器有一个缓存功能，可以记住之前查询过的域名。  
如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。  
相比每次都从根域找起来说，缓存可以减少查询所需的时间。  
并且，当要查询的域名不存在时，“不存在”这一响应结果也会被缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。  

这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。  
因此，DNS 服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。  
而且，在对查询进行响应时，DNS 服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的 DNS 服务器。  

## 委托协议栈发送消息

### 数据收发操作概览

知道了 IP 地址之后，就可以委托操作系统内部的协议栈向这个目标 IP 地址，也就是我们要访问的 Web 服务器发送消息了。  
要发送给 Web 服务器的 HTTP 消息是一种数字信息（digital data），因此也可以说是委托协议栈来发送数字信息。  
  - 收发数字信息这一操作不仅限于浏览器，对于各种使用网络的应用程序来说都是共通的；
  - 因此，这一操作的过程也不仅适用于 Web，而是适用于任何网络应用程序。

和向 DNS 服务器查询 IP 地址的操作一样，收发数字信息这一操作也需要使用 Socket 库中的程序组件。  
不过，查询 IP 地址只需要调用一个程序组件就可以了，而这里需要按照指定的顺序调用多个程序组件，这个过程有点复杂。  
发送数据是一系列操作相结合来实现的。  

使用 Socket 库来收发数据的操作过程，简单来说，就像收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。  
我们可以把数据通道想象成一条管道，将数据从一端送入管道，数据就会到达管道的另一端然后被取出。  
  - 数据可以从任何一端被送入管道，数据的流动是双向的。
  - 不过，这并不是说现实中真的有这么一条管道，只是为了帮助大家理解数据收发操作的全貌。
收发数据的整体思路就是这样，但还有一点也非常重要。  
在进行收发数据操作之前，双方需要先建立起这条管道才行。  
  - 建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字。我们需要先创建套接字，然后再将套接字连接起来形成管道。  

实际的过程是下面这样的：  
1. 服务器一方先创建套接字，然后等待客户端向该套接字连接管道；
   - 服务器程序一般会在启动后就创建好套接字并等待客户端连接管道。
2. 当服务器进入等待状态时，客户端就可以连接管道了；
   - 客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务器端的套接字上。
3. 当双方的套接字连接起来之后，通信准备就完成了；
4. 接下来，只要将数据送入套接字就可以收发数据了；
5. 当数据全部发送完毕之后，连接的管道将会被断开；
   - 管道在连接时是由客户端发起的，但在断开时可以由客户端或服务器任意一方发起。
   - 其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。
6. 到此为止，通信操作就结束了。

综上所述，收发数据的操作分为若干个阶段，可以大致总结为以下 4 个。  
1. 创建套接字（创建套接字阶段）；
2. 将管道连接到服务器端的套接字上（连接阶段）；
3. 收发数据（通信阶段）；
4. 断开管道并删除套接字（断开阶段）。

在每个阶段，Socket 库中的程序组件都会被调用来执行相关的数据收发操作。  
前面这 4 个操作都是由操作系统中的协议栈来执行的，浏览器等应用程序并不会自己去做连接管道、放入数据这些工作，而是委托协议栈来代劳。  
本章只介绍“委托”这个操作。关于协议栈收到委托之后具体是如何连接管道和放入数据的将在第 2 章介绍。  

此外，这些委托的操作都是通过调用 Socket 库中的程序组件来执行的。  
但这些数据通信用的程序组件其实仅仅充当了一个桥梁的角色，并不执行任何实质性的操作，应用程序的委托内容最终会被原原本本地传递给协议栈。  
因此，我们无法形象地展示这些程序组件到底完成了怎样的工作，与其勉强强调 Socket 库的存在，还不如将 Socket 库和协议栈看成一个整体并讲解它们的整体行为让人更容易理解。  
因此，后文将会采用这样的讲法。不过，请大家不要忘记 Socket 库这一桥梁的存在。  

### 创建套接字阶段

应用程序（浏览器）委托收发数据的过程关键点就是像对 DNS 服务器发送查询一样，  
调用 Socket 库中的特定程序组件访问 DNS 服务器时我们调用的是一个叫作 gethostbyname 的程序组件（也就是解析器），而这一次则需要按照一定的顺序调用若干个程序组件。  

首先是套接字创建阶段。客户端创建套接字的操作非常简单，只要调用 Socket 库中的 socket 程序组件就可以了。  
  - 调用 Socket 库中的程序组件的思路和调用解析器是一样的，调用解析器是在程序中直接写解析器的程序名`gethostbyname`即可；  
  - 和调用解析器一样，调用 socket 之后，控制流程会转移到socket 内部并执行创建套接字的操作，完成之后控制流程又会被移交回应用程序。
套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中；  
  - 描述符是用来识别不同的套接字的；
  - 因为同一台计算机上可能同时存在多个套接字，在这样的情况下，我们就需要一种方法来识别出某个特定的套接字，这种方法就是描述符。
当创建套接字后，我们就可以使用这个套接字来执行收发数据的操作了。  
  - 这时，只要我们出示描述符，协议栈就能够判断出我们希望用哪一个套接字来连接或者收发数据了；
  - 应用程序是通过“描述符”这一类似号码牌的东西来识别套接字的。

### 连接阶段：把管道接上去

接下来，我们需要委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序通过调用 Socket 库中的名为 connect 的程序组件来完成这一操作。  
这里的要点是当调用 connect 时，需要指定描述符、服务器 IP 地址和端口号这 3 个参数。  

1. 描述符；
   - 就是在创建套接字的时候由协议栈返回的那个描述符。
     - connect 会将应用程序指定的描述符告知协议栈，然后协议栈根据这个描述符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接的操作。
2. 服务器 IP 地址；
   - 就是通过 DNS 服务器查询得到的我们要访问的服务器的 IP 地址。
3. 端口号。
   - IP 地址是为了区分网络中的各个计算机而分配的数值。因此，只要知道了 IP 地址，我们就可以识别出网络上的某台计算机；
   - 但是，连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行，而仅凭 IP 地址是无法做到这一点的；
   - 当同时指定 IP 地址和端口号时，就可以明确识别出某台具体的计算机上的某个具体的套接字。

#### 端口号

能否使用描述符来识别套接字？  
描述符是和委托创建套接字的应用程序进行交互时使用的，并不是用来告诉网络连接的另一方的，因此另一方并不知道这个描述符。  
同样地，客户端也无法知道服务器上的描述符。因此，客户端也无法通过服务器端的描述符去确定位于服务器上的某一个套接字。  

所以，我们需要另外一个对客户端也同样适用的机制，而这个机制就是端口号。  
如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。  

##### 实现规定好的端口号

服务器上所使用的端口号是根据应用的种类事先规定好的，仅此而已。比如 Web 是 80 号端口，电子邮件是 25 号端口。  
关于端口号，我们将在第 6 章探索服务器内部工作的时候进行介绍，这里大家只要这样记住就行了：只要指定了事先规定好的端口号，就可以连接到相应的服务器程序的套接字。  
也就是说，浏览器访问 Web 服务器时使用 80 号端口，这是已经规定好的。  

端口号的规则是全球统一的，为了避免重复和冲突，端口号和 IP 地址一样都是由 IANA（Internet Assigned Number Authority，互联网编号管理局）这一组织来统一管理的。  

##### 客户端的端口

既然确定连接对象的套接字需要使用端口号，那么服务器也得知道客户端的套接字号码才行吧，这个问题是怎么解决的呢？  
事情是这样的，首先，客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。  
接下来，当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。  
  - 这部分内容我们会在第2 章探索协议栈内部工作时进行介绍。
  - 在创建套接字时，服务器也可以自行指定端口号，但一般并不常用。

总而言之，就是当调用 connect 时，协议栈就会执行连接操作。  
当连接成功后，协议栈会将对方的 IP 地址和端口号等信息保存在套接字中，这样我们就可以开始收发数据了。  

### 通信阶段：传递消息

当套接字连接起来之后，剩下的事情就简单了。只要将数据送入套接字，数据就会被发送到对方的套接字中。
当然，应用程序无法直接控制套接字，因此还是要通过 Socket 库委托协议栈来完成这个操作。
这个操作需要使用 write 这个程序组件，具体过程如下：
1. 当调用 write 时，需要指定描述符和发送数据，然后协议栈就会将数据发送到服务器。
   - 应用程序需要在内存中准备好要发送的数据，根据用户输入的网址生成的 HTTP 请求消息就是我们要发送的数据。
   - 由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。
2. 当发送数据会通过网络到达我们要访问的服务器，服务器执行接收操作，解析收到的数据内容并执行相应的操作，向客户端返回响应消息；
3. 当消息返回后，需要执行的是接收消息的操作。
   - 接收消息的操作是通过 Socket 库中的 read 程序组件委托协议栈来完成的。
   - 调用 read 时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。
4. 当服务器返回响应消息时，read 就会负责将接收到的响应消息存放到接收缓冲区中。
   - 由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。

### 断开阶段：收发数据结束

当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需要调用Socket 库的 close 程序组件进入断开阶段。  
最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。  

断开的过程如下：  
1. Web 使用的 HTTP 协议规定，当 Web 服务器发送完响应消息之后，应该主动执行断开操作，因此 Web 服务器会首先调用 close 来断开连接。
2. 断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。
3. 接下来，当浏览器调用 read 执行接收数据操作时，read 会告知浏览器收发数据操作已结束，连接已经断开。
4. 浏览器得知后，也会调用 close 进入断开阶段。

这就是 HTTP 的工作过程。HTTP 协议将HTML 文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。  
因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。  
对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。  
在HTTP 版本1.1 中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。  

> 本章我们探索了浏览器与 Web 服务器之间收发消息的过程，但实际负责收发消息的是协议栈、网卡驱动和网卡，只有这 3 者相互配合，数据才能够在网络中流动起来。
  下一章我们将对这一部分进行探索。

>	zongjie
	1. 浏览器解析URL，并根据 HTTP 协议进行客户端和服务器之间交互的消息内容和步骤
	2. 生成请求信息：包括方法和 URI
	3. 解析器调用协议栈，协议栈向最近的 DNS 服务器发送查询 Web 服务器的 IP 地址的信息
	4. 一层层查下去直到查到对应域名的 IP 地址
	5. 信息传回客户端，协议栈传回解析器，解析器传回应用程序
	6. 得知 IP 地址，客户端根据端口、描述符、IP 地址找到对应 IP 地址的套接字，
	7. 告知对应设备客户端的套接字信息
	8. 两个套接字连接
	9. 使用 write 发送信息进入客户端的套接字传送到服务器的套接字
	10. 服务器发回信息，使用 read 把返回信息放到接收缓存区
	11. 发送结束服务器断开，接着客户端断开，接着浏览器断开

# 用电信号传输 TCP/IP 数据

## 热身问答

1. 一般情况下，以太网的头部（网络包开头的控制信息）格式并非遵循国际标准（IEEE802.3/802.2），而是遵循一个更古老的规格（以太网第 2 版，又称 DIX 规格），  
   相对地，国际标准（IEEE802.3/802.2）的头部格式由于长度太长、效率降低而没有普及。  
2. 最早的 TCP/IP 协议原型设计相当于现在的 TCP 和 IP 合在一起的样子，后来才拆分成为 TCP 和 IP 两个协议。  
3. 在网络包出现之前，通信都是像电话一样把线路连接起来进行的。但是，连接线路的通信方式只能和固定的对象进行通信，无法发挥计算机可以处理多种工作的特点。  
   为了解决这个问题，人们设计出了使用网络包来进行通信的方式。  

## 看点

### 创建套接字

从应用程序收到委托后，协议栈通过 TCP 协议收发数据的操作可以分为 4 个阶段。  
首先是创建套接字，在这个阶段，我们将介绍协议栈的内部结构、套接字的实体，以及创建套接字的操作过程。  

### 连接服务器

接下来是客户端套接字向服务器套接字进行连接的阶段。  
我们将介绍“连接”具体是进行怎样的操作，在这个过程中协议栈到底是如何工作的，以及客户端和服务器是如何进行交互的。  

### 收发数据

两端的套接字完成连接之后，就进入收发消息的阶段了。在这个阶段，协议栈会将从应用程序收到的数据切成小块并发送给服务器。  
考虑到通信过程中可能会出错导致网络包丢失，协议栈还需要确认切分出的每个包是否已经送达服务器，  对于没有送达的包要重新发送一次。  

### 从服务器断开连接并删除套接字

收发消息的操作全部结束之后，接下来要断开服务器的连接并删除套接字。  
断开操作的本质是当消息收发完成后客户端和服务器相互进行确认的过程，但这个过程并不只是相互确认并删除套接字那么简单。  

### IP 与以太网的包收发操作

在介绍 TCP 协议收发消息的操作之后，我们再来看看实际的网络包是如何进行收发的。  
协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号或者光信号发送出去。  

### 用 UDP 协议收发数据的操作

TCP 协议有很多方便的功能，比如网络包出错丢失时可以重发，因此很多应用程序都是使用 TCP 协议来收发数据的，但这些方便的功能也有帮倒忙的时候。  
在这种情况下我们还有另外一种叫 UDP 的协议。这里我们将介绍 UDP 的必要性以及它与 TCP 的差异。  

## 创建套接字

本章将说明操作系统中的网络控制软件（协议栈）和网络硬件（网卡）是如何将浏览器的消息发送给服务器的。  

### 协议栈的内部结构

和浏览器不同的是，协议栈的工作我们从表面上是看不见的，可能比较难以想象。  

协议栈的内部分为几个部分，分别承担不同的功能。  
1. 协议栈的上半部分有两块；
   - 分别是负责用 TCP 协议收发数据的部分；
   - 负责用 UDP 协议收发数据的部分；
   - TCP 协议和 UDP 协议会接受应用程序的委托执行收发数据的操作；
   - 像浏览器、邮件等一般的应用程序都是使用 TCP 收发数据的，而像 DNS 查询等收发较短的控制数据的时候则使用 UDP。  
2. 下面一半是用 IP 协议控制网络包收发操作的部分。
  - 在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由 IP 来负责的；
  - 此外，IP 中还包括 ICMP 协议和 ARP 协议；
  - ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息；
  - ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

#### TCP/IP 软件的分层结构

TCP/IP 软件采用分层结构，包括应用程序、操作系统、驱动程序、硬件四个部分，四部分由上而下。  
上面的部分会向下面的部分委派工作，下面的部分接受委派的工作并实际执行。  
当然，这一上下关系只是一个总体的规则，其中也有一部分上下关系不明确，或者上下关系相反的情况，所以也不必过于纠结。  

1. 最上面的部分是网络应用程序；
   - 也就是浏览器、电子邮件客户端、Web 服务器、电子邮件服务器等程序，它们会将收发数据等工作委派给下层的部分来完成。
   - 除了浏览器之外，其他应用程序在网络上收发数据的操作也都是类似上面这样的
     - 也就是说，尽管不同的应用程序收发的数据内容不同，但收发数据的操作是共通的。
     - 因此，下面介绍的内容不仅适用于浏览器，也适用于各种应用程序。
2. 应用程序的下面是 Socket 库，其中包括解析器，解析器用来向 DNS 服务器发出查询；
3. 再下面就是操作系统内部了，其中包括协议栈；
4. IP 下面的网卡驱动程序负责控制网卡硬件，
5. 最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。

### 套接字的实体就是通信控制信息

在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP 地址、端口号、通信操作的进行状态等。  
本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。  

协议栈在执行操作时需要参阅这些控制信息。  
例如，在发送数据时，需要看一看套接字中的通信对象 IP 地址和端口号，以便向指定的 IP 地址和端口发送数据。  
在发送数据之后，协议栈需要等待对方返回收到数据的响应信息，但数据也可能在中途丢失，永远也等不到对方的响应。  
在这样的情况下，我们不能一直等下去，需要在等待一定时间之后重新发送丢失的数据，这就需要协议栈能够知道执行发送数据操作后过了多长时间。  
为此，套接字中必须要记录是否已经收到响应，以及发送数据后经过了多长时间，才能根据这些信息按照需要执行重发操作。  

上面说的只是其中一个例子。套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。  
协议栈是根据套接字中记录的控制信息来工作的。  

### 调用 socket 时的操作

当浏览器调用socket、connect 等 Socket 库中的程序组件时，协议栈内部是如何工作的。

1. 首先是创建套接字的阶段；
应用程序调用 socket 申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。  
在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。  
  - 用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们先要开辟出这样一块空间来，这相当于为控制信息准备一个容器；
  - 但光一个容器并没有什么用，还需要往里面存入控制信息。
套接字刚刚创建时，数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。  
到这里，创建套接字的操作就完成了。  

2. 接下来，需要将表示这个套接字的描述符告知应用程序；  
   - 描述符相当于用来区分协议栈中的多个套接字的号码牌。

3. 收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。
由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息。  
这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。  

## 连接服务器

### 连接是什么意思

创建套接字之后，应用程序（浏览器）就会调用 connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。  
连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作。  
  - 所谓控制信息，就是用来控制数据收发操作所需的一些信息，IP 地址和端口号就是典型的例子。

网线是一直连接着的，随时都有信号从中流过，如果通信过程只是将数据转换为电信号，那么这一操作随时都可以进行。  
不过，在这个时间点，也就是套接字刚刚创建完成时，当应用程序委托发送数据的时候，协议栈会如何操作呢？  

对于客户端方面来说，套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。  
在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。  
浏览器可以根据网址来查询服务器的 IP 地址，而且根据规则也知道应该使用 80 号端口，但只有浏览器知道这些必要的信息是不够的；  
因为在调用 socket 创建套接字时，这些信息并没有传递给协议栈。  
因此，我们需要把服务器的 IP 地址和端口号等信息告知协议栈，这是连接操作的目的之一。  

此时服务器上也会创建套接字，但服务器上的协议栈和客户端一样，只创建套接字是不知道应该和谁进行通信的。  
而且，和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁，这样下去永远也没法开始通信。  
于是，我们需要让客户端向服务器告知必要的信息，比如“我想和你开始通信，我的IP 地址是xxx.xxx.xxx.xxx，端口号是yyyy。”  
可见，客户端向服务器传达开始通信的请求，也是连接操作的目的之一。  

连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备。  
此外，当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的。  

上面这些就是“连接”这个词代表的具体含义。  

### 负责保存控制信息的头部

控制信息其实可以大体上分为两类。  

第一类是客户端和服务器相互联络时交换的控制信息。  
这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程中都需要，  
这些内容在 TCP 协议的规格中进行了定义。  

这些字段是固定的，在连接、收发、断开等各个阶段中，每次客户端和服务器之间进行通信时，都需要提供这些控制信息。  
具体来说，这些信息会被添加在客户端与服务器之间传递的网络包的开头。在连接阶段，由于数据收发还没有开始，所以网络包中没有实际的数据，只有控制信息。  

这些控制信息位于网络包的开头，因此被称为头部。
此外，以太网和 IP 协议也有自己的控制信息，这些信息也叫头部，为了避免各种不同的头部发生混淆，我们一般会记作 TCP 头部、以太网头部、IP 头部。
客户端和服务器在通信中会将必要的信息记录在头部并相互确认。  
头部的信息非常重要，理解了头部各字段的含义，就等于理解了整个通信的过程。  

TCP 头部格式：  
|字段名称|长度（比特）|含义|
|---|---|---|
|发送方端口号|16|发送网络包的程序的端口号|
|接收方端口号|16|网络包的接收方程序的端口号|
|序号（发送数据的顺序编号）|32|发送方告知接收方该网络包发送的数据相当于所有发送数据的第几个字节|
|ACK 号（接收数据的顺序编号）|32|接收方告知发送方接收方已经收到了所有数据的第几个字节。其中，ACK 是acknowledge 的缩写|
|数据偏移量|4|表示数据部分的起始位置，也可以认为表示头部的长度|
|保留|6|该字段为保留，现在未使用|
|控制位|6|该字段中的每个比特分别表示以下通信控制含义。URG：表示紧急指针字段有效; ACK：表示接收数据序号字段有效，一般表示数据已被接收方收到; PSH：表示通过 flush 操作发送的数据; RST：强制断开连接，用于异常中断的情况; SYN：发送方和接收方相互确认序号，表示连接操作; FIN：表示断开连接|
|窗口|16|接收方告知发送方窗口大小（即无需等待确认可一起发送的数据量）|
|校验和|16|用来检查是否出现错误|
|紧急指针|16|表示应紧急处理的数据位置|
|可选字段|可变长度|除了上面的固定头部字段之外，还可以添加可选字段，但除了连接操作之外，很少使用可选字段|

控制信息的第二类是保存在套接字中，用来控制协议栈操作的信息。  
应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。  

我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的，因此，“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同，但这并没有什么问题。  
因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。  
例如，Windows 和 Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同。  
但即便如此，两种系统之间依然能够互相通信，同样地，计算机和手机之间也能够互相通信。  
正如前面所说，协议栈的实现不同，因此我们无法具体说明协议栈里到底保存了哪些控制信息，但可以用命令来显示一些重要的套接字控制信息，  
这些信息无论何种操作系统的协议栈都是共通的，通过理解这些重要信息，就能够理解协议栈的工作方式了。  

> 网络包的结构是“以太网和 IP 的控制信息” + “ TCP 的控制信息” + “数据块”。

### 连接操作的实际过程

连接的具体操作过程是从应用程序调用Socket 库的connect 开始的。  
`connect（< 描述符>, < 服务器IP 地址和端口号>, …）`  
上面的调用提供了服务器的 IP 地址和端口号，这些信息会传递给协议栈中的 TCP 模块。  
然后，TCP 模块会与该 IP 地址对应的对象，也就是与服务器的 TCP 模块交换控制信息，这一交互过程包括下面几个步骤。  

1. 客户端先创建一个包含表示开始数据收发操作的控制信息的头部；
   - 头部包含很多字段，这里要关注的重点是发送方和接收方的端口号；
   - 这样，客户端（发送方）的套接字就准确找到了服务器（接收方）的套接字，也就是搞清楚了我应该连接哪个套接字；
   - 我们将头部中的控制位的 SYN 比特设置为 1，大家可以认为它表示连接。此外还需要设置适当的序号和窗口大小。
2. 当 TCP 头部创建好之后，接下来 TCP 模块会将信息传递给 IP 模块并委托它进行发送；
3. IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器；
4. 然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块，服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字；
   - 也就是说，从处于等待连接状态的套接字中找到与 TCP 头部中记录的端口号相同的套接字就可以了。
5. 当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接；
6. 上述操作完成后，服务器的 TCP 模块会返回响应，这个过程和客户端一样，需要在 TCP 头部中设置发送方和接收方端口号以及 SYN 比特；
   - 此外，在返回响应时还需要将 ACK 控制位设为1，这表示已经接收到相应的网络包；
   - 网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达，而设置 ACK 比特就是用来进行这一确认的；
   - 客户端向服务器发送第一个网络包时，由于服务器还没有接收过网络包，所以需要将 ACK 比特设为0。
7. 接下来，服务器 TCP 模块会将 TCP 头部传递给 IP 模块，并委托 IP 模块向客户端返回响应；
8. 然后，网络包就会返回到客户端，通过 IP 模块到达 TCP 模块，并通过 TCP 头部的信息确认连接服务器的操作是否成功；
   - 如果 SYN 为 1 则表示连接成功，这时会向套接字中写入服务器的 IP 地址、端口号等信息，同时还会将状态改为连接完毕；
   - 到这里，客户端的操作就已经完成。
9. 刚才服务器返回响应时将 ACK 比特设置为 1，相应地，客户端也需要将 ACK 比特设置为 1 并发回服务器，告诉服务器刚才的响应包已经收到。
   - 当这个服务器收到这个返回包之后，连接操作才算全部完成。

头部和套接字之间的关系是？

## 收发数据

### 将 HTTP 请求消息交给协议栈

当控制流程从 connect 回到应用程序之后，接下来就进入数据收发阶段了。  
数据收发操作是从应用程序调用 write 将要发送的数据交给协议栈开始的，协议栈收到数据后执行发送操作，这一操作包含如下要点：  

1. 协议栈并不关心应用程序传来的数据是什么内容；  
   - 应用程序在调用 write 时会指定发送数据的长度，在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已。

2. 协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。  
   - 这样做是有道理的。应用程序交给协议栈发送的数据长度是由应用程序本身来决定的，不同的应用程序在实现上有所不同。
     - 有些程序会一次性传递所有的数据，有些程序则会逐字节或者逐行传递数据；
     - 总之，一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为；
     - 在这样的情况下，如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。

至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的：  

1. 每个网络包能容纳的数据长度；  
   - 协议栈会根据一个叫作MTU（Maximum Transmission Unit，最大传输单元）的参数来进行判断。
     - MTU 表示一个网络包的最大长度，在以太网中一般是1500 字节。
   - MTU 是包含头部的总长度，因此需要从MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作MSS（Maximum Segment Size，最大分段大小）。
   - 当从应用程序收到的数据长度超过或者接近MSS 时再发送出去，就可以避免发送大量小包的问题了。

2. 时间。
   - 当应用程序发送数据的频率不高的时候，如果每次都等到长度接近MSS 时再发送，可能会因为等待时间太长而造成发送延迟，
     - 这种情况下，即便缓冲区中的数据长度没有达到MSS，也应该果断发送出去。
   - 为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去，这个时间并没有多长，是以毫秒为单位来计算的。

判断要素就是这两个，但它们其实是互相矛盾的。  
- 如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟；
- 如果时间优先，那么延迟时间会变少，但又会降低网络的效率。
- 因此，在进行发送操作时需要综合考虑这两个要素以达到平衡。
不过，TCP 协议规格中并没有告诉我们怎样才能平衡，因此实际如何判断是由协议栈的开发者来决定的，  
也正是由于这个原因，不同种类和版本的操作系统在相关操作上也就存在差异。  

正如前面所说，如果仅靠协议栈来判断发送的时机可能会带来一些问题，因此协议栈也给应用程序保留了控制发送时机的余地。  
应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。  
像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。  

### 对较大的数据进行拆分

HTTP 请求消息一般不会很长，一个网络包就能装得下，  
但如果其中要提交表单数据，长度就可能超过一个网络包所能容纳的数据量，比如在博客或者论坛上发表一篇长文就属于这种情况。  

这种情况下，发送缓冲区中的数据就会超过 MSS 的长度，这时我们当然不需要继续等待后面的数据了。  
发送缓冲区中的数据会被以 MSS 长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。  
根据发送缓冲区中的数据拆分的情况，当判断需要发送这些数据时，就在每一块数据前面加上 TCP 头部，并根据套接字中记录的控制信息标记发送方和接收方的端口号，  
然后交给 IP 模块来执行发送数据的操作，IP 模块会在网络包前面添加 IP 头部和以太网的 MAC 头部后发送网络包。  

### 使用 ACK 号确认网络包已收到

到这里，网络包已经装好数据并发往服务器了，但数据发送操作还没有结束。  
TCP 具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作。  

确认的原理：  

首先，TCP 模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在 TCP 头部中，“序号”字段就是派在这个用场上的。  
然后，发送数据的长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。  
有了上面两个数值，我们就可以知道发送的数据是从第几个字节开始，长度是多少了。  

通过这些信息，接收方还能够检查收到的网络包有没有遗漏。  
例如，假设上次接收到第 1460 字节，那么接下来如果收到序号为 1461 的包，说明中间没有遗漏；但如果收到的包序号为 2921，那就说明中间有包遗漏了。  
像这样，如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入 TCP 头部的 ACK 号中发送给发送方。  
  - 返回 ACK 号时，除了要设置 ACK 号的值以外，还需要将控制位中的 ACK 比特设为 1，这代表 ACK 号字段有效，接收方也就可以知道这个网络包是用来告知 ACK 号的。
这个返回 ACK 号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据。  
  - 在实际的通信中，序号并不是从 1 开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。
    - 但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。

> 在刚才讲过的连接过程中，有一个将 SYN 控制位设为 1 并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。  
  实际上，在将 SYN 设为1 的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值 SYN 为 1 表示进行连接，  
  这是因为将 SYN 设为 1 并告知初始序号这一操作仅在连接过程中出现，因此发送 SYN 为 1 的网络包就表示发起连接的意思。  
  实际上，SYN 是 Synchronize（同步）的缩写，意思是通过告知初始序号使通信双方保持步调一致，以便完成后续的数据收发检查，这才是SYN 原本的含义。  

前面介绍了通过序号和 ACK 号来进行数据确认的思路，但仅凭这些还不够。  
因为刚刚只考虑了单向的数据传输，但 TCP 数据收发是双向的，在客户端向服务器发送数据的同时，服务器也会向客户端发送数据，因此必须要想办法应对这样的情况。  
不过，这其实也不难，只要增加一种左右相反的情形就可以了。  
首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算 ACK 号并返回给客户端。  
相反地，服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算 ACK 号并返回给服务器。  
此外，客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。  

#### 实际工作流程

1. 首先，客户端在连接时需要计算出与从客户端到服务器方向通信相关的序号初始值，并将这个值发送给服务器；
2. 接下来，服务器会通过这个初始值计算出 ACK 号并返回给客户端，同时，服务器也需要计算出与从服务器到客户端方向通信相关的序号初始值，并将这个值发送给客户端；
   - 初始值有可能在通信过程中丢失，因此当服务器收到初始值后需要返回 ACK 号作为确认。
3. 接下来像刚才一样，客户端也需要根据服务器发来的初始值计算出 ACK 号并返回给服务器；
4. 到这里，序号和 ACK 号都已经准备完成了，接下来就可以进入数据收发阶段了。

数据收发操作本身是可以双向同时进行的，但 Web 中是先由客户端向服务器发送请求，序号也会跟随数据一起发送；  
然后，服务器收到数据后再返回 ACK 号；  
从服务器向客户端发送数据的过程则正好相反。  

TCP 采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的 ACK 号，那么就重新发送这些包。  
通过这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）。  
反过来说，有了这一机制，我们就不需要在其他地方对错误进行补救了。  

因此，网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。  
应用程序也是一样，因为采用 TCP 传输，即便发生一些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好了。  

不过，如果发生网络中断、服务器宕机等问题，那么无论 TCP 怎样重传都不管用。  
这种情况下，无论如何尝试都是徒劳，因此 TCP 会在尝试几次重传无效之后强制结束通信，并向应用程序报错。  

### 根据网络包平均往返时间调整 ACK 号等待时间

返回 ACK 号的等待时间（这个等待时间叫超时时间）。  

当网络传输繁忙时就会发生拥塞，ACK 号的返回会变慢，这时我们就必须将等待时间设置得稍微长一点，否则可能会发生已经重传了包之后，前面的 ACK 号才姗姗来迟的情况。  
这样的重传是多余的，看上去只是多发一个包而已，但它造成的后果却没那么简单。  
- 因为 ACK 号的返回变慢大多是由于网络拥塞引起的，因此如果此时再出现很多多余的重传，对于本来就很拥塞的网络来说无疑是雪上加霜；
- 不过如果某一个包被重复发送多次，接收方可以根据序号判断出这个包是重复的，因此并不会造成网络异常。

但如果等待时间过长，那么包的重传就会出现很大的延迟，也会导致网络速度变慢。  

等待时间需要设为一个合适的值，不能太长也不能太短，但这并不容易。  
根据服务器物理距离的远近，ACK 号的返回时间也会产生很大的波动，而且我们还必须考虑到拥塞带来的影响。  
- 例如，在公司里的局域网环境下，几毫秒就可以返回 ACK 号，但在互联网环境中，当遇到拥塞时需要几百毫秒才能返回ACK 号也并不稀奇。

正因为波动如此之大，所以将等待时间设置为一个固定值并不是一个好办法。  
因此，TCP 采用了动态调整等待时间的方法，这个等待时间是根据 ACK 号返回所需的时间来判断的。  
- 具体来说，TCP 会在发送数据的过程中持续测量ACK 号的返回时间，
  - 如果ACK 号返回变慢，则相应延长等待时间；
  - 相对地，如果ACK 号马上就能返回，则相应缩短等待时间。
- 由于计算机的时间测量精度较低，ACK 返回时间过短时无法被正确测量，因此等待时间有一个最小值，这个值在每个操作系统上不一样，基本上是在0.5 秒到1 秒之间。

### 使用窗口有效管理 ACK 号

每发送一个包就等待一个 ACK 号的方式是最简单也最容易理解的，但在等待 ACK 号的这段时间中，如果什么都不做那实在太浪费了。  
为了减少这样的浪费，TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作。  
- 所谓滑动窗口，就是在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。
- 这样一来，等待 ACK 号的这段时间就被有效利用起来了。

虽然这样做能够减少等待 ACK 号时的时间浪费，但有一些问题需要注意。  
在一来一回方式中，接收方完成接收操作后返回 ACK 号，然后发送方收到 ACK 号之后才继续发送下一个包，因此不会出现发送的包太多接收方处理不过来的情况。  
但如果不等返回 ACK 号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况。  

具体解释一下。  
当接收方的 TCP 收到包后，会先将数据存放到接收缓冲区中。  
然后，接收方需要计算 ACK 号，将数据块组装起来还原成原本的数据并传递给应用程序，如果这些操作还没完成下一个包就到了也不用担心，因为下一个包也会被暂存在接收缓冲区中。  
如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。  
缓冲区溢出之后，后面的数据就进不来了，因此接收方就收不到后面的包了，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力。  

可以通过下面的方法来避免这种情况的发生。  
首先，接收方需要告诉发送方自己最多能接收多少数据；  
然后发送方根据这个值对数据发送操作进行控制；  
这就是滑动窗口方式的基本思路。  

#### 滑动窗口的具体工作方式

接收方将数据暂存到接收缓冲区中并执行接收操作；  
当接收操作完成后，接收缓冲区中的空间会被释放出来，也就可以接收更多的数据了；  
这时接收方会通过TCP 头部中的窗口字段将自己能接收的数据量告知发送方；  
这样一来，发送方就不会发送过多的数据，导致超出接收方的处理能力了。  

接收方在收到数据之后马上就会开始进行处理，如果接收方的性能高，处理速度比包的到达速率还快，缓冲区马上就会被清空，并通过窗口字段告知发送方。  

能够接收的最大数据量称为窗口大小。  

### ACK 与窗口的合并

要提高收发数据的效率，还需要考虑另一个问题，那就是返回 ACK 号和更新窗口的时机。

首先，对于更新窗口大小的时机；
当收到的数据刚刚开始填入缓冲区时，其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度。
因此，更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候。
  - 这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作，
    - 因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机。

当接收方收到数据时，如果确认内容没有问题，就应该向发送方返回 ACK 号，因此我们可以认为收到数据之后马上就应该进行这一操作。

如果将前面两个因素结合起来看：  
首先，发送方的数据到达接收方，在接收操作完成之后就需要向发送方返回 ACK 号，而再经过一段时间，当数据传递给应用程序之后才需要更新窗口大小。

但如果根据这样的设计来实现，每收到一个包，就需要向发送方分别发送 ACK 号和窗口更新这两个单独的包。
这样一来，接收方发给发送方的包就太多了，导致网络效率下降。
因此，接收方在发送ACK 号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了。

举些例子：
- 在等待发送 ACK 号的时候正好需要更新窗口，这时就可以把 ACK 号和窗口更新放在一个包里发送，从而减少包的数量；
- 当需要连续发送多个 ACK 号时，也可以减少包的数量，只要发送最后一个ACK 号就可以了，中间的可以全部省略；
  - 这是因为 ACK 号表示的是已收到的数据量，也就是说，它是告诉发送方目前已接收的数据的最后位置在哪里，
- 当需要连续发送多个窗口更新时也可以减少包的数量，这种情况和 ACK 号一样，可以省略中间过程，只要发送最终的结果就可以了。
  - 连续发生窗口更新说明应用程序连续请求了数据，接收缓冲区的剩余空间连续增加。

### 接收 HTTP 响应消息

至此讲解完协议栈接到浏览器委托后发送 HTTP 请求消息的一系列操作过程了。  
不过，浏览器的工作并非到此为止。发送 HTTP 请求消息后，接下来还需要等待 Web 服务器返回响应消息。  
对于响应消息，浏览器需要进行接收操作，这一操作也需要协议栈的参与。  

首先，浏览器在委托协议栈发送请求消息之后，会调用 read 程序来获取响应消息。  
然后，控制流程会通过 read 转移到协议栈，  
然后协议栈会执行接下来的操作。  

和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下：  
首先，协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。  
响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。  
这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作。  

> 大家可以认为这时协议栈会进入暂停状态，但实际上并非如此。  
  协议栈会负责处理来自很多应用程序的工作，因此挂起其中一项工作并不意味着协议栈就完全暂停了，协议栈会继续执行其他的工作。  
  在执行其他工作的时候，挂起的工作并没有在执行，因此看上去和暂停是一样的。  

之前有说过协议栈接收数据的具体操作，这里进行简单总结：  
首先，协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号；  
然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序；  
- 具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。
将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新。  
- 如果窗口更新能够和 ACK 号等合并的话，在这里就会发送合并后的包。

## 从服务器断开并删除套接字

### 数据发送完毕后断开连接

应用程序判断所有数据都已经发送完毕时，数据发送完毕的一方会发起断开过程，但不同的应用程序会选择不同的断开时机。  

以 Web 为例：  
浏览器向 Web 服务器发送请求消息，Web 服务器再返回响应消息，这时收发数据的过程就全部结束了，服务器一方会发起断开过程。  
  - 这里讲的是 HTTP 1.0 的情形；
  - 在 HTTP 1.1 中，服务器返回响应消息之后，客户端还可以继续发起下一个请求消息，如果接下来没有请求要发送了，客户端一方会发起断开过程。

也有一些程序是客户端发送完数据就结束了，不用等服务器响应，这时客户端会先发起断开过程。  
这一判断是应用程序作出的，协议栈在设计上允许任何一方先发起断开过程。  

无论哪种情况，完成数据发送的一方会发起断开过程，这里我们以服务器一方发起断开过程为例来进行讲解。  
首先，服务器一方的应用程序会调用 Socket 库的 close 程序。  
然后，服务器的协议栈会生成包含断开信息的 TCP 头部，具体来说就是将控制位中的 FIN 比特设为 1。  
接下来，协议栈会委托IP 模块向客户端发送数据。  
- 同时，服务器的套接字中也会记录下断开操作的相关信息。

接下来轮到客户端了。  
当收到服务器发来的 FIN 为 1 的 TCP 头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态；  
然后，为了告知服务器已收到 FIN 为 1 的包，客户端会向服务器返回一个 ACK 号；  
这些操作完成后，协议栈就可以等待应用程序来取数据了；  
过了一会儿，应用程序就会调用 read 来读取数据；
- 这时，协议栈不会向应用程序传递数据，而是会告知应用程序（浏览器）来自服务器的数据已经全部收到了；
- 根据规则，服务器返回请求之后，Web 通信操作就全部结束了，因此只要收到服务器返回的所有数据，客户端的操作也就随之结束了。
客户端应用程序会调用 close 来结束数据收发操作；  
这时客户端的协议栈也会和服务器一样，生成一个 FIN 比特为 1 的 TCP 包，然后委托 IP 模块发送给服务器；  
一段时间之后，服务器就会返回 ACK 号；  
到这里，客户端和服务器的通信就全部结束了。  

### 删除套接字

和服务器的通信结束之后，用来通信的套接字也就不会再使用了，这时我们就可以删除这个套接字了。  
不过，套接字并不会立即被删除，而是会等待一段时间之后再被删除。  

等待这段时间是为了防止误操作，引发误操作的原因有很多，这里无法全部列举，下面来举一个最容易理解的例子。  

假设是客户端先发起断开，则断开的操作顺序如下：  
1. 客户端发送 FIN；
2. 服务器返回 ACK 号；
3. 服务器发送 FIN；
4. 客户端返回 ACK 号。

如果最后客户端返回的 ACK 号丢失了，服务器没有接收到 ACK 号，可能会重发一次 FIN ；  
但如果这时客户端的套接字已经删除了，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来；  
这时如果别的应用程序要创建套接字，新套接字碰巧又被分配到了同一个端口号，而服务器重发的 FIN 正好到达；  
本来这个 FIN 是要发给之前被删掉的套接字的，但新套接字有同样的端口号，于是这个 FIN 就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。  
之所以不马上删除套接字，就是为了防止这样的误操作。  

至于具体等待多长时间，这和包重传的操作方式有关。  
网络包丢失之后会进行重传，这个操作通常要持续几分钟。  
如果重传了几分钟之后依然无效，则停止重传。  
在这段时间内，网络中可能存在重传的包，也就有可能发生前面讲到的这种误操作，因此需要等待到重传完全结束。  
协议中对于这个等待时间没有明确的规定，一般来说会等待几分钟之后再删除套接字。  

### 数据收发操作小结

数据收发操作的步骤：

1. 创建套接字；
   - 一般来说，服务器一方的应用程序在启动时就会创建好套接字并进入等待连接的状态；
   - 客户端则一般是在用户触发特定动作，需要访问服务器的时候创建套接字；
   - 在这个阶段，还没有开始传输网络包。
2. 客户端会向服务器发起连接操作；
   - 首先，客户端会生成一个 SYN 为 1 的 TCP 包并发送给服务器；
     - 这个 TCP 包的头部还包含了客户端向服务器发送数据时使用的初始序号，以及服务器向客户端发送数据时需要用到的窗口大小。
   - 当这个包到达服务器之后，服务器会返回一个 SYN 为 1 的 TCP 包；
     - 这个包的头部中也包含了序号和窗口大小，此外还包含表示确认已收到客户端发送的 TCP 包的 ACK 号。
   - 当这个包到达客户端时，客户端会向服务器返回一个包含表示确认的 ACK 号的 TCP 包；
   - 到这里，连接操作就完成了，双方进入数据收发阶段。
3. 数据收发阶段；
数据收发阶段的操作根据应用程序的不同而有一些差异，以 Web 为例：  
   - 首先客户端会向服务器发送请求消息；
     - TCP 会将请求消息切分成一定大小的块，并在每一块前面加上 TCP 头部，然后发送给服务器；
     - TCP 头部中包含序号，它表示当前发送的是第几个字节的数据。
   - 当服务器收到数据时，会向客户端返回 ACK 号；
     - 在最初的阶段，服务器只是不断接收数据，随着数据收发的进行，数据不断传递给应用程序，接收缓冲区就会被逐步释放。这时，服务器需要将新的窗口大小告知客户端。
   - 当服务器收到客户端的请求消息后，会向客户端返回响应消息，这个过程和刚才的过程正好相反。
4. 断开操作。
服务器的响应消息发送完毕之后，数据收发操作就结束了，这时就会开始执行断开操作。  
以 Web 为例：  
   - 服务器会先发起断开过程；
   - 在这个过程中，服务器先发送一个 FIN 为 1 的 TCP 包；
   - 然后客户端返回一个表示确认收到的 ACK 号；
   - 接下来，双方还会交换一组方向相反的 FIN 为 1 的 TCP 包和包含 ACK 号的 TCP 包；
   - 最后，在等待一段时间后，套接字会被删除。

## IP 与以太网的包收发操作

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成包发送给通信对象。  

### 包的基本知识

包是由头部和数据两部分构成的。  
- 头部包含目的地址等控制信息；
- 头部后面就是委托方要发送给对方的数据。

TCP/IP包：  
|MAC头部|IP头部|TCP头部|数据块|
|---|---|---|---|
|MAC头部：以太网控制信息|IP头部：IP控制信息|||

一般来说 TCP 头部和数据块加起来就是包的内容；  
IP 头部加 TCP 头部加数据块是 IP 包；  
IP 包加 MAC 头部是以太网包。  

#### 包发往目的地的过程

1. 首先，发送方的网络设备会负责创建包；  
   - 创建包的过程就是生成含有正确控制信息的头部，然后再附加上要发送的数据。
2. 接下来，包会被发往最近的网络转发设备；  
   - 当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里。
   - 这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个方向。
3. 接下来，包在向目的地移动的过程中，又会到达下一个转发设备，然后又会按照同样的方式被发往下一个转发设备。  
   - 就这样，经过多个转发设备的接力之后，包最终就会到达接收方的网络设备。

当然，发送方向接收方发送一个包，接收方可能也会向发送方返回一个包，此时的发送方到了接下来的某个时刻就会变成接收方。  
因此，我们不需要把发送方和接收方明确区分开来，在这里我们把发送方和接收方统称为终端节点。  
- 相应地，转发设备被称为转发节点或者中间节点。


网络中有路由器和集线器两种不同的转发设备，它们在传输网络包时有着各自的分工。  
1. 路由器根据目标地址判断下一个路由器的位置；
2. 集线器在子网中将网络包传输到下一个路由。

实际上，集线器是按照以太网规则传输包的设备，而路由器是按照 IP 规则传输包的设备，因此我们也可以作如下理解。  
1. IP 协议根据目标地址判断下一个 IP 转发设备的位置；
2. 子网中的以太网协议将包传输到下一个转发设备。

TCP/IP 包包含如下两个头部：  
1. MAC 头部（用于以太网协议）；
2. IP 头部（用于 IP 协议）。

这两个头部分别具有不同的作用。 
 
1. 首先，发送方将包的目的地，也就是要访问的服务器的 IP 地址写入 IP 头部中；  
   - 这样一来，我们就知道这个包应该发往哪里，IP 协议就可以根据这一地址查找包的传输方向，从而找到下一个路由器的位置。  
2. 接下来，IP 协议会委托以太网协议将包传输过去；  
   - 这时，IP 协议会查找下一个路由器的以太网地址（ MAC 地址），并将这个地址写入 MAC 头部中；
   - 这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。  
3. 网络包在传输过程中会经过集线器，集线器是根据以太网协议工作的设备;  
   - 为了判断包接下来应该向什么地方传输，集线器里有一张表（用于以太网协议的表），可根据以太网头部中记录的目的地信息查出相应的传输方向;
   - 当存在多个集线器时，网络包会按顺序逐一通过这些集线器进行传输。  
4. 接下来，包会到达下一个路由器；
   - 路由器中有一张 IP 协议的表，可根据这张表以及 IP 头部中记录的目的地信息查出接下来应该发往哪个路由器;
   - 为了将包发到下一个路由器，我们还需要查出下一个路由器的 MAC 地址，并记录到 MAC 头部中，大家可以理解为改写了 MAC 头部;
   - 这样，网络包就又被发往下一个节点了;
   - 更准确地说，收到包的时候 MAC 头部会被舍弃，而当再次发送的时候又会加上包含新 MAC 地址的新 MAC 头部。
5. 这个过程不断重复，最终网络包就会被送到目的地。
   - 当目的地设备成功接收之后，网络包的传输过程就结束了。

这就是一个网络包从出发到到达目的地的全过程。  

虽然看起来有点复杂，不过设计这样的分工是有原因的。  
其中以太网的部分也可以替换成其他的东西，例如无线局域网、ADSL、FTTH 等，它们都可以替代以太网的角色帮助 IP 协议来传输网络包。  
- 当使用除以太网之外的其他网络进行传输时，MAC 头部也会被替换为适合所选通信规格的其他头部。
因此，将 IP 和负责传输的网络分开，可以更好地根据需要使用各种通信技术。像互联网这样庞大复杂的网络，在架构上需要保证灵活性，这就是设计这种分工方式的原因。  

### 在协议栈中 IP 模块如何完成包收发操作概览

尽管之前说 IP 模块负责将包发给对方，但实际上将包从发送方传输到接收方的工作是由集线器、路由器等网络设备来完成的，  
因此 IP 模块仅仅是整个包传输过程的入口而已。即便如此，IP 模块还是有很多工作需要完成。  

1. 包收发操作的起点是 TCP 模块委托 IP 模块发送包的操作；
   - 这个委托的过程就是 TCP 模块在数据块的前面加上 TCP 头部，然后整个传递给 IP 模块，这部分就是网络包的内容。
   - 与此同时，TCP 模块还需要指定通信对象的 IP 地址，也就是需要写清楚“将什么内容发给谁”。
2. 收到委托后，IP 模块会将包的内容当作一整块数据，在前面加上包含控制信息的头部，即 IP 头部和 MAC 头部这两种头部；
   - IP 头部中包含 IP 协议规定的、根据 IP 地址将包发往目的地所需的控制信息；
   - MAC 头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息；
   - 加上这两个头部之后，一个包就封装好了，这些就是 IP 模块负责的工作。
     - 凡是局域网所使用的头部都叫 MAC 头部，但其内容根据局域网的类型有所不同；
     - 此外，对于除局域网之外的其他通信技术，还有不同名称的各种头部，但它们只是名字不叫 MAC 头部而已，承担的作用和 MAC 头部是相同的。
3. 接下来，封装好的包会被交给网络硬件，例如以太网、无线局域网等；
   - 网络硬件可能是插在计算机主板上的板卡，也可能是笔记本电脑上的 PCMCIA 卡，或者是计算机主板上集成的芯片；
   - 不同形态的硬件名字也不一样，本书将它们统称为网卡。
4. 传递给网卡的网络包是由一连串 0 和 1 组成的数字信息，网卡会将这些数字信息转换为电信号或光信号，并通过网线（或光纤）发送出去；
5. 然后这些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步地送达接收方；
6. 包送达对方之后，对方会作出响应；
7. 返回的包也会通过转发设备发送回来，然后我们需要接收这个包；
   - 接收的过程和发送的过程是相反的，信息先以电信号的形式从网线传输进来，然后由网卡将其转换为数字信息并传递给 IP 模块；
   - 接下来，IP 模块会将 MAC 头部和 IP 头部后面的内容，也就是 TCP 头部加上数据块，传递给 TCP 模块。
8. 接下来的操作就是我们之前讲过的 TCP 模块负责的部分了。

在这个过程中，有2个关键的点。  
1. IP 的包收发操作都是相同的，并不会因包本身而有所区别；  
   - 因为 IP 模块会将 TCP 头部和数据块看作一整块二进制数据，在执行收发操作时并不关心其中的内容。
2. IP 模块也不关心 TCP 的操作阶段，对于包的乱序和丢失也一概不知。  
   - 总之，IP 的职责就是将委托的东西打包送到对方手里，或者是将对方送来的包接收下来，仅此而已。

### 生成包含接收方 IP 地址的 IP 头部

IP 模块接受 TCP 模块的委托负责包的收发工作，它会生成 IP 头部并附加在 TCP 头部前面。  

IP 头部最重要的内容就是 IP 地址，它表示这个包应该发到哪里去；  
- 这个地址是由 TCP 模块告知的，而 TCP 又是在执行连接操作时从应用程序那里获得这个地址的，因此这个地址的最初来源就是应用程序。
- IP 不会自行判断包的目的地，而是将包发往应用程序指定的接收方，即便应用程序指定了错误的 IP 地址，IP 模块也只能照做。

IP 头部中还需要填写发送方的IP 地址；  
- 一般的客户端计算机上只有一块网卡，因此也就只有一个 IP 地址，这种情况下我们可以认为这个 IP 地址就是计算机的 IP 地址；
- 但如果计算机上有多个网卡，情况就没那么简单了。
  - IP 地址实际上并不是分配给计算机的，而是分配给网卡的，因此当计算机上存在多块网卡时，每一块网卡都会有自己的 IP 地址；
  - 很多服务器上都会安装多块网卡，这时一台计算机就有多个 IP 地址，在填写发送方 IP 地址时就需要判断到底应该填写哪个地址；
  - 这个判断相当于在多块网卡中判断应该使用哪一块网卡来发送这个包，也就相当于判断应该把包发往哪个路由器；
  - 因为只要确定了目标路由器，也就确定了应该使用哪块网卡，也就确定了发送方的 IP 地址。
>（因为 IP 表，即路由表（Routing Table）中目标路由器的 IP 和转发路由器的 IP 和网卡这样的网络接口是有对应关系的。）

接下来还需要填写协议号。
- 它表示包的内容是来自哪个模块的
  - 如果是TCP 模块委托的内容，则设置为06（十六进制）；
  - 如果是UDP 模块委托的内容，则设置为17（十六进制）；
  - 这些值都是按照规则来设置的。

### 生成以太网用的MAC 头部

生成了 IP 头部之后，接下来 IP 模块还需要在 IP 头部的前面加上 MAC 头部；  
IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，TCP/IP 的这个思路是行不通的；  
以太网在判断网络包目的地时和 TCP/IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的。  

IP 模块在生成 IP 头部之后，会在它前面再加上 MAC 头部。MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。  

MAC 头部的开头是接收方和发送方的 MAC 地址；  
- 大家可以认为它们和IP 头部中的接收方和发送方IP 地址的功能差不多，只不过 IP 地址的长度为32 比特，而MAC地址为48 比特。
- 此外，IP 地址是类似多少弄多少号这种现实中地址的层次化的结构，而 MAC 地址中的 48 比特可以看作是一个整体。

尽管有上述差异，但从表示接收方和发送方的意义上来说，MAC 地址和 IP 地址是没有区别的，因此可以暂且先把它们当成是一回事。  

第 3 个以太类型字段和 IP 头部中的协议号类似。  
在 IP 中，协议号表示 IP 头部后面的包内容的类型；  
而在以太网中，我们可以认为以太网类型后面就是以太网包的内容，而以太类型就表示后面内容的类型。  
以太网包的内容可以是 IP 、 ARP 等协议的包，它们都有对应的值，这也是根据规则来确定的。  

MAC 头部的字段：  
|字段名称|长度（比特）|含义|
|---|---|---|
|接收方 MAC 地址|48|网络包接收方的 MAC 地址，在局域网中使用这一地址来传输网络包|
|发送方 MAC 地址|48|网络包发送方的 MAC 地址，接收方通过它来判断是谁发送了这个包|
|以太类型|16|使用的协议类型。一般在 TCP/IP 通信中只使用 0800：IP 协议 和 0806：ARP 协议 这两种|

在生成 MAC 头部时，只要设置接收方 MAC 地址、发送方 MAC 地址、以太类型这 3 个字段就可以了。  
以太类型：这里填写表示 IP 协议的值 0800（十六进制）；  
发送方 MAC 地址，这里填写网卡本身的 MAC 地址；  
  - MAC 地址是在网卡生产时写入ROM里的，只要将这个值读取出来写入 MAC 头部就可以了；
    - 实际上，只有在操作系统启动过程中对网卡进行初始化的时候才会读取 MAC 地址，读取出来之后会存放在内存中，每次执行收发操作时实际上使用的是内存中的值。
  - 对于多块网卡的情况，判断出从哪块网卡发送包，然后将这块网卡对应的 MAC 地址填进去就好了。
接收方 MAC 地址，IP 模块根据路由表 Gateway 栏的内容判断应该把包发送给谁，但只知道对方的 IP 地址，还不知道对方的 MAC 地址，所以需要根据 IP 地址查询 MAC 地址。  

### 通过 ARP 查询目标路由器的 MAC 地址

在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。  

ARP（Address Resolution Protocol，地址解析协议。）就是利用广播对所有设备提问：“×× 这个 IP 地址是谁的？请把你的 MAC 地址告诉我。”
然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是××××。
- 不是这个IP 地址的设备会忽略广播，什么都不回答。

如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址，然后，我们将这个 MAC 地址写入 MAC 头部，MAC头部就完成了。  
如果不在同一个子网，那 ARP 的对象就变成默认网关，数据包交给网关，由路由器转发。  
  - 永远不会 ARP 远端主机的 IP。

不过，如果每次发送包都要这样查询一次，网络中就会增加很多 ARP 包，因此我们会将查询结果放到一块叫作 ARP 缓存的内存空间中留着以后用。  
也就是说，在发送包时，先查询一下 ARP 缓存。  
- 如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址；
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 查询。

MAC 地址的写法：  
1. 用“-”分隔的写法：00-80-C8-2D-82-EA
2. 用“:”分隔的写法：00:80:C8:2D:82:EA
MAC 地址的长度为 48 比特，即6字节，按照惯例有这两种写法，它们的意思是一样的，使用任何一种写法都可以。  

有了 ARP 缓存，我们可以减少 ARP 包的数量，但如果总是使用 ARP 缓存中保存的地址也会产生问题：  
  - 例如当 IP 地址发生变化时，ARP 缓存的内容就会和现实发生差异。  
为了防止这种问题的发生，ARP 缓存中的值在经过一段时间后会被删除，一般这个时间在几分钟左右。  
  - 这个删除的操作非常简单粗暴，不管 ARP 缓存中的内容是否有效，只要经过几分钟就全部删掉，这样就不会出问题了。  
  - 当地址从 ARP 缓存中删除后，只要重新执行一次 ARP 查询就可以再次获得地址了。  
上面这个策略能够在几分钟后消除缓存和现实的差异，但 IP 地址刚刚发生改变的时候，ARP 缓存中依然会保留老的地址，这时就会发生通信的异常。  
  - 遇到这种情况，可以查看ARP 缓存的内容，并手动删除过时的条目。

将 MAC 头部加在 IP 头部的前面，整个包就完成了。
- 到这里为止，整个打包的工作是由 IP 模块负责的。  
  有人认为，MAC 头部是以太网需要的内容，并不属于 IP 的职责范围，但从现实来看，让IP 负责整个打包工作是有利的。  
  如果在交给网卡之前，IP 模块能够完成整个打包工作，那么网卡只要将打好的包发送出去就可以了。  
  对于除 IP 以外的其他类型的包也是一样，如果在交给网卡之前完成打包，那么对于网卡来说，发送的操作和发送IP 包是完全相同的。  
  这样一来，同一块网卡就可以支持各种类型的包。  
- 至于接收操作，我们到后面会讲，但如果接收的包可以原封不动直接交给IP 模块来处理，网卡就只要负责接收就可以了。  
  这样一来，一块网卡也就能支持各种类型的包了。  
  与其机械地设计模块和设备之间的分工，导致网卡只能支持IP 包，不如将分工设计得现实一些，让网卡能够灵活支持各种类型的包。  
  
### 以太网的基本知识

以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术。

通过 MAC 头部中的接收方 MAC 地址，就能够知道包是发给谁的；  
而通过发送方 MAC 地址，就能够知道包是谁发出的；  
此外，通过以太类型就可以判断包里面装了什么类型的内容。  
以太网其实就这么简单。  

尽管以太网经历了数次变迁，但其基本的 3 个性质至今仍未改变，即将包发送到 MAC 头部的接收方 MAC 地址代表的目的地，用发送方 MAC地址识别发送方，用以太类型识别包的内容。  
因此，大家可以认为具备这 3 个性质的网络就是以太网。  

以太网中的各种设备也是基于以太网规格来工作的，因此下面的内容不仅适用于客户端计算机，同样也适用于服务器、路由器等各种设备。  
- 路由器等网络设备的网卡是集成在设备内部的，其电路的设计也有所不同，尽管结构有差异，但功能和行为是没有区别的。
此外，以太网和 IP 一样，并不关心网络包的实际内容，因此以太网的收发操作也和 TCP 的工作阶段无关，都是共通的，同样也与应用程序的种类无关。  

### 将 IP 包转换成电或光信号发送出去

以太网的包收发操作：  
IP 生成的网络包只是存放在内存中的一串数字信息，没有办法直接发送给对方。  
因此，我们需要将数字信息转换为电或光信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。  

负责执行这一操作的是网卡，但网卡也无法单独工作，要控制网卡还需要网卡驱动程序。  

#### 网卡的初始化过程

网卡并不是通上电之后就可以马上开始工作的，而是和其他硬件一样，都需要进行初始化。  
- 也就是说，打开计算机启动操作系统的时候，网卡驱动程序会对硬件进行初始化操作，然后硬件才进入可以使用的状态； 
- 这些操作包括硬件错误检查、初始设置等步骤，这些步骤对于很多其他硬件也是共通的。
  - 但也有一些操作是以太网特有的，那就是在控制以太网收发操作的 MAC 模块中设置 MAC 地址。

网卡的 ROM 中保存着全世界唯一的 MAC 地址，这是在生产网卡时写入的，将这个值读出之后就可以对 MAC 模块进行设置，MAC 模块就知道自己对应的 MAC 地址了。  
也有一些特殊的方法，比如从命令或者配置文件中读取 MAC 地址并分配给 MAC 模块。这种情况下，网卡会忽略 ROM 中的 MAC 地址。  

有人认为在网卡通电之后，ROM 中的 MAC 地址就自动生效了，其实不然，真正生效的是网卡驱动进行初始化时在 MAC 模块中设置的那个 MAC 地址。  
在操作系统启动并完成这些初始化操作之后，网卡就可以等待来自 IP 的委托了。  

### 给网络包再加 3 个控制数据

网卡将包转换成电信号并发送到网线中的过程：  
网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向 MAC 模块发送发送包的命令。接下来就轮到 MAC 模块进行工作了。  
1. 首先，MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列；
   - 报头是一串像 10101010… 这样 1 和 0 交替出现的比特序列，长度为 56 比特，它的作用是确定包的读取时机;
     - 当这些 1010 的比特序列被转换成电信号后，会形成波形。接收方在收到信号时，遇到这样的波形就可以判断读取数据的时机。
      - 关于如何通过电信号来读取数据：
       1. 用电信号来表达数字信息时，我们需要让 0 和 1 两种比特分别对应特定的电压和电流;
          - 通过测量信号中的电压和电流变化，还原出 0 和 1 两种比特的值;
          - 如果 1 和 0 连续出现的信号，由于电压和电流没有变化，我们就没办法判断出其中每个比特到底应该从哪里去切分。
       2. 要解决这个问题，最简单的方法就是在数据信号之外再发送一组用来区分比特间隔的时钟信号;
          - 因为各种原因，数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移。
       3. 要解决这个问题，可以采用将数据信号和时钟信号叠加在一起的方法。
          - 由于时钟信号是按固定频率变化的，只要对信号进行一段时间的观察，就可以找到其变化的周期，此时通过接收信号和时钟信号算出数据信号，从而还原 0 或 1 的比特的值。
   - 因此我们在包的数据前面加上一段用来测量时钟信号的特殊信号，即报头，就可以确定包的读取时机。

> 如果在包信号结束之后，继续传输时钟信号，就可以保持时钟同步的状态，下一个包就无需重新进行同步。  
  有些通信方式采用了这样的设计，但以太网的包结束之后时钟信号也跟着结束了，没有通过这种方式来保持时钟同步，因此需要在每个包的前面加上报头，用来进行时钟同步。  

起始帧分界符是一个用来表示包起始位置的标记。  
它的末尾比特排列有少许变化。接收方以这一变化作为标记，从这里开始提取网络包数据。  

末尾的 FCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串 32 比特的序列，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的。  
在包传输过程中，如果受到噪声的干扰而导致其中的数据发生了变化，那么接收方计算出的FCS 和发送方计算出的FCS 就会不同，这样我们就可以判断出数据有没有错误。  

### 向集线器发送网络包

加上报头、起始帧分界符和 FCS 之后，我们就可以将包通过网线发送出去了。  
发送信号的操作分为两种：  
1. 使用集线器的半双工模式；
   - 某一时刻只能进行发送或接收其中一种操作的叫作“半双工”；
2. 使用交换机的全双工模式。
   - 发送和接收同时并行的方式叫作“全双工”。

在半双工模式中，为了避免信号碰撞，首先要判断网线中是否存在其他设备发送的信号。  
- 如果有，则需要等待该信号传输完毕；
  - 因为如果在有信号时再发送一组信号，两组信号就会发生碰撞。
- 当之前的信号传输完毕，或者本来就没有信号在传输的情况下，我们就可以开始发送信号了。

1. 首先，MAC 模块从报头开始将数字信息按每个比特转换成电信号，然后由 PHY，或者叫 MAU 的信号收发模块发送出去；
   - 在这里，将数字信息转换为电信号的速率就是网络的传输速率；
     - 例如每秒将 10 Mbit 的数字信息转换为电信号发送出去，则速率就是 10 Mbit/s。
   - 根据以太网信号方式的不同，有些地方叫 MAU（Medium Attachment Unit，介质连接单元），有些地方叫 PHY（Physical Layer Device，物理层装置）。
     - 在速率为 100 Mbit/s 以上的以太网中都叫 PHY。
2. 接下来，PHY（MAU）模块会将信号转换为可在网线上传输的格式，并通过网线发送出去。
   - 以太网规格中对不同的网线类型和速率以及其对应的信号格式进行了规定，但 MAC 模块并不关心这些区别，而是将可转换为任意格式的通用信号发送给PHY（MAU）模块；
     - 然后 PHY（MAU）模块再将其转换为可在网线上传输的格式。
   - 可以认为 PHY（MAU）模块的功能就是对 MAC 模块产生的信号进行格式转换。

#### PHY（MAU）的职责

1. 将MAC 模块传递过来的信号通过网线发送出去；
2. 监控接收线路中有没有信号进来。
   - 在开始发送信号之前，需要先确认没有其他信号进来，这时才能开始发送；
   - 如果在信号开始发送到结束发送的这段时间内一直没有其他信号进来，发送操作就成功完成了。

> 以太网不会确认发送的信号对方有没有收到。  
  根据以太网的规格，两台设备之间的网线不能超过 100 米，在这个距离内极少会发生错误，万一发生错误，协议栈的 TCP 也会负责搞定，因此在发送信号时没有必要检查错误。  
  - 100 米时使用双绞线的情况，如果采用光纤则可以更长，而且错误率不会上升；
  - 实际上的错误率低于万分之一。

如果有多台设备同时向一台设备发送信号，这些信号就会通过接收线路一起传进来；
在使用集线器的半双工模式中，一旦发生这种情况，两组信号就会相互叠加，无法彼此区分出来，这就是所谓的信号碰撞。
- 这种情况下，继续发送信号是没有意义的，因此发送操作会终止。
- 为了通知其他设备当前线路已发生碰撞，还会发送一段时间的阻塞信号，
  - 然后所有的发送操作会全部停止。
等待一段时间之后，网络中的设备会尝试重新发送信号。
- 但如果所有设备的等待时间都相同，那肯定还会发生碰撞，因此必须让等待的时间相互错开。
具体来说，等待时间是根据 MAC 地址生成一个随机数计算出来的。

> 当网络拥塞时，发生碰撞的可能性就会提高，重试发送的时候可能又会和另外一台设备的发送操作冲突，这时会将等待时间延长一倍，然后再次重试。
  以此类推，每次发生碰撞就将等待时间延长一倍，最多重试10次，如果还是不行就报告通信错误。

在全双工模式中，发送和接收可以同时进行，不会发生碰撞。  
因此，全双工模式中不需要像半双工模式这样考虑这么多复杂的问题，即便接收线路中有信号进来，也可以直接发送信号。  
关于全双工模式会在第三章介绍。  

### 接收返回包

在使用集线器的半双工模式以太网中，一台设备发送的信号会到达连接在集线器上的所有设备。  
这意味着无论是不是发给自己的信号都会通过接收线路传进来，因此接收操作的第一步就是不管三七二十一把这些信号全都收进来再说。  

信号的开头是报头，通过报头的波形同步时钟，然后遇到起始帧分界符时开始将后面的信号转换成数字信息。  

首先，PHY（MAU）模块会将信号转换成通用格式并发送给MAC 模块，
MAC 模块再从头开始将信号转换为数字信息，并存放到缓冲区中。
当到达信号的末尾时，还需要检查FCS。
  - 具体来说，就是将从包开头到结尾的所有比特套用到公式中计算出FCS，然后和包末尾的FCS 进行对比，
    - 正常情况下两者应该是一致的，
    - 如果中途受到噪声干扰而导致波形发生紊乱，则两者的值会产生差异，这时这个包就会被当作错误包而被丢弃。
如果FCS 校验没有问题，接下来就要看一下MAC 头部中接收方 MAC 地址与网卡在初始化时分配给自己的MAC 地址是否一致
  - 以此来判断这个包是不是发给自己的
    - 我们没必要去接收发给别人的包，因此如果不是自己的包就直接丢弃，
    - 如果接收方MAC 地址和自己MAC 地址一致，则将包放入缓冲区中
    - 到这里，MAC 模块的工作就完成了，接下来网卡会通知计算机收到了一个包。

#### 中断

通知计算机的操作会使用一个叫作中断的机制。  
- 在网卡执行接收包的操作的过程中，计算机并不是一直监控着网卡的活动，而是去继续执行其他的任务。
- 因此，如果网卡不通知计算机，计算机是不知道包已经收到了这件事的。
  - 网卡驱动也是在计算机中运行的一个程序，因此它也不知道包到达的状态。
在这种情况下，我们需要一种机制能够打断计算机正在执行的任务，让计算机注意到网卡中发生的事情，这种机制就是中断。  

具体来说，中断的工作过程是这样的：  
首先，网卡向扩展总线中的中断信号线发送信号；  
  - 该信号线通过计算机中的中断控制器连接到CPU。
当产生中断信号时，CPU 会暂时挂起正在处理的任务，切换到操作系统中的中断处理程序；  
  - 中断处理程序执行完毕之后，CPU 会继续处理原来的任务。
然后，中断处理程序会调用网卡驱动，控制网卡执行相应的接收操作。  

中断是有编号的，网卡在安装的时候就在硬件中设置了中断号，在中断处理程序中则将硬件的中断号和相应的驱动程序绑定。  
  - 例如，假设网卡的中断号为11，则在中断处理程序中将中断号11 和相应的网卡驱动绑定起来，当网卡发起中断时，就会自动调用网卡驱动了；
  - 现在的硬件设备都遵循即插即用规范自动设置中断号，我们没必要去关心中断号了，
    - 即插即用英文缩写为 PnP (Plug and Play)，是一种自动对扩展卡和周边设备进行配置的功能。

网卡驱动被中断处理程序调用后，会从网卡的缓冲区中取出收到的包，并通过 MAC 头部中的以太类型字段判断协议的类型。  

现在在大多数情况下都是使用 TCP/IP 协议，但除了 TCP/IP 之外还有很多其他类型的协议；
  - 例如 NetWare 中使用的 IPX/SPX，以及 Mac 电脑中使用的 AppleTalk 等协议。
这些协议都被分配了不同的以太类型。
  - 如 0080（十六进制）代表 IP 协议，网卡驱动就会把这样的包交给 TCP/IP 协议栈；
  - 如果是 809B 则表示 AppleTalk 协议，就把包交给 AppleTalk 协议栈；
  - 以此类推。

按照探索之旅的思路，大家可能会认为向 Web 服务器发送包之后，后面收到的一定是 Web 服务器返回的包，其实并非如此。  
计算机中同时运行了很多程序，也会同时进行很多通信操作，因此收到的包也有可能是其他应用程序的。  
不过，即便如此也没问题，网卡不会关心包里的内容。  
- 只要按照以太类型将包交给对应的协议栈就可以了；
- 接下来，协议栈会判断这个包应该交给哪个应用程序，并进行相应的处理。

### 将服务器的响应包从 IP 传递给 TCP

假设 Web 服务器返回了一个网络包，此时协议栈会进行的处理：  
1. 服务器返回的包的以太类型应该是 0800 ，因此网卡驱动会将其交给 TCP/IP 协议栈来进行处理；
2. IP 模块开始工作；
   1. 第一步是检查 IP 头部，确认格式是否正确；
   2. 如果格式没有问题，下一步就是查看接收方 IP 地址；
      - 服务器返回的包的接收方 IP 地址应该与客户端网卡的地址一致，检查确认后就可以接收这个包了；
        - 此时还需要完成另一项工作：分片重组。
          - IP 协议有一个叫作分片的功能，简单来说，网线和局域网中只能传输小包，因此需要将大的包切分成多个小包；
          - 如果接收到的包是经过分片的，那么 IP 模块会将它们还原成原始的包；
          - 分片的包会在 IP 头部的标志字段中进行标记，当收到分片的包时，IP 模块会将其暂存在内部的内存空间中，然后等待IP头部中具有相同ID 的包全部到达，这是因为同一个包的所有分片都具有相同的 ID；
          - IP 头部还有一个分片偏移量（fragment offset）字段，它表示当前分片在整个包中所处的位置；
          - 根据这些信息，在所有分片全部收到之后，就可以将它们还原成原始的包，这个操作叫作分片重组。
      - 如果 IP 地址不一致，那一定是发生了什么错误，客户端计算机不负责对包进行转发，因此不应该收到不是发给自己的包。
        - 当发生这种错误时，IP 模块会通过 ICMP 消息中的 Destination unreachable 将错误告知发送方。
   3. 到这里，IP 模块的工作就结束了。 
3. 包会交给 TCP 模块，TCP 模块会根据 IP 头部中的接收方和发送方 IP 地址，以及 TCP 头部中的接收方和发送方端口号来查找对应的套接字。
   - 找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了。例如：
     - 如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取；
     - 如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立和断开连接的操作状态。

## UDP 协议的收发操作

### 不需要重发的数据用 UDP 发送更高效

大多数的应用程序都像之前介绍的一样使用 TCP 协议来收发数据，但当然也有例外。  
有些应用程序不使用 TCP 协议，而是使用 UDP 协议来收发数据。向 DNS 服务器查询 IP 地址的时候我们用的也是 UDP 协议。  

TCP 是一种复杂的机制，因为需要确保能够将数据高效且可靠地发送给对方。  
为了实现可靠性，就需要确认对方是否收到了发送的数据，如果没有就再发一遍；  
  - 要实现上面的要求，最简单的办法就是数据全部发送完毕之后让接收方返回一个接受确认。  
    - 如果没收到就直接全部重新发送一遍，但这种就很低效。
为了实现高效，就需要避免重发已经送达的包，只发那些出错或者未送达的包就可以了。  
TCP 之所以复杂就是为了实现这两点。  

不过，在某些情况下，即便没有 TCP 这样复杂的机制，我们也能够高效地重发数据，这种情况就是数据很短，用一个包就能装得下。  
  - 如果只有一个包，就不用考虑哪个包未送达了，因为全部重发也只不过是重发一个包而已，这种情况下我们就不需要 TCP 这样复杂的机制了；
  - 而且，如果不使用 TCP，也不需要发送那些用来建立和断开连接的控制包了；
  - 此外，我们发送了数据，对方一般都会给出回复，只要将回复的数据当作接收确认就行了，也不需要专门的接收确认包了。

### 控制用的短数据

像 DNS 查询等交换控制信息的操作基本上都可以在一个包的大小范围内解决，这种情况就适合使用 UDP 而不是 TCP 。  

UDP 协议的功能：  
1. 发送；
   - UDP 没有 TCP 的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤；  
   - 只要在从应用程序获取的数据前面加上 UDP 头部，然后交给 IP 进行发送就可以了。  
2. 接收；
   - 接收也很简单，只要根据 IP 头部中的接收方和发送方 IP 地址，以及 UDP 头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了。  
3. 除此之外，UDP 协议没有其他功能了，遇到错误或者丢包也一概不管。
   - 因为 UDP 只负责单纯地发送包而已，并不像 TCP 一样会对包的送达状态进行监控，所以协议栈也不知道有没有发生错误；  
   - 但这样并不会引发什么问题，因此出错时就收不到来自对方的回复，应用程序会注意到这个问题，并重新发送一遍数据；  
   - 这样的操作本身并不复杂，也并不会增加应用程序的负担。  

UDP 头部（总长8字节）中的控制信息：  
|字段名称|长度（比特）|含义|
|---|---|---|
|发送方端口号|16|网络包发送方的端口号|
|接收方端口号|16|网络包接收方的端口号|
|数据长度|16| UDP 头部后面数据的长度|
|校验和|16|用于校验错误|

### 音频和视频数据

还有另一个场景会使用 UDP，就是发送音频和视频数据的时候。  
音频和视频数据必须在规定的时间内送达，一旦送达晚了，就会错过播放时机，导致声音和图像卡顿。  

如果像 TCP 一样通过接收确认响应来检查错误并重发，重发的过程需要消耗一定的时间，因此重发的数据很可能已经错过了播放的时机。  
一旦错过播放时机，重发数据也是没有用的，因为声音和图像已经卡顿了，这是无法挽回的。  
  - 当然，我们可以用高速线路让重发的数据能够在规定的时间内送达，但这样一来可能要增加几倍的带宽才行；
  - UDP 经常会被防火墙阻止，因此当需要穿越防火墙传输音频和视频数据时，尽管需要消耗额外的带宽，但有时候也只能使用 TCP。  
音频和视频数据中缺少了某些包并不会产生严重的问题，只是会产生一些失真或者卡顿而已，一般都是可以接受的。  
在这些无需重发数据，或者是重发了也没什么意义的情况下，使用 UDP 发送数据的效率会更高。  

# 从网线到网络设备-探索集线器、交换机和路由器

## 热身问答

1. 最早的以太网使用专用同轴网线，后来变成由美国室内电话线改良的版本，原因是它可以兼容电话线的布线工具和材料，比较方便。
2. 交换机比路由器更加简单，因此可能有人以为交换机应该比路由器出现得更早，其实是路由器先问世的。
3. 对于路由器和交换机，如果包在传输过程中发生错误，会直接丢弃错误的包而不会尝试修复。不过操作系统中的网络控制软件（协议栈）会对丢弃的包进行重发，数据不会因此丢失。

## 探索之旅

### 信号在网线和集线器中传输

信号从计算机中流出之后，会在网线中经过集线器等设备前进。  
此时，信号是如何在网线和集线器传输的，就是我们的第一个看点。  
信号在传输过程中会衰减，还会受到噪声干扰而失真，如何抑制这些影响是我们的另一个看点。  

### 交换机的包转发操作

交换机的工作方式也是本章看点之一。  
交换机并不只是简单地让信号流过，而是先接收信号并将其还原为数字信息，然后再重新转换成信号并发送出去的过程。  
这里我们将详细探索这一过程。  

### 路由器的包转发操作

路由器和交换机一样也负责对包进行转发，但它们的工作方式有一些差异。  
交换机是基于以太网规格工作的设备，而路由器是基于 IP 工作的，它们之间的差异也是本章看点之一。  

### 路由器的附加功能

位于互联网接入端的路由器通常还会提供一些附加功能，例如将私有地址转换为公有地址的地址转换功能，以及阻止危险网络包的包过滤功能等。  
本章最后将介绍一下这些功能，这样我们就会对路由器有较全面的认识。  

## 信号在网线和集线器中传输

### 每个包都是独立传输的

从计算机发送出来的网络包会通过集线器、路由器等设备被转发，最终到达目的地。  
转发设备会根据包头部中的控制信息，在转发设备内部一个写有转发规则的表中进行查询，以此来判断包的目的地，然后将包朝目的地的方向进行转发。  

转发设备在进行转发时也不看数据的内容。因此，无论包里面装的是应用程序的数据或者是 TCP 协议的控制信息，都不会对包的传输操作本身产生影响。  
  - TCP 控制信息也叫 TCP 头部，但从以太网和 IP 传输网络包的角度来看，TCP 头部并不算是“头部”，只能算是“数据”。
换句话说，HTTP 请求的方法，TCP 的确认响应和序号，客户端和服务器之间的关系，这一切都与包的传输无关。  
因此，所有的包在传输到目的地的过程中都是独立的，相互之间没有任何关联。  

网络包从客户端计算机发出以后，要经过集线器、交换机和路由器，最终进入互联网。  
  - 但实际上，现在一般使用的路由器已经集成了集线器和交换机的功能，使用独立设备的情况很少见。

### 防止网线中的信号衰减很重要

信号流出网卡进入网线，网卡中的 PHY（MAU）模块负责将包转换成电信号，信号通过 RJ-45 接口进入双绞线。  
  - 以太网信号的本质是正负变化的电压，大家可以认为网卡的 PHY（MAU）模块就是一个从正负两个信号端子输出信号的电路。 

网卡的 PHY（MAU）模块直接连接 RJ-45 接口，信号从这个接口中的 1 号和 2 号针脚流入网线。  
然后，信号会通过网线到达集线器的接口，这个过程就是单纯地传输电信号而已。  
但是，信号到达集线器的时候并不是跟刚发送出去的时候一模一样。集线器收到的信号有时会出现衰减。  
信号在网线的传输过程中，能量会逐渐损失。网线越长，信号衰减就越严重。  

而且，信号损失能量并非只是变弱而已，以太网中的信号波形是方形的，但损失能量会让信号的拐角变圆，这是因为电信号的频率越高，能量的损失率越大。  
信号的拐角意味着电压发生剧烈的变化，而剧烈的变化意味着这个部分的信号频率很高。  
高频信号更容易损失能量，因此本来剧烈变化的部分就会变成缓慢的变化，拐角也就变圆了。  

即便线路条件很好，没有噪声，信号在传输过程中依然会发生失真，如果再加上噪声的影响，失真就会更厉害。  
噪声根据强度和类型会产生不同的影响，无法一概而论，但如果本来就已经衰减的信号再进一步失真，就会出现对 0 和 1 的误判，这就是产生通信错误的原因。  

### “双绞”是为了抑制噪声

局域网网线使用的是双绞线，其中“双绞”的意思就是以两根信号线为一组缠绕在一起，这种拧麻花一样的设计是为了抑制噪声的影响。  

产生噪声的原因是网线周围的电磁波，当电磁波接触到金属等导体时，在其中就会产生电流。  
因此，如果网线周围存在电磁波，就会在网线中产生和原本的信号不同的电流。  
由于信号本身也是一种带有电压变化的电流，其本质和噪声产生的电流是一样的，所以信号和噪声的电流就会混杂在一起，导致信号的波形发生失真，这就是噪声的影响。  

影响网线的电磁波分为两种。  
一种是由电机、荧光灯、CRT 显示器等设备泄漏出来的电磁波，这种电磁波来自网线之外的其他设备；  
另一种电磁波是从网线中相邻的信号线泄漏出来的。  
  - 由于传输的信号本身就是一种电流，当电流流过时就会向周围发出电磁波，这些电磁波对于其他信号线来说就成了噪声。这种内部产生的噪声称为串扰（crosstalk）。

双绞线抑制第一种电磁波的原理：  
首先，信号线是用金属做成的，当电磁波接触到信号线时，会沿电磁波传播的右旋方向产生电流，这种电流会导致波形发生失真。  
如果我们将信号线缠绕在一起，信号线就变成了螺旋形，其中两根信号线中产生的噪声电流方向就会相反，从而使得噪声电流相互抵消，噪声就得到了抑制。   
当然，即便信号线变成螺旋形，里面的信号依然可以原样传输，也就是说，信号没有变，只是噪声被削弱了。  

第二种电磁波，即串扰：  
这种噪声的强度其实并不高，但问题是噪声源的距离太近了。  
距离发生源越远，电磁波就会因扩散而变得越弱，但在同一根网线中的信号线之间距离很近，这些电磁波还没怎么衰减就已经接触到了相邻的信号线。  
  - 因此，尽管信号线产生的电磁波十分微弱，也能够在相邻的信号线中产生感应电流。
要抑制这种噪声，关键在于双绞线的缠绕方式。  
  - 在一根网线中，每一对信号线的扭绞间隔（节距）都有一定的差异，这使得在某些地方正信号线距离近，另一些地方则是负信号线距离近；
  - 由于正负信号线产生的噪声影响是相反的，所以两者就会相互抵消；
  - 从网线整体来看，正负的分布保持平衡，自然就会削弱噪声的影响。

通过将信号线缠绕在一起的方式，噪声得到了抑制，从结果来看提升了网线的性能，除此之外还有其他一些工艺也能够帮助提升性能：  
  - 例如在信号线之间加入隔板保持距离，以及在外面包裹可阻挡电磁波的金属屏蔽网等。

网线的性能是以“类”来区分的，现在市售双绞线的主要种类如下表所示：  

|类|含义|
|---|---|
|五类（CAT-5）|用于10 Mbit/s（10BASE-T）和 100 Mbit/s（100BASE-TX）以太网，可以最高 125 MHz 的频率在最长 100 米的距离内传输信号|
|超五类（CAT-5e）|用于千兆（1000BASE-T）以太网，对五类网线进行了改良，改善了串扰，也向下兼容 10BASE-T 和 100BASE-TX |
|六类（CAT-6）|支持最高 250 MHz 的信号传输，用于 1000BASE-TX 规格的千兆以太网和 10GBASE-T 规格的万兆以太网，同时向下兼容 10BASE-T、100BASE-TX 和 1000BASE-T |
|超六类（CAT-6A）|对六类网线进行了改良，改善了外部串扰，兼容 10GBASE-T、1000BASE-TX、1000BASE-T、100BASE-TX 和 10BASE-T |
|七类（CAT-7）|支持最高 600 MHz 的高速信号传输， 兼容 10GBASE-T、1000BASE-TX、1000BASE-T、100BASE-TX 和 10BASE-T |

### 集线器将信号发往所有线路

当信号到达集线器后，会被广播到整个网络中。以太网的基本架构就是将包发到所有的设备，然后由设备根据接收方 MAC 地址来判断应该接收哪些包。  
而集线器就是这一架构的忠实体现，它就是负责按照以太网的基本架构将信号广播出去。  

#### 集线器的内部结构

首先，在每个接口的后面装有和网卡中的 PHY（MAU）功能相同的模块；  
  - 但如果它们像网卡端一样采用直连式接线，是无法正常接收信号的；
  - 要正常接收信号，必须将“发送线路”和“接收线路”连接起来才行。
    - 集线器中的 PHY（MAU）模块与接口之间采用交叉接线的原因正是在于此。
信号到达集线器的 PHY（MAU）模块后，会进入中继电路；  
  - 中继电路的基本功能就是将输入的信号广播到集线器的所有端口上；
  - 当然，也有一些产品具有信号整形、错误抑制等功能，但基本上就是将输入的信号原封不动地输出到网线接口。
接下来，信号从所有接口流出，到达连接在集线器上的所有设备；  
然后，这些设备在收到信号之后会通过 MAC 头部中的接收方 MAC 地址判断是不是发给自己的，如果是发给自己的就接受，否则就忽略；  
这样，网络包就能够到达指定 MAC 地址的接收方了。  

由于集线器只是原封不动地将信号广播出去，所以即便信号受到噪声的干扰发生了失真，也会原样发送到目的地。  
这时，接收信号的设备，也就是交换机、路由器、服务器等，会在将信号转换成数字信息后通过 FCS 校验发现错误，并将出错的包丢弃。  
当然，丢弃包并不会影响数据的传输，因为丢弃的包不会触发确认响应。因此协议栈的 TCP 模块会检测到丢包，并对该包进行重传。  

##### MDI/MDI-X

MDI 是 Media Dependent Interface（媒体相关接口）的缩写，MDI-X 是 MDI-Crossover 的缩写。  

集线器的接口中有一个 MDI/MDI-X 切换开关，MDI 就是对RJ-45 接口和信号收发模块进行直连接线，而 MDI-X 则是交叉接线。  
由于集线器的接口一般都是 MDI-X 模式，要将两台集线器相连时，就需要将其中一台改成 MDI 模式。  
如果集线器上没有 MDI 切换开关，而且所有的接口又都是 MDI-X 时，可以用交叉网线连接两台集线器。  
  - 所谓交叉网线，就是一种将发送和接收信号线反过来接的网线。

交叉网线也可以用于将两台计算机直接连接起来。  
网卡不仅可以连接集线器，因为网卡的 PHY（MAU）模块和集线器都是一样的，所以两台计算机的网卡也可以相互连接；  
只要将一侧的发送信号线和另一侧的接收信号线连起来就可以收发数据了。  

## 交换机的包转发操作

交换机的设计是将网络包原样转发到目的地。  

交换机的工作流程：  
首先，信号到达网线接口，并由 PHY（MAU）模块进行接收，这一部分和集线器是相同的；  
  - 也就是说，它的接口和 PHY（MAU）模块也是以 MDI-X 模式进行连接的，当信号从双绞线传入时，就会进入 PHY（MAU）模块的接收部分。
接下来，PHY（MAU）模块会将网线中的信号转换为通用格式，然后传递给 MAC 模块；  
MAC 模块将信号转换为数字信息，然后通过包末尾的 FCS 校验错误，如果没有问题则存放到缓冲区中。  
将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了；  
  - MAC 地址表主要包含两个信息；
    - 一个是设备的 MAC 地址；
    - 另一个是该设备连接在交换机的哪个端口上；
    - MAC 地址和端口是一一对应的，通过这张表就能够判断出收到的包应该转发到哪个端口。

> 大家可以认为交换机的每个网线接口后面都是一块网卡，网线接口和后面的电路部分加在一起称为一个端口，也就是说交换机的一个端口就相当于计算机上的一块网卡。  
  但交换机的工作方式和网卡有一点不同。  
  网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；  
  相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。  

交换电路的工作流程：  
交换电路中的信号线排列成网格状，每一个交叉点都有一个交换开关，交换开关是电子控制的，通过切换开关的状态就可以改变信号的流向。
交换电路的输入端和输出端分别连接各个接收端口和发送端口，网络包通过这个网格状的电路在端口之间流动。
每个交叉点上的交换开关都可以独立工作，因此只要路径不重复，就可以同时传输多路信号。

例：将包从 2 号端口发送到 7 号端口。    
1. 信号会从输入端的 2 号线进入交换电路；
2. 让左起的 6 个开关水平导通，然后将第 7 个开关切换为垂直导通；
3. 信号就会流到输出端 7 号线路，于是网络包就被发送到了 7 号端口。

当网络包通过交换电路到达发送端口时，端口中的 MAC 模块和 PHY（MAU）模块会执行发送操作，将信号发送到网线中，这部分和网卡发送信号的过程是一样的。  
根据以太网的规则，首先应该确认没有其他设备在发送信号，也就是确认信号收发模块中的接收线路没有信号进来。  
  - 如果检测到其他设备在发送信号，则需要等待信号发送完毕；
  - 如果没有其他信号，或者其他信号已经发送完毕，这时就可以将包的数字信息转换为电信号发送出去。
在发送信号的过程中，还需要对接收信号进行监控，这一点和网卡也是一样的。  
如果在发送过程中检测到其他设备发送信号，就意味着出现了信号碰撞，这时需要发送阻塞信号以停止网络中所有的发送操作，等待一段时间后再尝试重新发送，这一步和网卡也是一样的。  

### MAC 地址表的维护

交换机在转发包的过程中，还需要对 MAC 地址表的内容进行维护，维护操作分为两种。
1. 收到包时，将发送方 MAC 地址以及其输入端口的号码写入 MAC 地址表中；
   - 由于收到包的那个端口就连接着发送这个包的设备，所以只要将这个包的发送方 MAC 地址写入地址表，以后当收到发往这个地址的包时，交换机就可以将它转发到正确的端口了；
   - 交换机每次收到包时都会执行这个操作，因此只要某个设备发送过网络包，它的 MAC 地址就会被记录到地址表中。
2. 删除地址表中某条记录的操作。
   - 这是为了防止设备移动时产生问题；
     - 如果之前连接在端口的设备产生了移动，那如果交换机继续按过时记录发送数据则会导致通信出错。
   - 但是交换机也无法得知设备是否产生移动。
     - 所以地址表中的记录不能永久有效，而是要在一段时间不使用后就自动删除。
     - 过时记录从地址表中删除的时间一般为几分钟，在删除过时记录之前，依然有可能有发给该设备的包到达交换机，这是交换机正常工作就会导致通信出错。
       - 可能性很小，但确实有可能发生；
       - 这种情况下重启一下交换机，地址表就会被清空并更新正确的信息，然后网络就又可以正常工作了。

总之，交换机会自行更新或删除地址表中的记录，不需要手动维护。当地址表的内容出现异常时，只要重启一下交换机就可以重置地址表，也不需要手动进行维护。  

### 特殊操作

上面介绍了交换机的基本工作方式，下面来看一些特殊情况下的操作。  

1. 交换机查询地址表之后发现记录中的目标端口和这个包的源端口是同一个端口；
   - 当交换机发现一个包要发回到原端口时，就会直接丢弃这个包。
     - 首先，计算机 A 发送的包到达集线器后会被集线器转发到所有端口上，也就是会到达交换机和计算机 B ；
     - 交换机转发这个包之后，这个包会原路返回集线器；
     - 然后，集线器又把包转发到所有端口，于是这个包又到达了计算机 A 和计算机 B ；
     - 所以计算机 B 就会收到两个相同的包，这会导致无法正常通信。
2. 地址表中找不到指定的MAC 地址。
   - 这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。
   - 这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。
   - 至于这种特殊情况的原因可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。

有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”  
其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入地址表，下次也就不需要把包发到所有端口了。  
局域网中每秒可以传输上千个包，多出一两个包并无大碍。  

此外，如果接收方 MAC 地址是一个广播地址，那么交换机会将包发送到除源端口之外的所有端口。  
  - 广播地址（broadcast address）是一种特殊的地址，将广播地址设为接收方地址时，包会发送到网络中所有的设备。
    - MAC 地址中的 FF:FF:FF:FF:FF:FF 和 IP 地址中的 255.255.255.255 都是广播地址。

### 全双工模式可以同时进行发送和接收

全双工模式是交换机特有的工作模式，它可以同时进行发送和接收操作，集线器不具备这样的特性。  
使用集线器时，如果多台计算机同时发送信号，信号就会在集线器内部混杂在一起，进而无法使用，这种现象称为碰撞，是以太网的一个重要特征。不过，只要不用集线器，就不会发生碰撞。   
  
而使用双绞线时，发送和接收的信号线是各自独立的，因此在双绞线中信号不会发生碰撞。  
网线连接的另一端，即交换机端口和网卡的 PHY（MAU）模块以及 MAC 模块，其内部发送和接收电路也是各自独立的，信号也不会发生碰撞。  
因此，只要不用集线器，就可以避免信号碰撞了。如果不存在碰撞，也就不需要半双工模式中的碰撞处理机制了。  
也就是说，发送和接收可以同时进行。  

然而，以太网规范中规定了在网络中有信号时要等该信号结束后再发送信号，因此发送和接收还是无法同时进行。  
于是，人们对以太网规范进行了修订，增加了一个无论网络中有没有信号都可以发送信号的工作模式，同时规定在这一工作模式下停用碰撞检测。  
这种工作模式就是全双工模式。  
  - 在全双工模式下，无需等待其他信号结束就可以发送信号，因此它比半双工模式速度要快。
  - 由于双方可以同时发送数据，所以可同时传输的数据量也更大，性能也就更高。

### 自动协商：确定最优的传输速率

随着全双工模式的出现，如何在全双工和半双工模式之间进行切换的问题也产生了。  
在全双工模式刚刚出现的时候，还需要手动进行切换，但这样实在太麻烦，于是后来出现了自动切换工作模式的功能。  
  - 这一功能可以由相互连接的双方探测对方是否支持全双工模式，并自动切换成相应的工作模式；
  - 此外，除了能自动切换工作模式之外，还能探测对方的传输速率并进行自动切换；
  - 这种自动切换的功能称为自动协商。

在以太网中，当没有数据在传输时，网络中会填充一种被称为连接脉冲的脉冲信号。
  - 在没有数据信号时就填充连接脉冲，这使得网络中一直都有一定的信号流过，从而能够检测对方是否在正常工作，或者说网线有没有正常连接；
  - 以太网设备的网线接口周围有一个绿色的LED 指示灯，它表示是否检测到正常的脉冲信号。
    - 如果绿灯亮，说明PHY（MAU）模块以及网线连接正常。

在双绞线以太网规范最初制定的时候，只规定了按一定间隔发送脉冲信号，这种信号只能用来确认网络是否正常。  
后来，人们又设计出了的具有特定排列的脉冲信号，通过这种信号可以将自身的状态告知对方。  
自动协商功能就利用了这样的脉冲信号，即通过这种信号将自己能够支持的工作模式和传输速率相互告知对方，并从中选择一个最优的组合。  
  - 支持的模式是按照优先级排序的，双方会根据都支持的模式从优先级高的开始选。  

### 交换机可同时执行多个转发操作

交换机只将包转发到具有特定 MAC 地址的设备连接的端口，其他端口都是空闲的，这些端口可以传输其他的包，因此交换机可以同时转发多个包。  
相对地，集线器会将输入的信号广播到所有的端口，如果同时输入多个信号就会发生碰撞，无法同时传输多路信号，因此从设备整体的转发能力来看，交换机要高于集线器。  

## 路由器的包转发操作

### 路由器的基本知识

网络包经过集线器和交换机之后，现在到达了路由器，并在此被转发到下一个路由器。  
这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。不过在具体的操作过程上，路由器和交换机是有区别的。  
  - 因为路由器是基于IP 设计的，而交换机是基于以太网设计的。

#### 路由器的内部结构

路由器包括转发模块和端口模块两部分。  
  - 转发模块负责判断包的转发目的地；
    - 转发模块也叫包转发模块，根据路由器中的记录判断包的转发目标。
  - 端口模块负责包的收发操作。
    - 不同的路由器端口模块有所不同，例如支持 ADSL 的路由器，支持 FTTH 的路由器，支持专线等线路的路由器等。
    - 以太网端口与计算机里的网卡差不多，也是由 RJ-45 接口、 MAU(PHY)、 MAC 和内存组成的。其中接口与 MAU(PHY) 之间一般采用和网卡一样的 MDI 方式进行连接。
    
通过更换网卡，计算机不仅可以支持以太网，也可以支持无线局域网，路由器也是一样。  
如果路由器的端口模块安装了支持无线局域网的硬件，就可以支持无线局域网了。  
  - 此外，计算机的网卡除了以太网和无线局域网之外很少见到支持其他通信技术的品种；
  - 而路由器的端口模块则支持除局域网之外的多种通信技术，如 ADSL、FTTH ，以及各种宽带专线等，只要端口模块安装了支持这些技术的硬件即可。

#### 路由器的工作原理

1. 路由器在转发包时，首先会通过端口将发过来的包接收进来，这一步的工作过程取决于端口对应的通信技术；
   - 对于以太网端口来说，就是按照以太网规范进行工作；
   - 对于无线局域网端口则是按照无线局域网的规范工作；
   - 总之就是委托端口的硬件将包接收进来。
2. 接下来，转发模块会根据接收到的包的 IP 头部中记录的接收方 IP 地址，在路由表中进行查询，以此判断转发目标；
3. 然后，转发模块将包转移到转发目标对应的端口，端口再按照硬件的规则将包发送出去。
   - 也就是转发模块委托端口模块将包发送出去的意思。

##### 关于路由器工作原理的一些补充

端口模块会根据相应通信技术的规范来执行包收发的操作，这意味着端口模块是以实际的发送方或者接收方的身份来收发网络包的。  
  - 以以太网端口为例，路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；
  - 端口还具有IP 地址，从这个意义上来说，它和计算机的网卡是一样的；
  - 当转发包时，首先路由器端口会接收发给自己的以太网包，然后查询转发目标，再由相应的端口作为发送方将以太网包发送出去。
    - 这一点和交换机是不同的，交换机只是将进来的包转发出去而已，它自己并不会成为发送方或者接收方。

### 路由表中的信息

在“查表判断转发目标”这一点上，路由器和交换机的大体思路是类似的，不过具体的工作过程有所不同。  
  - 交换机是通过 MAC 头部中的接收方 MAC 地址来判断转发目标的；
  - 路由器则是根据 IP 头部中的 IP 地址来判断的；
  - 由于使用的地址不同，记录转发目标的表的内容也会不同。

路由器中的表叫作路由表，结构如下： 
 
|目标地址 ( Destination) |子网掩码 ( Netmask ) | 网关 ( Gateway ) | 接口 ( Interface ) | 跃点数 ( Metric ) |
|---|---|---|---|---|
| 10.10.1.0 | 255.255.255.0 | - | e2 | 1 |
|...|...|...|...|...|

最左侧的目标地址列记录的是接收方的信息。  
  - 实际上这里的 IP 地址只包含表示子网的网络号部分的比特值，而表示主机号部分的比特值全部为 0 ;
  - 路由器会将接收到的网络包的接收方IP地址与路由表中的目标地址进行比较，并找到相应的记录。
    - 交换机在地址表中只匹配完全一致的记录;
    - 而路由器则会忽略主机号部分，只匹配网络号部分;
    - 打个比方，路由器在转发包的时候只看接收方地址属于哪个区，×× 区发往这一边，×× 区发往那一边。
在匹配地址的过程中，路由器需要知道网络号的比特数，因此路由表中还有一列子网掩码，通过子网掩码就可以判断出网络号的比特数。  

接下来在子网掩码的右边还有网关和接口两列，它们表示网络包的转发目标。  
根据目标地址和子网掩码匹配到某条记录后，路由器就会将网络包交给接口列中指定的网络接口（即端口），并转发到网关列中指定的 IP 地址。  

最后一列是跃点计数，它表示距离目标IP 地址的距离是远还是近。这个数字越小，表示距离目的地越近；数字越大，表示距离目的地越远。  

#### 路由表记录维护方式

路由表记录维护的方式和交换机也有所不同。  
  - 交换机中对MAC 地址表的维护是包转发操作中的一个步骤；
  - 路由器中对路由表的维护是与包转发操作相互独立的。
    - 也就是说，在转发包的过程中不需要对路由表的内容进行维护。

对路由表进行维护的方法有几种，大体上可分为以下两类：  
1. 由人手动维护路由记录；
2. 根据路由协议机制，通过路由器之间的信息交换由路由器自行维护路由表的记录。
   - 路由协议有很多种，例如 RIP、OSPC、BGP 等都属于路由协议。

#### 路由器工作时的一些例外

路由聚合会将几个子网合并成一个子网，并在路由表中只产生一条记录。  
  - 这会导致地址本身的子网掩码和路由表中的子网掩码是不一致的。  

比如：  
我们现在有 3 个子网，分别为 10.10.1.0/24、10.10.2.0/24、10.10.3.0/24 ，路由器 B 需要将包发往这 3 个子网；  
在这种情况下，路由器 B 的路由表中原本应该有对应这 3 个子网的 3 条记录；  
但在这个例子中，无论发往任何一个子网，都能通过路由器 A 来进行转发；  
因此我们可以在路由表中将这 3 个子网合并成 10.10.0.0/16，这样也可以正确地进行转发，但我们减少了路由表中的记录数量，这就是路由聚合；  
经过路由聚合，多个子网会被合并成一个子网，子网掩码会发生变化，同时，目标地址列也会改成聚合后的地址。  

还有另外一些情况，如将一个子网进行细分并注册在路由表中，然后拆分成多条记录。  

从结果上看，路由表的子网掩码列只是用来在匹配目标地址时告诉路由器应该匹配多少个比特。  
而且，目标地址中的地址和实际子网的网络号可能并不完全相同，但即便如此，路由器依然可以正常工作。  

此外，通过上述方法，我们也可以将某台具体计算机的地址写入路由表中，这时的子网掩码为 255.255.255.255，也就是说地址中的全部 32 个比特都为 1 。  
这样一来，主机号部分比特全部为 0 可以表示一个子网，主机号部分比特不全部为 0 可以表示某一台计算机，两种情况可以用相同的规则来处理。  
（这段没看懂）  

### 路由器的包接收操作
 
路由器的端口有各种不同的类型，这里我们只介绍以太网端口是如何接收包的。  
以太网端口的结构和计算机的网卡基本相同，接收包并存放到缓冲区中的过程也和网卡几乎没有区别。  

首先，信号到达网线接口部分，其中的 PHY（MAU）模块和 MAC 模块将信号转换为数字信息，然后通过包末尾的 FCS 进行错误校验；  
如果没问题则检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包。  
  - 如果是就放到接收缓冲区中，否则就丢弃这个包；
  - 如果包的接收方 MAC 地址不是自己，说明这个包是发给其他设备的，如果接收这个包就违反了以太网的规则。

### 查询路由表确定输出端口

完成包接收操作之后，路由器就会丢弃包开头的 MAC 头部。  
MAC 头部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。  
因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。  

接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。  
转发操作分为几个阶段:  
首先是查询路由表判断转发目标。关于具体的工作流程，还是来看一个实际的例子：  

假设地址为 10.10.1.101 的计算机要向地址为 192.168.1.10 的服务器发送一个包，这个包先到达路由器
判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。
  - 这个匹配并不是匹配全部 32 个比特，而是根据子网掩码列中的值判断网络号的比特数，并匹配相应数量的比特。
    - 网络包的接收方 IP 地址和路由表中的目标地址左起 24 个比特的内容都是 192.168.1，因此两者是匹配的，该行记录就是候选转发目标之一；
    - 按照这样的规则，我们可能会匹配到多条候选记录；
      - 其中，路由器首先寻找网络号比特数最长的一条记录（这一规则被称为“最长匹配”原则）；
        - 网络号比特数越长，说明主机号比特数越短，也就意味着该子网内可分配的主机数量越少，即子网中可能存在的主机数量越少，这一规则的目的是尽量缩小范围，所以根据这条记录判断的转发目标就会更加准确。
      - 按照最长匹配原则筛选后，如果只剩一条候选记录，则按照这条记录的内容进行转发。
    - 然而，有时候路由表中会存在网络号长度相同的多条记录；
      - 例如考虑到路由器或网线的故障而设置的备用路由就属于这种情况；
      - 这时，需要根据跃点计数的值来进行判断。跃点计数越小说明该路由越近，因此应选择跃点计数较小的记录。
    - 如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过 ICMP 消息告知发送方。
      - 这里的处理方式和交换机不同，原因在于网络规模的大小。
        - 交换机连接的网络最多也就是几千台设备的规模，这个规模并不大；
          - 这里几千台设备的规模指的是以太网的规模。交换机本身的设计并不需要按照这个规模，但由于它是基于以太网进行工作的，因此其规模和以太网的规模是一致的；
          - 如果只有几千台设备，遇到不知道应该转发到哪里的包，交换机可以将包发送到所有的端口上，虽然这个方法很简单粗暴，但不会引发什么问题。
        - 然而，路由器工作的网络环境就是互联网，它的规模是远远大于以太网的，全世界所有的设备都连接在互联网上，而且规模还在持续扩大。
          - 在如此庞大的网络中，如果将不知道应该转发到哪里的包发送到整个网络上，那就会产生大量的网络包，造成网络拥塞；
          - 因此，路由器遇到不知道该转发到哪里的包，就会直接丢弃。

### 找不到匹配路由时选择默认路由

如果是公司或者家庭网络，将所有的转发目标都配置在路由器中也没什么问题；  
但是在互联网中的转发目标可能超过 20 万个，如果要全部配置在路由表中实在是不太现实。  

但路由器有一种特殊的机制，相当于把所有目标都配置好了：  
在路由表的最后一行，其记录的子网掩码为 0.0.0.0 ；
关键就在这里，子网掩码 0.0.0.0 的意思是网络包接收方 IP 地址和路由表目标地址的匹配中需要匹配的比特数为 0 ；  
换句话说，就是根本不需要匹配。只要将子网掩码设置为 0.0.0.0 ，那么无论任何地址都能匹配到这一条记录，这样就不会发生不知道要转发到哪里的问题了。  

只要在这一条记录的网关列中填写接入互联网的路由器地址，当匹配不到其他路由时，网络包就会被转发到互联网接入路由器。  
因此这条记录被称为默认路由，这一行配置的网关地址被称为默认网关。  
  - 由于匹配的比特数越长优先级越高（最长匹配原则），因此子网掩码为 0.0.0.0 的记录优先级是最低的，只有当找不到其他匹配的记录时，才会选择这条记录。
这样一来，无论目标地址是表示一个子网还是表示某台设备，都可以用相同的方法查找出转发目标，而且也避免了不知道转发到哪里的问题。  

> 在计算机的 TCP/IP 设置窗口中也有一个填写默认网关的框，意思是一样的。计算机上也有一张和路由器一样的路由表，其中默认网关的地址就是我们在设置窗口中填写的地址。

### 包的有效期

从路由表中查找到转发目标之后，网络包就会被转交给输出端口，并最终发送出去，但在此之前，路由器还有一些工作要完成。  

第一个工作是更新 IP 头部中的 TTL（Time to Live，生存时间）字段。  
  - TTL 字段表示包的有效期，包每经过一个路由器的转发，这个值就会减 1 ，当这个值变成 0 时，就表示超过了有效期，这个包就会被丢弃；
  - 这个机制是为了防止包在一个地方陷入死循环。
    - 如果路由表中的转发目标都配置正确，应该不会出现这样的情况；
    - 但如果其中的信息有问题，或者由于设备故障等原因切换到备用路由时导致暂时性的路由混乱，就会出现这样的情况；
    - 发送方在发送包时会将 TTL 设为 64 或 128，也就是说包经过这么多路由器后就会“寿终正寝”。
      - 现在的互联网即便访问一台位于地球另一侧的服务器，最多也只需要经过几十个路由器，因此只要包被正确转发，就可以在过期之前到达目的地。

### 通过分片功能拆分大网络包

路由器的端口并不只有以太网一种，也可以支持其他局域网或专线通信技术。  

有时会出现转发的包长度超过了输出端口能传输的最大长度的情况，这种情况下就无法直接发送这个包了。  
  - 不同的线路和局域网类型各自能传输的最大包长度也不同，因此输出端口的最大包长度可能会小于输入端口；
  - 即便两个端口的最大包长度相同，也可能会因为添加了一些头部数据而导致包的实际长度发生变化，ADSL、FTTH 等宽带接入技术中使用的 PPPoE 协议就属于这种情况。  

遇到这种情况，可以使用 IP 协议中定义的分片功能对包进行拆分，缩短每个包的长度。  
  - 需要注意的是，这里说的分片和之前第二章介绍的 TCP 对数据进行拆分的机制是不同的。
    - TCP 拆分数据的操作是在将数据装到包里之前进行的，换句话说，拆分好的一个数据块正好装进一个包里；
    - 从 IP 分片的角度来看，这样一个包其实是一个未拆分的整体，也就是说，这里的分片是对一个完整的包再进行拆分的过程。

分片操作的过程：  
1. 首先，我们需要知道输出端口的 MTU，看看这个包能不能不分片直接发送；
   - 最大包长度是由端口类型决定的，用这个最大长度减掉头部的长度就是MTU，将MTU 与要转发的包长度进行比较；
     - 如果输出端口的 MTU 足够大，那么就可以不分片直接发送；
     - 如果输出端口的 MTU 太小，那么就需要将包按照这个 MTU 进行分片。
   - 但在此之前还需要看一下 IP 头部中的标志字段，确认是否可以分片。
     - 一般来说都是可以分片的，但下面两种情况不能分片：
       - 发送方应用程序等设置了不允许分片；
       - 这个包已经是经过分片后的包。
2. 如果查询标志字段发现不能分片，那么就只能丢弃这个包，并通过 ICMP 消息通知发送方。否则，就可以按照输出端口MTU 对数据进行依次拆分了。
   - 在分片中，TCP 头部及其后面的部分都是可分片的数据，尽管 TCP 头部不属于用户数据，但从 IP 来看也是 TCP 请求传输的数据的一部分。
   - 数据被拆分后，每一份数据前面会加上 IP 头部，其大部分内容都和原本的 IP 头部一模一样，但其中有部分字段需要更新，这些字段用于记录分片相关的信息。

（不太明白第一步那里说的 MTU 和转发的包进行比较，这里的包指的是加了头部的（TCP头部+数据），还是仅仅值（TCP头部+数据））  

### 路由器的发送操作和计算机相同

到这里，发送前的准备工作就完成了，接下来就会进入包的发送操作。  

> 实际上还有一项工作。IP 头部中有一个用于错误检验的字段“校验和”。  
  在路由器更新 TTL 和分片的过程中，IP 头部的内容发生了改变，因此必须重新计算校验和。  
  这里之所以没有详细讲解这个过程，是因为和以太网以及通信线路本身的错误校验机制相比，IP 校验和的可靠性很低，因此大多数路由器都不去校验这个值，就当它不存在一样。  

发送操作取决于输出端口的类型：  
如果是以太网端口，则按照以太网的规则将包转换为电信号发送出去；  
如果是 ADSL 则按照 ADSL 的规则来转换，以此类推。  
在家庭网络中，路由器后面一般连接 ADSL 等线路接入互联网，因此路由器会根据接入网的规则来发送包。  

假设路由器位于公司等局域网的内部，即输出端口也是以太网，看看这种情况是如何操作的：  

以太网的包发送操作是根据以太网规则来进行的，即便设备种类不同，规则也是相同的。  
也就是说，其基本过程和协议栈中的IP 模块发送包的过程是相同的，即在包前面加上MAC 头部，设置其中的一些字段，然后将完成的包转换成电信号并发送出去。  

首先，为了判断 MAC 头部中的 MAC 地址应该填写什么值，我们需要根据路由表的网关列判断对方的地址；  
  - 如果网关是一个 IP 地址，则这个 IP 地址就是我们要转发到的目标地址；
  - 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址。
    - 之前讲过网关的 IP 地址和接口的 IP 地址相同时，表示 IP 头部中的接收方 IP 地址就是我们要转发的直接目标，但这段内容是针对Windows计算机的；
    - 路由器和 Windows 不一样，当包可以直接发送到最终接收方时，一般网关列是留空的。
知道对方的 IP 地址之后，接下来需要通过 ARP 根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址；  
  - 路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。
接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 0080（十六进制）；  
  - 端口的 MAC 地址一般也是在硬件生产过程中写入 ROM 中的。
网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的；  
  - 例如，当以太网工作在半双工模式时，需要先确认线路中没有其他信号后才能发送，如果检测到碰撞，则需要等待一段时间后重发；
  - 如果以太网工作在全双工模式，则不需要确认线路中的信号，可以直接发送。
如果输出端口为以太网，则发送出去的网络包会通过交换机到达下一个路由器；  
  - 由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。
接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。  

### 路由器与交换机的关系

要理解两者之间的关系，关键点在于计算机在发送网络包时，或者是路由器在转发网络包时，都需要在前面加上MAC 头部。  
之前的讲解都是说在开头加上 MAC 头部，，准确的说法应该是将 IP 包装进以太网包的数据部分中。  
也就是说，给包加上 MAC 头部并发送，从本质上说是将 IP 包装进以太网包的数据部分中，委托以太网去传输这些数据。  

IP 协议本身没有传输包的功能，因此包的实际传输要委托以太网来进行。  
路由器是基于IP 设计的，而交换机是基于以太网设计的，因此IP 与以太网的关系也就是路由器与交换机的关系。  
换句话说，路由器将包的传输工作委托给交换机来进行。  

从包的转发目标也可以看出路由器和交换机之间的委托关系。IP 并不是委托以太网将包传输到最终目的地，而是传输到下一个路由器。  
在创建 MAC 头部时，也是从 IP 的路由表中查找出下一个路由器的 IP 地址，并通过 ARP 查询出 MAC 地址，  
然后将 MAC 地址写入 MAC 头部中的，这表示 IP 对以太网的委托只是将包传输到下一个路由器就行了。  
当包到达下一个路由器后，下一个路由器又会重新委托以太网将包传输到再下一个路由器。  
随着这一过程反复执行，包就会最终到达IP 的目的地，也就是通信的对象。  

到这里已经梳理清除路由器与交换机之间的关系。简单来说，IP（路由器）负责将包发送给通信对象这一整体过程，而其中将包传输到下一个路由器的过程则是由以太网（交换机）来负责的。  

网络并非以太网一种，其他通信技术比如无线局域网以及接入互联网的通信线路，它们和 IP 之间的关系与 IP 与 以太网的关系是一样的：  
IP 本身不负责包的传输，而是委托各种通信技术将包传输到下一个路由器。  
（这样的设计是有重要意义的，即可以根据需要灵活运用各种通信技术，这也是 IP 的最大特点。正是有了这一特点，我们才能够构建出互联网这一规模巨大的网络。）  

## 路由器的附加功能

上面介绍完了路由器的基本功能，它还有一些附加功能：地址转换和包过滤。  

### 通过地址转换有效利用 IP 地址

#### 地址转换功能出现的背景

所谓地址，就是用来识别每一台设备的标志，因此每台设备都应该有一个唯一不重复的地址。  
网络也是一样，本来互联网中所有的设备都应该有自己的固定地址，而且最早也确实是这样做的。  
- 比如，公司内网需要接入互联网的时候，应该向地址管理机构申请IP 地址，并将它们分配给公司里的每台设备；
- 换句话说，那个时候没有内网和外网的区别，所有客户端都是直接连接到互联网的。

尽管互联网原本是这样设计的，但进入 20 世纪 90 年代之后，互联网逐步向公众普及，接入互联网的设备数量也快速增长，如此一来，情况就发生了变化。  
如果还用原来的方法接入，过不了多久，可分配的地址就用光了。  
如果不能保证每台设备有唯一不重复的地址，就会从根本上影响网络包的传输，这是一个非常严重的问题。  
如果任由这样发展下去，不久的将来，一旦固定地址用光，新的设备就无法接入了，互联网也就无法继续发展了。  

解决这个问题的关键在于固定地址的分配方式。  
举个例子，假如有 A、B 两家公司，它们的内网是完全独立的。  
这种情况下，两家公司的内网之间不会有网络包流动，即使 A 公司的某台服务器和 B 公司的某台客户端具有相同的IP 地址也没关系，因为它们之间不会进行通信。  
只要在每家公司自己的范围内，能够明确判断网络包的目的地就可以了，是否和其他公司的内网地址重复无关紧要，只要每个公司的网络是相互独立的，就不会出现问题。  

解决地址不足的问题，利用的就是这样的性质，即公司内部设备的地址不一定要和其他公司不重复。  
这样一来，公司内部设备就不需要分配固定地址了，从而大幅节省了 IP 地址。  

当然，就算是公司内网，也不是可以随便分配地址的，因此需要设置一定的规则，规定某些地址是用于内网的，这些地址叫作私有地址，而原来的固定地址则叫作公有地址。  
私有地址的规则其实并不复杂，在内网中可用作私有地址的范围仅限以下这些。  

10.0.0.0 ～ 10.255.255.255
172.16.0.0 ～ 172.31.255.255
192.168.0.0 ～ 192.168.255.255

在制定私有地址规则时，这些地址属于公有地址中还没有分配的范围。  
这些地址不做不作统一管理，不需要申请，任何人都可以自由使用。  
当然，如果在公司内部地址有重复就无法传输网络包了，因此必须避免在内网中出现重复的地址。  

尽管这样的确能节省一部分地址，但仅凭这一点还无法完全解决问题。  
公司内网并不是完全独立的，而是需要通过互联网和其他很多公司相连接，所以当内网和互联网之间需要传输包的时候，问题就出现了；  
因为如果很多地方都出现相同的地址，包就无法正确传输了。  

于是，当公司内网和互联网连接的时候，需要将公司内网分成两个部分，一部分是对互联网开放的服务器，另一部分是公司内部设备。  
其中对互联网开放的部分分配公有地址，可以和互联网直接进行通信，这一部分和之前介绍的内容是一样的。  
相对地，内网部分则分配私有地址，内网中的设备不能和互联网直接收发网络包，而是通过一种特别的机制进行连接，这个机制就叫地址转换。  

### 地址转换的基本原理

地址转换的基本原理是在转发网络包时对 IP 头部中的 IP 地址和端口号进行改写。  
- 这里的端口号指的是 TCP 和 UDP 的端口号，不是路由器和集线器连接网线的那个端口。

假设现在要访问 Web 服务器，看看包是如何传输的：  
1. 首先，TCP 连接操作的第一个包被转发到互联网时，会将发送方 IP 地址从私有地址改写成公有地址；
   - 这里使用的公有地址是地址转换设备的互联网接入端口的地址。与此同时，端口号也需要进行改写，地址转换设备会随机选择一个空闲的端口；
   - 然后，改写前的私有地址和端口号，以及改写后的公有地址和端口号，会作为一组相对应的记录保存在地址转换设备内部的一张表中；
   - 具备地址转换功能的设备不仅有路由器，有些防火墙也有地址转换功能，它的工作方式和路由器是相同的，因此这里我们虽然用了地址转换设备这个词，但在这里的上下文中指的就是路由器。
2. 改写发送方 IP 地址和端口号之后，包就被发往互联网，最终到达服务器，然后服务器会返回一个包。
   - 服务器返回的包的接收包是原始包的发送方，因此返回的包的接收方就是改写后的公有地址和端口号。
     - 这个公有地址其实是地址转换设备的地址，因此这个返回包就会到达地址转换设备。
3. 接下来，地址转换设备会从地址对应表中通过公有地址和端口号找到相对应的私有地址和端口号，并改写接收方信息，然后将包发给公司内网，这样包就能够到达原始的发送方了；
4. 在后面的包收发过程中，地址转换设备需要根据对应表查找私有地址和公有地址的对应关系，再改写地址和端口号之后进行转发；
5. 当数据收发结束，进入断开阶段，访问互联网的操作全部完成后，对应表中的记录就会被删除。

通过这样的机制，具有私有地址的设备就也可以访问互联网了。从互联网一端来看，实际的通信对象是地址转换设备（这里指的是路由器）。  

上面是以公司内网为例来进行介绍的，家庭网络中的工作过程也是完全相同的，只是规模不同而已。  

### 改写端口号的原因

现在我们使用的地址转换机制是同时改写地址和端口号的，但早期的地址转换机制是只改写地址，不改写端口号的。  
用这种方法也可以让公司内网和互联网进行通信，而且这种方法更简单。  
但是，使用这种方法的前提是私有地址和公有地址必须一一对应，也就是说，有多少台设备要上互联网，就需要多少个公有地址。  
当然，访问动作结束后可以删除对应表中的记录，这时同一个公有地址可以分配给其他设备使用，因此只要让公有地址的数量等于同时访问互联网的设备数量就可以了。  
然而公司人数一多，同时访问互联网的人数也会增加。一个几千人的公司里，有几百人同时访问互联网是很正常的，这样就需要几百个公有地址。  

改写端口号正是为了解决这个问题。客户端一方的端口号本来就是从闲端口中随机选择的，因此改写了也不会有问题。端口号是一个 16 比特的数值，总共可以分配出几万个端口；  
  - 16 比特可以表示 65536 个端口号，但并不是所有这些端口都可以用于地址转换。  
因此如果用公有地址加上端口的组合对应一个私有地址，一个公有地址就可以对应几万个私有地址，这种方法提高了公有地址的利用率。  

### 从互联网访问公司内网

对于从公司内网访问互联网的包，即便其发送方私有地址和端口号没有保存在对应表中也是可以正常转发的，  
因为用来改写的公有地址就是地址转换设备自身的地址，而端口号只要随便选一个空闲的端口就可以了，这些都可以由地址转换设备自行判断。  
然而，对于从互联网访问公司内网的包，如果在对应表中没有记录就无法正常转发。  
因为如果对应表中没有记录，就意味着地址转换设备无法判断公有地址与私有地址之间的对应关系。  

换个角度来看，这意味着对于没有在访问互联网的内网设备，是无法从互联网向其发送网络包的。  
而且即便是正在访问的设备，也只能向和互联网通信中使用的那个端口发送网络包，无法向其他端口发送包。  
也就是说，除非公司主动允许，否则是无法从互联网向公司内网发送网络包的。这种机制具有防止非法入侵的效果。  

不过，有时候我们希望能够从互联网访问公司内网，这需要进行一些设置才能实现。  
之所以无法从互联网访问内网，是因为对应表里没有相应的记录，那么我们只要事先手动添加这样的记录就可以了。  

一般来说，用于外网访问的服务器可以放在地址转换设备的外面并为它分配一个公有地址，  
也可以将服务器的私有地址手动添加到地址转换设备中，这样就可以从互联网访问到这台具有私有地址的服务器了。  
  - 这种配置中，需要将地址转换设备的公有地址添加到DNS 服务器中。

### 路由器的包过滤功能

包过滤也是路由器的一个重要附加功能，包过滤的机制并不复杂。  

包过滤就是在对包进行转发时，根据MAC 头部、IP 头部、TCP 头部的内容，按照事先设置好的规则决定是转发这个包，还是丢弃这个包。  
我们通常说的防火墙设备或软件，大多数都是利用这一机制来防止非法入侵的。  

包过滤的原理非常简单，但要想设置一套恰当的规则来区分非法访问和正常访问，只阻止非法入侵而不影响正常访问，是非常不容易的。  
举个例子，为了防止从互联网非法入侵内网，我们可以将来自互联网的所有包都屏蔽掉，  
但网络包是双向传输的，如果简单地阻止来自互联网的全部包，那么从内网访问互联网的操作也会无法正常进行。  

# 通过接入网进入互联网内部-探索接入网和网络运营商

## 热身问答

1. 第一个采用包机制的网络就是互联网的前身 ARPANET。
   - 互联网通过技术更新一直在不断进化，大家可能会认为它是一种很新的网络，其实并非如此；
   - 互联网实际上是一种具有将近 40 年历史的“最古老的”包网络。
   
2. ADSL 方式中，从家里到电话局的线路费用包含在电话费中，因此可以降低上网费。
   光纤的线路费用包含在上网费中，因此光纤的上网费高，电话费便宜。  
   
3. 电信号和光信号传播的速度大体上相同，之所以电缆不如光纤通信速率高，是因为电信号在提升通信速率的同时，其衰减率也会提高（信号在传播过程中减弱），导致信号无法传到目的地。
   相对地，光信号本来的衰减率就很低，提高通信速率也并不会提高衰减率。此外，光纤还不受电磁噪声的影响，因此光纤能够进行高速通信。  
   
## 探索之旅

### ADSL 接入网的结构和工作方式

家庭和公司的内网是通过接入网连接到网络运营商的。  
接入网有很多类型，这里我们将介绍 ADSL 接入网的知识，重点包括 ADSL 接入网的结构、电话线中传输的信号以及与电话共用的方式。  

### 光纤接入网（FTTH）

我们还会介绍另一种常用的接入网技术——与 ADSL 技术的利用率不相上下的光纤技术，  
重点包括光纤结构、单模和多模的区别之类的光纤性质，以及光纤用作接入网时的工作方式。  

### 接入网中使用的 PPP 和隧道

接入网需要通过用户名和密码验证用户的身份，然后由网络运营商向用户分配公有地址。  
此外，从接入网向网络运营商传输网络包时还使用了隧道技术，这些都是本章的看点。  

### 网络运营商的内部

接入网后面连接着网络运营商的网络，运营商网络也是以路由器为核心组成的，这一点和家庭、公司网络是一样的，包转发的工作原理也没有区别。  
不过，运营商网络也使用了一些和家庭、公司网络不同的技术，比如运营商之间可以自动交换路由信息和更新路由表，这些都是本章的看点。  

### 跨越运营商的网络包

互联网是由多个运营商网络相互连接形成的巨大网络，而多个运营商之间相互连接的部分可以说就是互联网的核心部分，这里也是本章的看点。  

## ADSL 接入网的结构和工作方式

### 互联网的基本结构和家庭、公司网络是相同的

互联网是一个遍布世界的巨大而复杂的系统，但其基本工作方式却出奇地简单。  
和家庭、公司网络一样，互联网也是通过路由器来转发包的，而且路由器的基本结构和工作方式也并没有什么不同。  
因此，我们可以将互联网理解为家庭、公司网络的一个放大版。  

当然，互联网也有一些和家庭、公司网络不同的地方，其中之一就是与转发设备间的距离。  
在家庭、公司网络中，与转发设备之间的距离不过几十米到几百米，在这种情况下，只要延长以太网线就可以到达相邻的转发设备了。  
  - 双绞线的极限距离是 100 米，但光纤的连接距离可以长达几公里。
然而，互联网可不能这么搞，因为你家到最近的电话局至少也有几公里的距离，而从日本连接到美国甚至要跨越太平洋，用以太网线是无法实现这种连接的。  

除了距离之外，路由器在如何控制包的转发目标上也不一样。  
尽管从基本原理来看，互联网也是根据路由表中的记录来判断转发目标的，但路由表记录的维护方式不同。  
互联网中的路由器上有超过 10 万条路由记录，而且这些记录还在不断变化，当出现线路故障时，或者新的公司加入互联网时，都会引发路由的变化。  
人工维护这些路由信息是不现实的，必须实现自动化。公司的路由器也有自动维护路由表的机制，但出于各种原因，互联网中采用的机制和公司有所区别。  

距离的不同和路由的维护方式，就是互联网与家庭、公司网络之间最主要的两个不同点。  

### 连接用户与互联网的接入网

网络包通过交换机和路由器的转发一步一步地接近它的目的地，在通过互联网接入路由器之后，就进入了互联网。  

刚才讲过，路由器的转发操作都是相同的，因此互联网接入路由器的包转发操作也和第 3 章讲过的以太网路由器几乎是一样的。  
简单来说，就是根据包 IP 头部中的接收方 IP 地址在路由表的目标地址中进行匹配，找到相应的路由记录后将包转发到这条路由的目标网关。  
不过，互联网接入路由器发送网络包的操作和以太网路由器有一点不同，互联网接入路由器是按照接入网规则来发送包的。  

所谓接入网，就是指连接互联网与家庭、公司网络的通信线路。  
一般家用的接入网方式包括 ADSL、FTTH、CATV、电话线、ISDN 等，公司则还可能使用专线。  
接入网的线路有很多种类，我们无法探索所有这些线路，因此下面先介绍一个比较有代表性的例子—— ADSL 。  

接入网这个词表示的是通信线路的用法，而并不表示通信线路的结构。  
例如公司里使用的专线，当它用来连接互联网时就叫作接入网，而用来连接总公司和分公司时就不叫接入网。  
此外，接入网这个词也不仅限于互联网，当使用运营商提供的通信服务时，一般都会将用户与运营商之间的线路叫作接入网。  

> ADSL：Asymmetric Digital Subscriber Line，不对称数字用户线。  
  它是一种利用架设在电线杆上的金属电话线来进行高速通信的技术，它的上行方向（用户到互联网）和下行方向（互联网到用户）的通信速率是不对称的。  
  FTTH：Fiber To The Home，光纤到户。指的是将光纤接入家庭的意思。  
  
### ADSL Modem 将包拆分成信元

用户端路由器发出的网络包通过 ADSL Modem 和电话线到达电话局，然后到达 ADSL 的网络运营商（即ISP，互联网服务提供商）。  
- 有些情况下会使用集成了互联网接入路由器和 ADSL Modem 的多功能 ADSL Modem（也叫路由型 ADSL Modem ），其实就是把路由器和 ADSL Modem 装到一个外壳里而已。
- Modem 中文全称为“调制解调器”，因为这个名字比较长，所以正文中统一使用 Modem。

首先，客户端生成的网络包先经过集线器和交换机到达互联网接入路由器，并在此从以太网包中取出 IP 包并判断转发目标，这部分和之前讲的以太网路由器的工作方式是一样的。    

接下来，包发送的操作也很类似。  
如果互联网接入路由器和 ADSL Modem 之间是通过以太网连接的，那么就会按照以太网的规则执行包发送的操作，发送信号本身的过程跟之前是一样的，  
但以太网的头部会有一些差异。这部分的具体情况各运营商会有所不同，而且还需要一些关于 BAS（位于接入网另一端的包转发设备）的知识，因此相关的细节我们在探索 BAS 的时候再具体讲解。  
这里大家先记住，网络包会加上 MAC 头部、PPPoE 头部、PPP 头部总共3 种头部，然后按照以太网规则转换成电信号后被发送出去。  
- BAS：Broadband Access Server，宽带接入服务器。它也是一种路由器。
- PPP：Point-to-Point Protocol，点到点协议。它是电话线、ISDN 等通信线路所使用的一种协议，集成了用户认证、配置下发、数据压缩、加密等各种功能。  

互联网接入路由器将包发送出去之后，包就到达了 ADSL Modem ，然后，ADSL Modem 会把包拆分成很多小格子。  
每一个小格子称为一个信元。  
信元是一个非常小的数据块，开头是有 5 个字节的头部，后面是 48 个字节的数据，用于一种叫作 ATM 的通信技术。  
大家可以将信元理解为一种更小一号的包，原理上跟 TCP/IP 将应用程序的数据拆分成块装进一个个包的过程是一样的。  

将包拆分成信元的原因：  
当初开发 ADSL 技术时，通信业比较看好 ATM 技术，各运营商也在 ATM 相关的设备上投入了很多资金。  
在这样的情况下，如果使用信元来传输数据，就比较容易和其他设备进行整合，可以降低开发投入和设备投入。  
如果不是出于这样的原因，其实并不需要将包拆分成信元，实际上也有一些 ADSL 运营商使用的 ADSL Modem 是不进行数据拆分的。  
- ATM：Asynchronous Transfer Mode，异步传输。它是在以电话线为载体的传统电话技术基础上扩展出来的一种通信方式。  
  它的数据传输是以“信元”为单位来进行的，这和以包为单位传输数据的TCP/IP 很像，但这种方式并不适用于计算机通信。  

在网络包从用户传输到运营商的过程中，会变换几种不同的形态：
|序号|层面|步骤|
|---|---|---|
|1.|客户端|添加 IP 头部；|
|2.|客户端|添加 MAC 头部并发送；|
|3.|互联网接入路由器|接收包；|
|4.|互联网接入路由器|取出 IP 包；|
|5.|互联网接入路由器|添加 PPP、PPPoE、MAC 头部；|
|6.|ADSL Modem|接收包；|
|7.|ADSL Modem|拆分为 ATM 信元；|
|8.|ADSL Modem|转换成电信号并发送；|
|9.|DSLAM（局端多路 Modem）|接收电信号；|
|10.|DSLAM（局端多路 Modem）|还原为 ATM 信元并发送；|
|11.|BAS（宽带接入服务器）|接收 ATM 信元；|
|12.|BAS（宽带接入服务器）|还原为网络包；|
|13.|BAS（宽带接入服务器）|取出 PPP 包；|
|14.|BAS（宽带接入服务器）|添加隧道头部并发送（使用 L2TP 隧道时）；|
|15.|路由器（隧道专用）|接收隧道包；|
|16.|路由器（隧道专用）|取出 IP 包；|
|17.|路由器（隧道专用）|发送到互联网内部（此时包会有一个根据实际情况改变的头部）|

3-8 是用户，9-17 是 ADSL 运营商。  

### ADSL 将信元“调制”成信号

将网络包拆分成信元之后，接下来就要将这些信元转换成信号了。  

之前讲过，以太网采用的是用方波信号表示 0 和 1 的方式，这种方式很简单，但同样是将数字信息转换成模拟信号，ADSL 采用的方法要复杂一些。  
其中有两个原因：  
一个原因是方波信号的波形容易失真，随着距离的延长错误率也会提高；  
另一个原因是方波信号覆盖了从低频到高频的宽广频段，信号频率越高，辐射出来的电磁噪声就越强，因此信号频谱太宽就难以控制噪声。  

因此，ADSL Modem 采用了一种用圆滑波形（正弦波）对信号进行合成来表示 0 和 1 的技术，这种技术称为调制。  
调制有很多方式，ADSL 采用的调制方式是振幅调制（ASK）和相位调制（PSK）相结合的正交振幅调制（QAM）方式，也称为正交调幅。  

振幅调制：  
振幅调制是用信号的强弱，也就是信号振幅的大小来对应 0 和 1 的方式。  
- 在这个例子中，振幅大小只有两个级别，振幅小的信号为 0 ，振幅大的信号为 1 ，这是一种最简单的对应关系。
如果增加振幅变化的级别，就可以对应更多的比特。  
例如，如果将振幅增加到 4 个级别，则振幅从小到大可分别对应 00、01、10 和 11 ，这样就可以表示两个比特了。  
这样做可以将单位时间内传输的数据量加倍，也就能够提高速率。  
以此类推，如果振幅有 8 个级别，就可以表示 3 个比特，16 个级别就可以表示 4 个比特，速率也就越来越高。  
不过，信号会在传输过程中发生衰减，也会受到噪声影响而失真，如果振幅级别太多，接收方对信号的识别就容易出错，因此振幅级别也不能太多。  

相位调制：  
相位调制是一种根据信号的相位来对应 0 和 1 的方式。  
Modem 产生的信号是以一定周期振动的波，振动的起始位置不同，波的形状也就不同。  
如果将波的一个振动周期理解为一个圆，则起始位置就可以用 0 度到 360 度的角度来表示，这个角度就是相位，用角度来对应0 和1 的方式就叫作相位调制。  
例如，从 0 度开始的波为 0 ，从 180 度开始的波为 1 ，这是一种最简单的对应关系。  
和振幅调制一样，相位调制也可以通过将角度划分为更细的级别来增加对应的比特数量，从而提高速率。但是，角度太接近的时候也容易产生误判，因此这样提升速率还是有限度的。  

正交振幅调制：  
ADSL 使用的正交振幅调制就是将前面这两种方式组合起来实现的。  
如果信号的振幅可以表示 1 个比特，相位可以表示 1 个比特，那么加起来就可以表示 2 个比特。  
因此，将两种方式组合起来，正交振幅调制就可以用一个波表示更多的比特，从而提高传输速率。  
正交振幅调制中，通过增加振幅和相位的级别，就可以增加能表示的比特数。  
例如，如果振幅和相位各自都有 4 个级别，那么组合起来就有 16 个级别，也就可以表示 4 个比特的值。  
当然，和单独使用振幅调制或相位调制的情况一样，级别过多就容易发生误判，因此这种方法提升的速率是有限度的。  

### ADSL 通过使用多个波来提高速率

ADSL 的信号不一定要限制在一个频率。  
不同频率的波可以合成，也可以用滤波器从合成的波中分离出某个特定频率的波。  
因此，我们可以使用多个频率合成的波来传输信号，这样一来，能够表示的比特数就可以成倍提高了。  

ADSL 使用间隔为 4.3125 kHz 的上百个不同频率的波进行合成，每个波都采用正交振幅调制，而且，根据噪声等条件的不同，每个波表示的比特数是可变的。  
也就是说，噪声小的频段可以给波分配更多的比特，噪声大的频段则给波分配较少的比特，每个频段表示的比特数加起来，就决定了整体的传输速率。  
  - 一般情况下，一个波可以表示几个比特到几十个比特。
  
ADSL 技术中，上行方向（用户到互联网）和下行方向（互联网到用户）的传输速率是不同的，原因也在这里。  
如果上行使用 26 个频段，下行则可以使用 95 个或者 223 个频段，波的数量不同，导致了上下行速率不同。  
当然，下行使用的频段较高，这些信号容易衰减而且更容易受到噪声的影响，因此这些频段可能只能表示较少的比特数，或者干脆无法传输信号。  
  - 距离越远，频率越高，这种情况也就越显著。
  
噪声和衰减等影响线路质量的因素在每条线路上都不同，而且会随着时间发生变化。  
因此，ADSL 会持续检查线路质量，动态判断使用的频段数量，以及每个频段分配到的比特数。  
具体来说，当 Modem 通电后，会发送测试信号，并根据信号的接收情况判断使用的频段数量和每个频段的比特数，这个过程称为训练（握手），需要几秒到几十秒的时间。  

### 分离器的作用

ADSL Modem 将信元转换为电信号之后，信号会进入一个叫作分离器的设备，然后 ADSL 信号会和电话的语音信号混合起来一起从电话线传输出去。  
在信号从用户端发送出去时，电话和 ADSL 信号只是同时流到一条线路上而已，分离器实际上并没有做什么事。  

ADSL Modem 将信元转换为电信号之后，信号会进入一个叫作分离器的设备，然后 ADSL 信号会和电话的语音信号混合起来一起从电话线传输出去。  
在信号从用户端发送出去时，电话和 ADSL 信号只是同时流到一条线路上而已，分离器实际上并没有做什么事。  

分离器的作用其实在相反的方向，也就是信号从电话线传入的时候。这时，分离器需要负责将电话和 ADSL 的信号进行分离。  
电话线传入的信号是电话的语音信号和 ADSL 信号混合在一起的，如果这个混合信号直接进入电话机，ADSL 信号就会变成噪音，导致电话难以听清。  
为了避免这样的问题，就需要通过分离器将传入的信号分离，以确保 ADSL 信号不会传入电话机。  

具体来说，分离器的功能是将一定频率以上的信号过滤掉，也就是过滤掉了 ADSL 使用的高频信号，这样一来，只有电话信号才会传入电话机，  
但对于另一头的 ADSL Modem，则是传输原本的混合信号给它。  
ADSL Modem 内部已经具备将 ADSL 频率外的信号过滤掉的功能，因此不需要在分离器进行过滤。  

大家可能会认为分离器的功能只是过滤掉高频信号，防止 ADSL 对电话产生干扰，而实际上它还可以防止电话对 ADSL 产生干扰。  
如果没有分离器，拿起电话听筒接通电话的状态，和放下听筒挂断电话的状态下，信号的传输方式是不同的。  

当放下听筒时，电话机的电路和电话线是断开的，当拿起听筒时电话机就和电话线相连，电话机的信号就会传到电话线上，这两种状态的差异会导致噪声等线路状态的改变。  
如果 ADSL 通信过程中拿起话筒导致线路状态改变，就需要重新训练（握手），这就会导致几十秒的通信中断，分离器可以防止发生这样的问题。  

当然，也有一种技术能够快速重新握手，即便没有分离器也不会影响 ADSL 通信，G.992.2 的 ADSL 规格就包含这种技术，  
但 ADSL 信号还是会影响电话，因此 G.992.2 的 ADSL 规格中一般还是需要使用分离器。  

### 从用户到电话局

从分离器出来，就是插电话线的接口，信号从这里出来之后，会通过室内电话线，然后到达大楼的 IDF 和 MDF，外面的电话线在这里和大楼内部的室内电话线相连接。  
- IDF：Intermediate Distribution Frame，中间配线盘；
- MDF：Main Distribution Frame，主配线盘（总配线架）。

如果是独栋住宅，就可以将室外线和室内线直接连起来。  
通过配线盘之后，信号会到达保安器。保安器是为了防止雷电等情况下电话线中产生过大电流的一种保护装置，内部有保险丝。  

接下来，信号会进入电线杆上架设的电话电缆。  
- 电话线是一种直径 0.32～0.9 mm 的金属信号线。

电话电缆在用户住宅附近一般是架设在电线杆上，但中途会沿电线杆侧面的金属管进入地下。  
- 由于电话线必须进入很多住宅和大楼，所以电话局附近就会集结数量庞大的电缆，这么多电缆要通过电线杆引入电话局是非常不现实的，电话局周围得密密麻麻地立满了电线杆，
- 而且电线杆上架设过多的电缆，还会产生防灾方面的问题。
因此，在电话局附近，电话线都是埋在地下的。  
由于电话局附近的地下电缆很多，集中埋设电缆的地方就形成了一条地道，这部分称为电缆隧道。  
通过电缆隧道进入电话局后，电缆会逐根连接到电话局的 MDF 上。  

### 噪声的干扰

电话电缆中的信号也会受到噪声的干扰。虽然电话线和以太网双绞线的结构有所不同，但它们都是用金属信号线传输电信号，本质上是共通的。  
也就是说，电话线也会受到来自外部的噪声和来自内部的噪声（串扰）的干扰，导致信号失真。  
此外，电话线原本的设计并没有考虑到传输 ADSL 这样的高频信号，从这个角度上可以说它比以太网双绞线更容易受到噪声的干扰。  

不过，电话线受到干扰的方式和双绞线有些不同。  
双绞线中只有一路方波信号，信号失真后就无法读取还原成数字信号，于是就会产生错误，但 ADSL 信号受到干扰后并不会立即造成错误。  
ADSL 信号分布在多个频段上，只有和噪声频率相同的信号会受到影响而无法读取，即可用的信号数量减少，结果导致速率下降。  

因此，电话线架设在噪声比较多的地方时，可能就会导致速率下降，比如电车线路旁边。  
电车的受电弓（pantograph）从架空接触网获取电力时会产生电火花释放噪声，ADSL 会因此受到干扰，导致速率下降。  
此外，ADSL 还会受到 AM 电台广播的干扰。  

电缆内部产生的噪声也会形成干扰。  
四芯线内部，或者相邻子单元的附近如果同时存在 ADSL 和 ISDN 信号线，ISDN 发出的噪声就会干扰ADSL。  
ADSL 刚刚开始普及的时候，大家还都比较关注防止 ISDN 干扰的技术，不过现在防止 ISDN 干扰的技术已经形成了，因此在使用 ADSL 时已经基本上没必要在意 ISDN 线路的问题了。  

### 通过 DSLAM 到达 BAS

信号通过电话线到达电话局之后，会经过配线盘、分离器到达 DSLAM ，在这里，电信号会被还原成数字信息——信元。  
- DSLAM：DSL Access Multiplexer，数字用户线接入复用设备。它是一种电话局用的多路 ADSL Modem，可以理解为将多个 ADSL Modem 整合在一个外壳里的设备。
DSLAM 通过读取信号波形，根据振幅和相位判断对应的比特值，将信号还原成数字信息，这一过程和用户端的 ADSL Modem 在接收数据时的过程是一样的。  
因此，如果在电话局里安装一大堆和用户端一样的 ADSL Modem，也可以完成这些工作，只不过安装这么多 Modem 需要占用大量的空间，而且监控起来也非常困难。  
因此，电话局使用了 DSLAM 设备，它是一种将相当于很多个 ADSL Modem 的功能集中在一个外壳里的设备。  

不过，DSLAM 和用户端 ADSL Modem 相比还是有一个不同的地方。  
用户端 ADSL Modem 具备以太网接口，可以与用户端的路由器和计算机交互，收发以太网包；  
而 DSLAM 一般不用以太网接口，而是用 ATM 接口，和后方路由器收发数据时使用的是原始网络包拆分后的 ATM 信元形式。  

信元从 DSLAM 出来之后，会到达一个叫作 BAS 的包转发设备；  
BAS 和 DSLAM 一样，都具有 ATM 接口，可以接收 ATM 信元，还可以将接收到的 ATM 信元还原成原始的包；  
到这里，BAS 的接收工作就完成了，接下来，它会将收到的包前面的 MAC 头部和 PPPoE 头部丢弃，取出 PPP 头部以及后面的数据；  
  - MAC 头部和 PPPoE 头部的作用是将包送达 BAS 的接口，当接口完成接收工作后，它们就完成了使命，可以被丢弃了；
  - 具有以太网接口的路由器在接收到包之后也会丢弃其中的 MAC 头部，道理是一样的。
接下来，BAS 会在包的前面加上隧道专用头部，并发送到隧道的出口；  
  - 一般情况下使用的隧道技术为 L2TP，在这种情况下就会加上 L2TP 头部。
然后，网络包会到达隧道出口的隧道专用路由器，在这里隧道头部会被去掉，IP 包会被取出，并被转发到互联网内部。  

## 光纤接入网（FTTH）

### 光纤的基本知识

FTTH 是一种基于光纤的接入网技术。
FTTH 的关键点在于对光纤的使用，所以我们先来介绍一些光纤的基本知识。
光纤是由一种双层结构的纤维状透明材质（玻璃和塑料）构成的，通过在里面的纤芯中传导光信号来传输数字信息。
ADSL 信号是由多个频段的信号组成的，比较复杂，但光信号却非常简单，亮表示 1 ，暗表示 0 。

不过，数字信息并不能一下子变成光信号，而是需要先将数字信息转换成电信号，然后再将电信号转换成光信号。  
这里的电信号非常简单，1 用高电压表示，0 用低电压表示。  
将这样的电信号输入 LED、激光二极管等光源后，这些光源就会根据信号电压的变化发光，高电压发光亮，低电压发光暗。  
这样的光信号在光纤中传导之后，就可以通过光纤到达接收端。  
接收端有可以感应光线的光敏元件，光敏元件可以根据光的亮度产生不同的电压。  
当光信号照射到上面时，光亮的时候就产生高电压，光暗的时候就产生低电压，这样就将光信号转换成了电信号。  
最后再将电信号转换成数字信息，我们就接收到数据了。  

### 单模与多模

光纤通信的关键技术就是能够传导光信号的光纤。  

光在透明材质中传导似乎听起来很简单，但实际上光的传导方式是非常复杂的，不同材质的光纤其透光率和折射率也不同，纤芯的直径等因素也会影响光的传导。  
其中，纤芯的直径对光的传导影响很大，要理解这一点，我们得先来看看光在光纤中是如何传导的。  

首先，我们来看看光源发出的光是如何进入纤芯的。  
光源在所有方向上都会发光，因此会有各种角度的光线进入纤芯，  
但入射角度太大的光线会在纤芯和包层（纤芯外沿部分）的边界上折射出去，只有入射角较小的光线会被包层全反射，从而在纤芯中前进。  

不过，也不是所有入射角小的光线都会在纤芯中传导。  
光也是一种波，因此光也有相位，当光线在纤芯和包层的边界上反射时，会由于反射角产生相位变化。  
当朝反射面前进的光线和被反射回来的光线交会时，如果两条光线的相位不一致，就会彼此发生干涉抵消，只有那些相位一致的光线才会继续在光纤中传导。  

这个现象和往水面上投一颗石子产生的波纹是一样的。  
水波也有相位，在石子进入水面的瞬间，波纹中心会产生各种相位的波。  
不过，相位不同的波会相互干涉，相位不同的波在干涉后会变弱、消失，最后就只剩下相位相同的波向周围扩散开来。  
石子投入水面后扩散出来的波纹会形成同心圆状，一般大家对这样的现象已经习以为常，实际上只有相位相同的波才会扩散出来被我们看到。  
如果周围没有障碍物，水面上的波纹会一直呈同心圆状扩散出去，但如果遇到两侧的墙壁，波纹就会被反射回来。  
这时，向墙壁前进的波和从墙壁反射回来的波就会相互叠加，其中相位相同的波相互加强，相位不同的波相互抵消。  

光纤中的情况也是一样的，只不过和水波不同的是，光在被纤芯和包层的边界反射时，相位会发生变化。  
这个变化的量随光在反射面的反射角度不同而不同，大多数角度下，都会因为相位不同而被干涉抵消。  
不过，有几个特定的角度下，向反射面前进的光和反射回来的光的相位是一致的，只有以这些角度反射的光才能继续向前传导。  
进入光纤的光线有各种角度，但其中，只有少数按照特定角度入射以保持相位一致的光线才会继续传导。  

这个角度非常关键，纤芯的直径也是根据这个角度来确定的，而且纤芯的直径大小会极大地改变光纤的性质。  
根据纤芯直径，光纤可以划分成几种类型，大体上包括较细的单模光纤（8～10 μm）和较粗的多模光纤（50 μm 或62.5 μm）。  
- 单模光纤的纤芯很细，只有入射角很小的光线才能进入，因此在能够保持相位一致的角度中，只有角度最小的光线能进入光纤；
  - 反过来可以说，单模光纤的纤芯直径就是按照只允许相位一致的最小角度的光进入而设计的。
- 多模光纤的纤芯比较粗，入射角比较大的光也可以进入；
  - 这样一来，在相位一致的角度中，不仅角度最小的可以在光纤中传导，其他角度更大一些的也可以，也就是说，可以有多条光线在纤芯中同时传导。
换句话说，单模和多模实际上表示相位一致的角度有一个还是多个。  

单模光纤和多模光纤在光的传导方式上有所不同，这决定了它们的特性也有所不同。  
多模光纤中可以传导多条光线，这意味着能通过的光线较多，对光源和光敏元件的性能要求也就较低，从而可以降低光源和光敏元件的价格。  
相对地，单模光纤的纤芯中只能传导一条光线，能通过的光线较少，相应地对于光源和光敏元件的性能要求就较高，但信号的失真会比较小。  

信号失真与光在纤芯传导时反射的次数相关。  
多模光纤中，多条反射角不同的光线同时传导，其中反射角越大的光线反射次数越多，走过的距离也就越长；相对地，反射角越小的光线走过的距离越短。  
光通过的距离会影响其到达接收端的时间，也就是说，通过的距离越长，到达接收端的时间越长。  
结果，多条光线到达的时间不同，信号的宽度就会被拉伸，这就造成了失真。  
因此，光纤越长，失真越大，当超过允许范围时，通信就会出错。  
相对地，单模光纤则不会出现这样的问题。  
因为在纤芯传导的光线只有一条，不会因为行进距离的差异产生时间差，所以即便光纤很长，也不会产生严重的失真。  

光纤的最大长度也是由上述性质决定的。  
单模光纤的失真小，可以比多模光纤更长，因此多模光纤主要用于一座建筑物里面的连接，单模光纤则用于距离较远的建筑物之间的连接。  
FTTH 属于后者，因此主要使用单模光纤。  

### 通过光纤分路来降低成本

用光纤来代替 ADSL 将用户端接入路由器和运营商的 BAS 连接起来的接入方式就是 FTTH ，从形态上可大致分为两种。
一种是用一根光纤直接从用户端连接到最近的电话局；
另一种光纤的接入方式是在用户附近的电线杆上安装一个名为分光器的设备，通过这个设备让光纤分路，同时连接多个用户。

在第一种类型的 FTTH 中，用户和电话局之间通过光纤直接连接，网络包的传输方式如下：  
1. 首先，用户端的光纤收发器将以太网的电信号转换成光信号。
   - 这一步只进行电信号到光信号的转换，而不会像 ADSL 一样还需要将包拆分成信元，大家可以认为是将以太网包原原本本地转换成了光信号；
   - 光纤收发器将以太网的电信号转换成光信号的设备，也叫“终端盒”。
2. 接下来，光信号通过连接到光纤收发器的光纤直接到达 BAS 前面的多路光纤收发器；
3. 然后，多路光纤收发器将光信号转换成电信号，BAS 的端口接收之后，将包转发到互联网内部。
4. 把网络包发送到互联网之后，服务器会收到请求并返回响应。
   - 响应包的光信号也是沿着同一条光纤传输到用户端的；
   - 这里，前往互联网的上行光信号和前往用户的下行光信号在光纤中混合在一起，信号会变得无法识别，因此我们需要对它们进行区分，办法是上行和下行信号采用不同波长的光；
   - 波长不同的光混合后可通过棱镜原理进行分离，因此光纤中的上行和下行信号即便混合起来也可以识别；
   - 像这样在一条光纤中使用不同的波长传输多个光信号的方式叫作波分复用。

在第二种类型的 FTTH 中，用户端不使用光纤收发器，而是使用一个叫作 ONU 的设备；  
  - ONU：Optical Network Unit，光网络单元。它和光纤收发器一样，可以将电信号转换成光信号，除此之外还具有和电话局的 OLT 相互配合避免信号碰撞的功能。
    - 这个设备有时也被叫作终端盒，因此终端盒这个词本身是对光纤收发器和ONU 等光纤终端设备的统称。
它将以太网的电信号转换成光信号之后，会到达 BAS 前面的一个叫作 OLT 的设备。  
  - OLT：Optical Line Terminal，光线路终端。
  
光信号的传导方式和刚才介绍的直连方式是一样的，但有一点不同，因为多个用户同时收发网络包时信号会在分光器产生碰撞。  
因此，OLT 和 ONU 中具备通过调整信号收发时机来避免碰撞的功能。  
具体来说，OLT 会调整信号发送时机并向 ONU 下发指令，ONU 则根据 OLT 的指令来发送数据。  
反过来，当 BAS 端向用户发送数据时，分光器只需要将信号发给所有用户就可以了，这里并不会发生碰撞，  
但这样做会导致一个用户收到其他所有用户的信号，造成信息泄露的问题，因此需要在每个包前面加上用于识别 ONU 的信息，  
当 ONU 收到信号后，会接收发给自己的信号并将其转换成以太网信号。  

像这样，FTTH 可以分为直连和分路两种方式，这两种方式只是光信号的传输方式有一些区别，实际传输的网络包是相同的。  
当使用 PPPoE 来传输包时，其工作过程和刚才讲过的 ADSL 类似。  
具体来说，就是由互联网接入路由器在 IP 头部前面加上 MAC 头部、PPPoE 头部和 PPP 头部；  
然后由光纤收发器或者 ONU 转换成光信号；  
  - 不使用信元，而是将以太网包原原本本地转换成光信号。
并通过光纤到达 BAS 前面的多路光纤收发器和 OLT，最后被还原成电信号并到达 BAS。  

## 接入网中使用的 PPP 和隧道

### 用户认证和配置下发

用户发送的网络包会通过 ADSL 和 FTTH 等接入网到达运营商的 BAS 。  
互联网本来就是由很多台路由器相互连接组成的，因此原则上应该是将接入网连接到路由器上。  
随着接入网发展到 ADSL 和 FTTH，接入网连接的路由器也跟着演进，而这种进化型的路由器就叫作 BAS。下面我们来具体讲一讲。  

首先是用户认证和配置下发功能。
ADSL 和 FTTH 接入网中，都需要先输入用户名和密码，登录之后才能访问互联网，而 BAS 就是登录操作的窗口。
  - 这里的用户名和密码指的就是和运营商签约时由运营商分配给用户的上网用户名和密码。
BAS 使用 PPPoE 方式来实现这个功能。
  - PPPoE：Point-to-Point Protocol over Ethernet，以太网的点对点协议；
  - 也有一些运营商使用后面会提到的 PPPoA 方式。
PPPoE 是由传统电话拨号上网上使用的 PPP 协议发展而来的，所以我们先来看一看 PPP 拨号上网的工作方式。

#### PPP 拨号上网的工作方式

首先，用户向运营商的接入点拨打电话，电话接通后输入用户名和密码进行登录操作；
用户名和密码通过 RADIUS 协议从 RAS 发送到认证服务器，认证服务器校验这些信息是否正确；
  - RADIUS：Remote Authentication Dial-in User Service，远程认证拨号用户服务；
  - RAS：Remote Access Server，远程访问服务器。
当确认无误后，认证服务器会返回 IP 地址等配置信息，并将这些信息下发给用户；
用户的计算机根据这些信息配置 IP 地址等参数，完成 TCP/IP 收发网络包的准备工作，接下来就可以发送 TCP/IP 包了。

这个过程的重点在于下发 TCP/IP 配置信息的步骤。  
在接入互联网时，必须为计算机分配一个公有地址，但这个地址并不是事先确定的。  
因为在拨号连接时，可以根据电话号码来改变接入点，而不同的接入点具有不同的 IP 地址，因此无法事先在计算机上设置这个地址。  
所以，在连接时运营商会向计算机下发 TCP/IP 配置信息，其中就包括为计算机分配的公有地址。  

### 在以太网上传输 PPP 消息

ADSL 和 FTTH 接入方式也需要为计算机分配公有地址才能上网，这一点和拨号上网是相同的。  
不过，ADSL 和 FTTH 中，用户和 BAS 之间是通过电缆或光纤固定连接在一起的，因此没有必要验证用户身份，所以实际上并不需要 PPP 的所有这些功能。  
然而，通过用户名和密码登录的步骤可以根据用户名来切换不同的运营商，这很方便。  
  - 通过输入用户名和密码，可以掌握是谁在访问互联网，从网络管理的角度来看，这对于运营商来说也是很方便的。
因此，接入运营商在 ADSL 和 FTTH 中一般也会使用 PPP 。  
  - 也有一些运营商不使用 PPP，而是使用 DHCP 方式来向客户端下发 IP 地址等配置信息。

不过，拨号上网的 PPP 是无法直接用于 ADSL 和 FTTH 的，要理解这里的原因，我们先来看看 PPP 协议是如何传输消息的。  

传输 PPP 消息的思路和将 IP 包装入以太网包中传输是一样的。PPP 协议中没有定义以太网中的报头和 FCS 等元素，也没有定义信号的格式，因此无法直接将 PPP 消息转换成信号来发送。  
要传输 PPP 消息，必须有另一个包含报头、FCS 、信号格式等元素的“容器”，然后将 PPP 消息装在这个容器里才行。  
于是，在拨号接入中 PPP 借用了 HDLC 协议作为容器，而 HDLC 协议原本是为在专线中传输网络包而设计的，拨号接入方式对这一规格进行了一些修正。  

拨号上网中的 PPP ：  
1. 用户在计算机上输入用户名和密码；
2. 根据用户名和密码生成 PPP 消息；
3.4. 将 PPP 消息装入 HDLC 帧进行发送；
5. Modem 或 TA 将数据转换成线路信号并通过电话线路或 ISDN 线路进行发送；
6.7. 数字 Modem 接收信号并还原 HDLC 帧；
8.9. 取出 HDLC 帧中的 PPP 消息，交给 RAS 的认证模块；
10. 将用户名和密码发送给认证服务器，认证服务器校验用户身份。

对于 ADSL 和 FTTH，如果可以和前面一样借用 HDLC 来作为容器，PPP 协议就可以直接使用了。  
但是，ADSL 和 FTTH 并不能使用 HDLC ，因此需要寻找另一个机制作为替代。  
于是，我们用以太网包代替 HDLC 来装载 PPP 协议。此外，以太网和 PPP 在设计上有所不同，为了弥补这些问题就重新设计了一个新的规格，这就是 PPPoE。  

ADSL 中的 PPP（ PPPoE ）：  
1. 用户在计算机上输入用户名和密码；
2. 根据用户名和密码生成 PPP 消息；
3.4. 将 PPP 消息装入以太网包进行发送；
5.6. 将以太网包拆分成 ATM 信元并通过 ADSL Modem 调制后通过电话线路发送；
7.8. 接收信号后将信号换成成信元，并发送给 BAS ；
9.10.11. 接收信元并还原成以太网包，取出 PPP 消息交给认证模块；
12. 将用户名和密码发送给认证服务器，认证服务器校验用户身份。

FTTH 中的 PPP（PPPoE）：  
1. 用户在计算机上输入用户名和密码；
2. 根据用户名和密码生成 PPP 消息；
3.4. 将 PPP 消息装入以太网包进行发送；
5. 将以太网包转换成光信号发送；
6.7. 接收光信号换成成以太网包；
8.9. 从以太网包中取出 PPP 消息交给认证模块；
10. 将用户名和密码发送给认证服务器，认证服务器校验用户身份。

于是，ADSL 和 FTTH 也可以像拨号上网一样传输 PPP 消息了。  
总之，只要将 PPP 消息装入以太网包中进行传输，ADSL 和 FTTH 就也可以像拨号上网一样通信了。  

> PPPoE 是将 PPP 消息装入以太网包进行传输的方式。

### 通过隧道将网络包发送给运营商

BAS 除了作为用户认证的窗口之外，还可以使用隧道方式来传输网络包。所谓隧道，就类似于套接字之间建立的 TCP 连接。  
在 TCP 连接中，我们从一侧的出口（套接字）放入数据，数据就会原封不动地从另一个出口出来，隧道也是如此。  
也就是说，我们将包含头部在内的整个包从隧道的一头扔进去，这个包就会原封不动地从隧道的另一头出来，就好像在网络中挖了一条地道，网络包从这个地道里穿过去一样。  

像这样，如果在 BAS 和运营商路由器之间的 ADSL/FTTH 接入服务商的网络中建立一条隧道，将用户到 BAS 的接入网连接起来，就形成了一条从用户一直到运营商路由器的通道；  
网络包通过这条通道，就可以进入互联网内部了，这样的机制就类似于将接入网一直延伸到运营商路由器。  

隧道有几种实现方式：  
1. TCP 连接；
   - 这种方式中，首先需要在网络上的两台隧道路由器之间建立 TCP 连接，然后将连接两端的套接字当作是路由器的端口，并从这个端口来收发数据。
     - 只要具备隧道功能，是不是路由器无所谓，有时也会使用服务器来建立隧道。
   - 换句话说，在路由器收发包时，是基于隧道的规则向隧道中放入或取出网络包，这时，TCP 连接就好像变成了一根网线，包从这里穿过到达另一端。
2. 基于封装（encapsulation）的隧道实现方式；
   - 这种方式是将包含头部在内的整个包装入另一个包中传输到隧道的另一端；
   - 在这种方式中，包本身可以原封不动地到达另一端的出口，从结果上看和基于 TCP 连接的方式是一样的，都实现了一个可供包进行穿梭的通道。

无论任何机制，只要能够将包原封不动搬运到另一端，从原理上看就都可以用来建立隧道。  

### 接入网的整体工作过程

接入网的工作从用户端的互联网接入路由器进行连接操作开始。  
首先，接入路由器中需要配置运营商分配的用户名和密码；  
  - 如果不使用路由器而是从计算机直接上网的情况下，需要在计算机中配置用户名和密码，这时计算机会代替路由器完成 PPPoE 操作，实际上这才是最初的原始方式。
然后，接入路由器会根据 PPPoE 的发现机制来寻找 BAS ；  
  - 这一机制和 ARP 一样是基于广播来实现的，过程类似于：
    - 用户询问：“ BAS 在不在？在的话请报告 MAC 地址。”
    - BAS 回答：“我在这里，我的 MAC 地址是xx:xx:xx:xx:xx:xx。”
    - 这样用户端就知道了 BAS 的 MAC 地址，也就可以和 BAS 进行通信了。
可以认为前面这个过程相当于拨号上网中拨通电话的动作。  

接下来，进入用户认证和下发配置的阶段；  
  - 这里的工作过程有点复杂，我们只说重点。
第一个重点是用户名和密码如何发送给 BAS。这里有两种方式，在互联网接入路由器的设置画面中可以选择：  
  - 一种是将密码进行加密的 CHAP 方式；
    - 进行加密的 CHAP 方式显然安全性更高，一般也推荐使用这种方式。
  - 一种是不加密的 PAP 方式。
    - 但也并不是说使用不加密的PAP 方式密码就立刻会被窃取；
    - 由于明文密码只在 BAS 和用户端路由器之间传输，所以如果要窃取密码，要么在路由器和 ADSL Modem 中间进行窃听，要么爬到电线杆上安装窃听装置拾取电缆中泄漏的电磁波；
    - 不过，光纤是不会泄漏电磁波的，因此无法通过第二种方式进行窃听。
第二个重点是，在校验密码之后 BAS 如何向用户下发 TCP/IP 配置信息。  
  - 这里下发的配置信息包括分配给上网设备的 IP 地址、DNS 服务器的 IP 地址以及默认网关的 IP 地址。
    - 分配给上网设备的 IP 地址是互联网中使用的公有地址。
当使用路由器连接互联网时，路由器会根据这些信息配置自身的参数。  
这样一来，路由器的 BAS 端的端口就有了公有地址，路由表中也配置好了默认网关，接下来就可以将包转发到互联网中了。  
  - 局域网端口一般是由用户分配一个私有地址；
  - 默认网关即默认路由所关联的网关地址。

接下来，客户端就会开始发送用来访问互联网的网络包。  
比如有人在浏览器里输入了一个网址，这时网络包就开始发送了。  
这些包的目的地是互联网中的某个地方，这个地方或许在互联网接入路由器的路由表里是找不到的。  
这时，路由器会选择默认路由，并将这个包转发给默认路由的网关地址，也就是 BAS 下发的默认路由。  

这里的操作过程和第 3 章介绍的路由器转发包的过程相同，只不过在通过路由表判断转发目标之后，包不是按照以太网规则转发，而是按照 PPPoE 规则转发，具体的过程如下：  
（为什么不是按照以太网规则转发？因为这是接入网的工作流程？）  
1. 首先，要发送的包会被加上头部信息，并设置相应的字段；  
     - 第一个 MAC 头部中；
       - 接收方 MAC 地址填写通过 PPPoE 发现机制查询到的 BAS 的 MAC 地址；
       - 发送方 MAC 地址填写互联网接入路由器的 BAS 端的端口的 MAC 地址；
       - 然后以太类型填写代表 PPPoE 的 8864（十六进制）。
     - 接下来是 PPPoE 头部和 PPP 头部，它们包含的字段有版本号、类型、编码、会话 ID 、载荷长度、协议；
       - 其中除了载荷长度之外，其他的值都是可以事先确定的，载荷长度就是需要传输的包的长度。
     - 再往后的部分就是包含 IP 头部在内的原始网络包。
   可以说，这里的转发操作中基本上不需要根据头部中的信息进行判断，只要将事先准备好的头部加上去就可以了。  
   然后，网络包会被转换成信号，从相应的端口发送出去。  
2. 接下来，网络包会到达 BAS，而 BAS 会将 MAC 头部和 PPPoE 头部去掉，取出 PPP 头部以及后面的部分，然后通过隧道机制将包发送出去；
3. 最后，PPP 包会沿隧道到达另一端的出口，也就是网络运营商的路由器。

### 不分配 IP 地址的无编号端口

一对一连接的端口可以不分配 IP 地址，这种方式称为无编号。  

以前，即便是在这样的场景中，还是会为每个端口分配 IP 地址，这是因为有一条规则规定所有的端口都必须具有 IP 地址。  
然而，当公有地址越来越少时，就提出了一个特例，即一对一连接的端口可以不分配 IP 地址。  
现在，在这种场景中按惯例都是不为端口分配 IP 地址的。这种情况下，BAS 下发配置信息时就不会下发默认网关的 IP 地址。  

PPPoE 是工作在以太网上的协议，可以通过集线器与路由器和 BAS 连接，因此从物理层面的连接形态来看并不是一对一的。  
不过，通过发现机制开始和 BAS 通信后，逻辑层面上就是一对一通信，因此这一性质也是适用的。  

### 互联网接入路由器将私有地址转换成公有地址

互联网接入路由器在转发包时需要进行地址转换。  
刚才我们讲过，BAS 会向用户端下发 TCP/IP 的配置信息，如果将这些信息配置在计算机上，就相当于计算机拥有了公有地址；  
这种情况下不需要进行地址转换也可以访问互联网。其实 TCP/IP 原本的设计就是这样的。  

然而，如果使用路由器来上网，BAS 下发的参数就会被配置在路由器上，而且公有地址也是分配给路由器的。这样一来，计算机就没有公有地址了。  
这时，计算机会被分配一个私有地址，计算机发送的包需要通过路由器进行地址转换然后再转发到互联网中。
Web 和电子邮件等应用程序不会受到地址转换的影响，但有些应用程序会因为地址转换无法正常工作，这一点需要大家注意。
这是因为有些应用程序需要将自己的 IP 地址告知通信对象或者告知控制服务器，但在有地址转换的情况下这些操作无法完成
- 网络电话、聊天、对战游戏等需要客户端之间直接收发网络包的应用程序都需要将自己的 IP 地址告知对方。
- 这些应用程序会受到地址转换的影响，但现在已经有很多解决方案，因此不能说这些应用程序全都不能正常工作。
- 对于某个应用程序来说，如果不知道它是否采用了相应的解决方案，就无法判断它是否会受到地址转换的影响。

遇到应用程序因地址转换无法正常工作的情况时，我们可以不使用路由器，而是直接让计算机接收来自BAS 的PPPoE 消息，也就是采用最原始的上网方法。
- 只要将计算机直接连接到 ADSL Modem、光纤收发器、ONU 等设备，或者是通过集线器连接到这些设备，计算机就可以直接接收PPPoE 消息了。
这样一来，计算机就具有了公有地址，不需要地址转换也可以上网了。
- 有一些面向公司提供的服务，如 IP8、IP16 等，可以分配多个公有地址，但这种服务非常昂贵。
不过，不用路由器上网也有一点需要注意，因为上网的计算机拥有公有地址，这意味着来自互联网的包可以直接到达计算机，这可能导致计算机被攻击。
因此，对于直接上网的客户端计算机，我们应该采取安装防火墙软件等防御手段。

### 除 PPPoE 之外的其他方式

刚才讲的内容都是基于 PPPoE 方式的，实际的接入网还有其他一些方式。  

使用 PPPoA 方式的 ADSL 接入网：
  - PPPoA：Point-to-Point Protocol over ATM。
  - PPPoA 不能用于 FTTH ，因为 FTTH 不使用 ATM 信元。

ADSL 使用 PPPoE 方式时，是先将 PPP 消息装入以太网包中，然后再将以太网包拆分并装入信元，而 PPPoA 方式是直接将 PPP 消息装入信元。  
由于只是开头加不加 MAC 头部和 PPPoE 头部的区别，PPP 消息本身是没有区别的，因此密码校验、下发 TCP/IP 配置参数、收发数据包等过程都是和 PPPoE 基本相同的。  
不过，虽然开头加不加 MAC 头部和 PPPoE 头部看上去只是很小的区别，但却会对用户体验产生一定的影响。  

用 ATM 信元装载 PPP 消息的 PPPoA：  
1. 用户在计算机上输入用户名和密码；
2.3. 根据用户名和密码生成 PPP 消息；
4. 将 PPP 消息拆分成 ATM 信元；
5. ADSL Modem 将信元调制成信号通过电话线发送；
6.7. 接收信号还原成信元，并发送给 BAS；
8.9. 接收 ATM 信元，还原 PPP 消息并交给认证模块；
10. 将用户名和密码发给认证服务器，认证服务器校验用户身份。

由于 PPPoA 没有 MAC 头部，所以 PPP 消息是无法通过以太网来传输的，  
这就意味着需要和 BAS 收发 PPP 消息的设备，也就是计算机和路由器，必须和 ADSL Modem 是一体的，否则 PPP 机制就无法工作了。  
这个一体化的方式主要有以下两种。  
1. 第一种是将计算机和 ADSL Modem 用 USB 接口连接起来， 这样 ADSL Modem 就和计算机成为一体了。
   - 不过，这种方式最终并没有普及。
2. 另一种方式是将 ADSL Modem 和路由器整合成一台设备。
   - 这种方式和 PPPoE 中使用路由器上网的方式基本没什么区别，因此得到了广泛的普及。
   - 不过，正如我们刚才提到的，当由于地址转换产生问题时，这种方式就不容易处理了，因为我们无法抛开路由器用计算机直接上网。

PPPoA 和 PPPoE 相比也有一些优势。PPPoE 方式中，需要添加 PPPoE 头部和 PPP 头部，这意味着 MTU 就相应变小了，这可能会降低网络的效率。  
  - PPPoE 一般还会和隧道技术一起使用，这时还需要加上隧道头部，MTU就更短了。
而 PPPoA 不使用以太网包来传输 PPP 消息，因此不会发生 MTU 变小的问题。  

PPPoE 会降低网络效率，PPPoA 也有 ADSL Modem 和路由器无法分离的限制，这两个问题其实都是由 PPP 引起的。  
因此，有一些运营商不使用 PPP，他们使用 DHCP 协议从 BAS 向用户端下发 TCP/IP 配置信息。  

DHCP 经常用于通过公司网络向客户端计算机下发 TCP/IP 配置信息。  
其原理：  
首先客户端请求配置信息；  
然后DHCP服务器下发配置信息，非常简单，不需要像 PPP 那样需要多个步骤，也不需要验证用户名和密码。  
- 没有用户名和密码，就意味着无法通过用户名来切换运营商网络，但这种方式也有优势，它可以单纯地直接传输以太网包，不需要添加额外的 PPP 头部，因此不会占用 MTU 。

此外，采用 DHCP 的运营商使用的 ADSL Modem 也和 PPPoE、PPPoA 方式不同，  
这种 ADSL Modem 不使用信元，而是直接将以太网包调制成 ADSL 信号，因此没有 ADSL Modem 和路由器无法分离的问题。  
- 使用信元的 PPPoE 和 PPPoA 方式中，BAS 需要配备比较昂贵的 ATM 接口，因此不使用信元还可以控制成本。

## 网络运营商的内部

网络包通过接入网之后，到达运营商 POP 的路由器。这里是互联网的入口，网络包会从这里进入互联网内部。  
- 简单来说，此后网络包的传输轨迹就是通过路由器的不断转发向目的地前进，基本过程和我们之前介绍的内容大同小异。

互联网的实体并不是由一个组织运营管理的单一网络，而是由多个运营商网络相互连接组成的。  
ADSL、FTTH 等接入网是与用户签约的运营商设备相连的，这些设备称为 POP ，互联网的入口就位于这里。  
- POP：Point of Presense，中文一般叫作“接入点”。

POP 的结构根据接入网类型以及运营商的业务类型不同而不同，POP 中包括各种类型的路由器，  
路由器的基本工作方式是相同的，但根据其角色分成了不同的类型，根据接入网的类型需要分别使用不同类型的路由器。  
1. 专线，这里用的路由器就是具有通信线路端口的一般路由器；
   - 专线不需要用户认证、配置下发等功能，因此用一般的路由器就可以了。
   - 专线是固定连接线路，不需要进行身份认证，参数是根据传真、书面等方式下发后进行手动配置的，因此也不需要 PPP、DHCP 等机制。其实，这就是最古老的互联网接入方式。
2. 电话、ISDN 等拨号方式的接入网，这里用的路由器称为 RAS ；
   - 拨号接入需要对用户拨电话的动作进行应答，而 RAS 就具备这样的功能；
   - 此外，之前讲过通过 PPP 协议进行身份认证和配置下发的过程，RAS 也具备这些功能。
3. PPPoE 方式的 ADSL 和 FTTH 。
   - PPPoE 方式中，ADSL、FTTH 接入服务商会使用 BAS，运营商的路由器则与 BAS 相连；
   - PPPoE 中的身份认证和配置下发操作由接入服务商的 BAS 来负责，运营商的路由器只负责对包进行转发，因此这里也是使用一般的路由器就可以了。
   - 如果 ADSL 采用 PPPoA 方式接入，那么工作过程会有所不同，DSLAM 通过 ATM 交换机与 ADSL 的运营商的 BAS 相连，然后再连接到运营商的路由器。
   - 用户端传输的信号先经过 ADSL Modem 拆分成 ATM 信元并进行调制，然后 DSLAM 将信号还原成信元，
   - 通过 ATM 交换机转发到 BAS，最后 BAS 将信元还原成网络包，再通过运营商的路由器转发到互联网内部。

对于连接接入网的部分来说，由于要连接的线路数量很多，所以路由器需要配备大量的端口，但能传输的网络包数量相对比较少，这是因为接入网的速率比互联网核心网络要低。  
因此，端口多且价格便宜的路由器适用于这些场景。  
相对地，连接骨干网的路由器用于连接运营商和核心 NOC 以及其他 POP ，所有连接接入网的路由器发出的包都会集中到这里，使用的线路速率也比较高，  
  - NOC: Network Operation Center，网络运行中心。
因此这里需要配备转发性能和数据吞吐量高的路由器。  

NOC 是运营商的核心设备，从 POP 传来的网络包都会集中到这里，并从这里被转发到离目的地更近的 POP ，或者是转发到其他的运营商。这里也需要配备高性能的路由器。  

话说回来，到底需要多高的性能才行呢？我们来看实际产品的参数。  
面向运营商的高性能路由器中有些产品的数据吞吐量超过 1 Tbit/s，而一般面向个人的路由器的数据吞吐量也就 100 Mbit/s 左右，两者相差 1 万多倍。  
当然，路由器的性能不完全是由吞吐量决定的，但从这里可以看出规模和性能的差异。  
其实，NOC 和 POP 并没有非常严格的界定。  
NOC 里面也可以配备连接接入网的路由器，很多情况下是和 POP 共用的。  
从 IP 协议的传输过程来看，也没有对两者进行区分的必然性，因为无论是哪个路由器，其转发网络包的基本工作原理都是相同的。  
因此，大家可以简单地认为，NOC 就是规模扩大后的 POP 。  

### 室外通信线路的连接

POP 和NOC 遍布全国各地，它们各自的规模有大有小，但看起来跟公司里的机房没什么太大区别，都是位于一幢建筑物中的，  
其中的路由器或者通过线路直接连接，或者通过交换机进行连接，这些和公司以及家庭网络都是相同的。  
只不过，公司的机房一般使用双绞线来连接设备，但运营商的网络中需要传输大量的包，已经超过了双绞线能容纳的极限，因此一般还是更多地使用光纤。  

大楼室内可以用线路直接连接，对于距离较远的 NOC 和 POP 来说，它们之间的连接方式可以分为几种：  
1. 对于自己拥有光纤的运营商来说，可以选择最简单的方式，也就是用光纤将NOC 和POP 直接连接起来。
     - 比如，电话公司由于自身业务需要，通过电线杆等方式铺设了很多光纤，那么这些公司属于拥有光纤的；
     - 电力公司通过继承电线杆上架设的光纤来开展通信业务，也算是自己拥有光纤的；
     - 此外，高速公路沿途铺设的光纤也会归一些公司所有，因此拥有光纤的方式是多种多样的。
   这种方式虽然想法简单，但实现起来却并不简单。光纤需要在地下铺设，需要很大的工程费用，而且当线路发生中断时还必须进行维修，这些维护工作也需要费用。  
   因此，只有有限的几家大型运营商才拥有光纤。  
2. 其他不拥有光纤运营商只要从其他公司租借光纤就可以了，但所谓租借并不是光纤本身。
   - 拥有光纤的公司一般都会提供光纤租用服务。
     - 以电话公司为例，电话公司会在其拥有的光纤中传输语音数据，但一条光纤并不是只能传输一条语音数据，光纤是可以复用的，一条语音数据只占其通信能力的一部分。
     - 换句话说，电话公司可以将自己的光纤的一部分通信能力租借给客户。对于客户来说，只要支付一定的费用就可以使用其中的通信能力了。
     - 对于电话公司来说，其拥有的光纤不会全部自己使用，通过租借的方式也可以带来一定的收益，无论其业务本质是电话还是互联网，这一点都是共通的。
     - 这种服务就叫作通信线路服务。

## 跨越运营商的网络包

### 运营商之间的连接

视角重新回到运营商内部，看一看到达 POP 路由器之后，网络包是如何前往下一站的。  

如果最终目的地 Web 服务器和客户端是连接在同一个运营商中的：  
那么 POP 路由器的路由表中应该有相应的转发目标。  
运营商的路由器可以和其他路由器交换路由信息，从而自动更新自己的路由表，通过这一功能，路由信息就实现了自动化管理。  
于是，路由器根据路由表中的信息判断转发目标，这个转发目标可能是 NOC ，也可能是相邻的 POP ，  
无论如何，路由器都会把包转发出去，然后下一个路由器也同样根据自己路由表中的信息继续转发。  
经过几次转发之后，网络包就到达了 Web 服务器所在的 POP 的路由器，然后从这里被继续转发到 Web 服务器。  

如果服务器的运营商和客户端的运营商不同：  
这种情况下，网络包需要先发到服务器所在的运营商，这些信息也可以在路由表中找到，这是因为运营商的路由器和其他运营商的路由器也在交换路由信息。  
这个信息交换的过程稍后再讲，我们暂且认为路由表中能找到对方运营商的路由信息，这时网络包会被转发到对方运营商的路由器。  

总之，对于互联网内部的路由器来说，无论最终目的地是否属于同一家运营商，都可以从路由表中查到，  
因此只要一次接一次按照路由表中的目标地址来转发包，最终一定可以到达 Web 服务器所在的 POP 。  
这样一来，我们就可以把包发到任何地方，包括地球的另一面。  

### 运营商之间的路由信息交换

只要路由表中能够查到，我们当然可以把包发到任何地方，包括地球的另一面，  
但如果路由表中没有相应的路由信息，路由器就无法判断某个网络的位置，也就无法对包进行转发，  
也就是说，仅仅用线路将路由器连起来，是无法完成包转发的。  

关于运营商之间是如何交换信息并对路由器进行自动更新的：  
其实方法并不难，只要让相连的路由器告知路由信息就可以了。  
只要获得了对方的路由信息，就可以知道对方路由器连接的所有网络，将这些信息写入自己的路由表中，也就可以向那些网络发送包了。  
获得对方的路由信息之后，我们也需要将自身的路由信息告知对方。这样一来，对方也可以将发往我们所在子网的包转发过来。
这个路由信息交换的过程是由路由器自动完成的，这里使用的机制称为 BGP 。
  - BGP：Border Gateway Protocol，边界网关协议。

根据所告知的路由信息的内容，这种路由交换可分为两类。  
一类是将互联网中的路由全部告知对方。  
例如，如果运营商 D 将互联网上所有路由都告知运营商 E ，则运营商 E 不但可以访问运营商 D ，还可以访问运营商 D 后面的运营商 B、A 和 C 。  
然后，通过运营商 D 就可以向所有的运营商发送包。像这样，通过运营商 D 来发送网络包的方式称为转接。  
另一种类型是两个运营商之间仅将与各自网络相关的路由信息告知对方。  
这样，只有双方之间的网络可以互相收发网络包，这种方式称为非转接，也叫对等。  

### 与公司网络中自动更新路由表机制的区别

路由器之间相互交换信息自动更新路由表的方式在公司网络中也会用到，不过公司内部和运营商之间在路由交换方式上是有区别的。  

公司中使用的方式是寻找与目的地之间的最短路由，并按照最短路由来转发包，因此，周围的所有路由器都是平等对待的。  

公司内部采用这样的方式没问题，但运营商之间就不行了。  
假设某个运营商拥有一条连接日本和美国的高速线路，那么要访问美国的地址时，可能这条线路是最短路由。  
如果单纯采用最短路由的方式，那么其他运营商的包就都会走这条线路，这时，该运营商需要向其他运营商收取相应的费用，否则就成义务劳动了。  
在这种情况下，如果使用最短路由的方式，就无法区分哪个运营商交了费，哪个运营商没交费，也就是说无法阻止那些没交费的运营商使用这条线路，这样就很难和对方进行交涉了。  
正是出于这样的原因，互联网中不能单纯采用最短路由，而是需要一种能够阻止某些来源的网络包的机制，互联网的路由交换机制就具有这样的功能。  

1. 首先，互联网中可以指定路由交换的对象；
   - 公司中，路由信息是在所有路由器间平等交换的；
   - 但运营商之间的路由交换是在特定路由器间一对一进行的；
   - 这样一来，运营商就可以只将路由信息提供给那些交了费的运营商，那些没交费的运营商也就无法将网络包发送过来了。
2. 其次，在判断路由时，该机制不仅可以判断是否是最短路由，还可以设置其他一些判断因素。
   - 例如当某个目的地有多条路由时，可以对每条路由设置优先级。

运营商之间需要对交换路由信息的对象进行判断和筛选，但这样一来，对于没有交换路由信息的运营商网络，我们就无法将网络包发送过去了，  
如果要访问的 Web 服务器就在那个运营商网络中，我们不就访问不了了吗？  
其实不用担心，运营商在进行路由交换时会避免出现这样的情况。  
互联网中有很多运营商，每个运营商都和其他多个运营商相互连接。  
因此，如果一个运营商走不过去，可以走另一个运营商，无论网络包要发送到什么地方，都会确保能够获取相应的路由信息。  
如果某个运营商做不到这一点，那它也就该倒闭了。  

### IX 的必要性

IX：Internet eXchange，中文一般叫作“互联网交换中心”。  

对于两个运营商来说，一对一的连接时最基本的一种连接方式，现在也会使用这种方式。  
但是这种方式有个不方便的地方，如果运营商之间只能一对一连接，那么就需要把所有的运营商都用通信线路连接起来。  
现在光日本国内就有数千家运营商，这样连接非常困难。  
对于这种情况，可以设置一个中心设备，通过连接到中心设备的方式来减少线路数量，这个中心设备就称为 IX 。  

### 运营商如何通过 IX 互相连接

IX 的部署场所：  
为了保证在遇到停电、火灾等事故，以及地震等自然灾害时，路由器等网络设备还能继续工作，IX 所在的大楼都装有自主发电设备，并具有一定的抗震能力。  
- 其实这样的要求也不仅限于 IX ，运营商的 NOC 也是一样。
- 现在在日本，拥有如此高安全性的大楼其实并不多，因此符合这样要求的大楼里面都可能会有 NOC 和 IX 。
- 运营商和 IX 运营机构会租下大楼中的一块地方用于放置 NOC 和 IX 的设备，换句话说，IX 就在这些大楼中某一层的某个角落中。

IX 的核心是具有大量高速以太网端口的二层交换机。  
二层交换机的基本原理和一般交换机相同，大家可以认为 IX 的核心就是大型的、高速的交换机。  

将各个运营商的路由器连接到 IX 核心交换机上的连接方法：  
1. 当运营商 NOC 和 IX 位于同一幢大楼里时，只要从 NOC 中将光纤延长出来接到 IX 交换机就可以了；
   - 这种情况和公司、家庭网络中的路由器与交换机的连接方法是相同的。
2. 当运营商 NOC 和 IX 不位于同一幢大楼里时，我们可以用通信线路将路由器和交换机连起来。
   这种情况下有两种连法：
   1. 一种是从路由器延伸出一根通信线路并连接到 IX 交换机上；
   2. 另一种是将路由器搬到 IX 机房里，用通信线路将路由器和 NOC 连起来，再将路由器连到 IX 交换机上。
   
下面我们来看一看网络包具体是如何传输的。其实这里并没有什么特别需要解释的，因为 IX 的交换机和一般的交换机在工作方式上没有区别。  
路由器发送网络包时，先通过 ARP 查询下一个路由器的 MAC 地址，然后将其写入 MAC 头部发送出去即可。  
只要填写了正确的 MAC 地址，就可以向任何运营商的路由器发送包。  
不过实际上，要成功发送包还需要正确的路由信息，对于没有进行路由交换的运营商，我们是无法向其发送包的。  
这需要运营商之间通过谈判签订合约，然后按照合约来交换路由信息，实现网络包的收发。  

运营商之间可以直接连接，也可以通过 IX 连接，无论是哪种方式，最终网络包都会到达服务器所在的运营商，然后通过 POP 进入服务器端的网络。  
















































































































































































































































































































































































































































































































































































































































































































