要实现应用程序之间的交互，我们需要一个能够在浏览器和Web服务器之间传递请求和响应的机制。  
由于请求和相应都是由 0 和 1 组成的数字信息，所以可以说，我们需要的是一种能够将数字信息搬运到指定目的地的机制。  
这种机制是由操作系统中的网络控制软件，以及交换机、路由器等设备分工合作来实现的，它的基本思路是将数字信息分割成一个一个的小块，然后装入一些被称为“包”（Packet）的容器中来运送。  
这个负责搬运数字信息的机制，再加上浏览器和Web服务器这些网络应用程序，这两部分就组成了网络。  

# 章节主要内容

## 第1章 Web 浏览器

首先介绍浏览器的工作方式，当输入网址时，浏览器就会按照一定的规则去分析这个网址的含义，然后根据其含义生成请求消息。  
接着浏览器就会委托操作系统中的网络控制软件将消息发送给服务器。  

## 第2章 协议栈、网卡

介绍探索搬运数据的机制。  
首先介绍协议栈（网络控制软件叫作协议栈）。这个软件会将从浏览器接收到的消息打包，然后加上目的地址等控制信息。  
接下来，协议栈会将包交给网卡（负责以太网或无线网络通信的硬件）。  
然后，网卡会将包转换为电信号并通过网线发送出去。这样一来，包就进入到网络之中了。  

## 第3章 集线器、交换机、路由器

本章假设客户端计算机是连接到家庭或公司的局域网中，然后再通过 ADSL 和光纤到户（FTTH）等宽带线路接入互联网。  
在这样的场景中，网卡发送的包会经过交换机等设备，到达用来接入互联网的路由器。路由器的后面就是互联网，网络运营商会负责将包送到目的地。  

## 第4章 接入网、网络运营商

数据从用来接入互联网的路由器出发，进入了互联网的内部。互联网的入口线路称为接入网。  
在骨干网中存在很多运营商和大量的路由器，这些路由器相互连接，组成一张巨大的网，而我们的网络包就在其中经过若干路由器的接力，最终被发送到目标Web服务器上。  

## 第5章 防火墙、缓存服务器

通过骨干网之后，网络包最终到达了 Web 服务器所在的局域网中。  
接着，它会遇到防火墙，防火墙会对进入的包进行检查。  
检查完之后，网络包接下来可能还会遇到缓存服务器。  
此外，在大型网站中，可能还会配备将消息分布到多台 Web 服务器上的负载均衡器，还有可能会使用通过分布在整个互联网中的缓存服务器来分发内容的服务。  
经过这些机制之后，网络包才会到达 Web 服务器。  

## 第6章 Web服务器

当网络包到达 Web 服务器后，数据会被解包并还原为原始的请求消息，然后交给 Web 服务器程序。  
接下来，Web 服务器程序分析请求消息的含义，并按照其中的指示将数据装入响应消息中，然后发回给客户端。  
  - 响应消息回到客户端的过程和之前我们介绍的过程正好相反。
当响应到达客户端之后，浏览器会从中读取出网页的数据并在屏幕上显示出来。  

# 涉及到的主要关键词

## 第1章 浏览器生成消息

浏览器、Web服务器、网址（URL）、HTTP、HTML、协议、URI、请求消息、解析器、Socket库、DNS服务器、域名  

## 第2章 用电信号传输TCP/IP数据

TCP/IP、套接字、协议栈、IP地址、端口号、包、头部、网卡、网卡驱动、MAC地址、以太网控制器、ICMP、UDP  

## 第3章 从网线到网络设备

局域网（LAN）、双绞线、串扰、中继式集线器、MDI、MDI-X、交换式集线器、全双工、半双工、碰撞、自动协商、路由器、  
路由表、子网掩码、默认网关、分片、地址转换、公有地址、私有地址  

## 第4章 通过接入网进入互联网内部

ADSL、FTTH、光纤、接入网、ADSL􀀀Modem集成式路由器、ATM、信元、正交振幅调制、分离器、DSLAM、宽带接入服务器、  
远程接入服务器、PPP、网络运行中心（NOC）、光纤、IX（Internet􀀀eXchange，互联网交换）  

## 第5章 服务器端的局域网中有什么玄机

防火墙、包过滤、数据中心、轮询、负载均衡器、缓存服务器、代理、代理服务器、内容分发服务、重定向  

## 第6章 请求到达Web服务器，响应返回浏览器

响应消息、多任务、多线程、虚拟目录、CGI、表单、访问控制、密码、数据格式、MIME  

# 第1章 浏览器生成消息——探索浏览器内部

## 热身问答

1. `http://www.nikkeibp.co.jp/`中的`www`只是Web服务器上的一种命名。  
   World Wide Web是Web的提出者最早开发的浏览器兼HTML编辑器的名字。  

2. 如果是`.com`、`.net`、`.org`、`.jp`（除`co.jp`、`ne.jp`等`xx.jp`格式的域名外）等没有对注册对象范围进行限制的域名，任何个人都可以申请注册。  
   - 在中国的情况，个人可以申请“`.cn`”域名，但“`.com.cn`”“`.net.cn`”等域名则是不开放给个人注册的。
   - 日本的域名体系中，`.jp`下级的域名用的是两个字母的命名，例如`.co.jp`、`.ne.jp`。
   此外，也有一种`.name`域名是专门为个人申请者准备的。  
   
3. 应用程序并不是自己去控制网络，而是委托操作系统来控制网络。  

## 看点

### 生成HTTP请求消息

用户在浏览器输入网址（URL） -\> 浏览器解析网址 -\> 浏览器根据网址含义生成请求信息

### 向DNS服务器查询Web服务器的IP地址

请求消息生成之后，浏览器会委托操作系统向 Web 服务器发送请求，但浏览器必须告诉操作系统接收方的 IP 地址才行，因此浏览器必须先查出 Web 服务器的 IP 地址。  
网址中只有 Web 服务器的域名，因此浏览器需要向 DNS 服务器查询域名对应的IP地址。  

### 全世界 DNS 服务器的大接力

全世界共有上万台 DNS 服务器，它们相互接力才能完成IP地址的查询，而它们进行接力的方法也是本章看点之一。  

### 委托协议栈发送消息

查询到 IP 地址之后，浏览器就可以将消息委托给操作系统发送给Web服务器了，但这个委托到底是如何完成的呢？这也是本章看点之一。  
理解了向操作系统进行委托时的规则，我们就能够明白做出某个委托时操作系统会给我们怎样的反馈，这可以说是相当于具体地理解了网络的潜在能力。  

## 生成 HTTP 请求消息

### 输入网址

#### 网址的定义

网址，准确来说应该叫 URL，是以`http://` 开头的那一串东西；  
实际上除了`http:`，网址还可以以其他一些文字开头，例如“`ftp:`、`file:`、`mailto:`等。  

浏览器是一个具备多种客户端功能的综合性客户端软件，因此它需要一些东西来判断应该使用其中哪种功能来访问相应的数据，而各种不同的 URL 就是用来干这个的，比如访问 Web 服务器时用`http:`，而访问 FTP 服务器下载和上传文件时用`ftp:`。  

#### 网址的格式

根据访问目标的不同，URL 的写法也会不同。  
  - 在访问 Web 服务器和 FTP 服务器时，URL 中会包含服务器的域名和要访问的文件的路径名等；
  - 发邮件的 URL 则包含收件人的邮件地址。
此外，根据需要，URL 中还会包含用户名、密码、服务器端口号等信息。  

##### URL的各种格式

用HTTP协议访问Web服务器时：  
|http://|user|:|password|@|www.glasscom.com|:80|/dir/file1.htm|  
|---|---|---|---|---|---|---|---|  
||用户名（可省略）||密码（可省略）||Web服务器域名|端口号（可省略）|文件的路径名|

用FTP协议下载和上传文件时：  
|ftp://|user|:|password|@|ftp.glasscom.com|:21|/dir/file1.htm|
|---|---|---|---|---|---|---|---|
|协议|用户名（可省略）||密码（可省略）||FTP服务器域名|端口号（可省略）|文件的路径名|

读取客户端计算机本地文件时:  
|file://|localhost|/c:/path/file1.zip|
|---|---|---|
||计算机名（可省略）|文件的路径名|

发送电子邮件时：  
|mailto:|tone@glasscom.com|
|---|---|
||邮件地址|

阅读新闻组的文章时:  
|news:|comp.protocols.tcp-ip|
|---|---|
||新闻组名|

尽管 URL 有各种不同的写法，但它们有一个共同点，那就是 URL 开头的文字，即`http:`、`ftp:`、`file:`、`mailto:`这部分文字都表示浏览器应当使用的访问方法。  
  - 访问 Web 服务器时应该使用 HTTP 协议；
  - 访问 FTP 服务器时则应该使用 FTP 协议。
因此，我们可以把这部分理解为访问时使用的协议类型。  
尽管后面部分的写法各不相同，但开头部分的内容决定了后面部分的写法，因此并不会造成混乱。  

> 1. HTTP：Hypertext Transfer Protocol，超文本传送协议。
  2. 协议：通信操作的规则定义称为协议（protocol）。

### 解析网址

浏览器要做的第一步工作就是对 URL 进行解析，从而生成发送给 Web 服务器的请求消息。  
具体步骤：  
1. 按照 URL 规格对字符串进行解析；
2. 将 URL 拆分为各个组成元素；
3. 分别理解各个元素的语义含义；
   - 主机名用于确定要访问的服务器；
   - 路径名用于确定服务器上要访问的具体资源位置。
4. 根据解析结果确定访问目标。

### 省略文件名的情况

URL 可以省略文件名，进一步省略目录名，再进一步省略结尾的`/`。这些写法都是允许的。  
当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是`/index.html`或者`/default.htm`这些文件。  

例：http://www.lab.glasscom.com/whatisthis  
一般来说，这种情况会按照下面的惯例进行处理：
如果Web 服务器上存在名为 whatisthis 的文件，则将 whatisthis 作为文件名来处理；  
如果存在名为 whatisthis 的目录，则将 whatisthis 作为目录名来处理。  

### HTTP 的基本思路

解析完 URL 之后，浏览器会使用 HTTP 协议来访问 Web 服务器。  

HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤，其基本思路非常简单。  
首先，客户端会向服务器发送请求消息。请求消息中包含的内容是“对什么”和“进行怎样的操作”两个部分。  
收到请求消息之后，Web 服务器会对其中的内容进行解析，通过 URI 和方法来判断“对什么”“进行怎样的操作”，并根据这些要求来完成自己的工作，然后将结果存放在响应消息中。  


#### URI 和方法

- 相当于“对什么”的部分称为 URI；
  - 一般来说，URI 的内容是一个存放网页数据的文件名或者是一个 CGI 程序的文件名，例如“/dir1/file1.html”“/dir1/program1.cgi”等。
  - 不过，URI 不仅限于此，也可以直接使用“http:”开头的 URL 来作为 URI。换句话说就是，这里可以写各种访问目标，而这些访问目标统称为URI。

- “进行怎样的操作”的部分称为方法。
  - 方法表示需要让 Web 服务器完成怎样的工作，其中典型的例子包括读取 URI 表示的数据、将客户端输入的数据发送给 URI 表示的程序等。

#### HTTP 的主要方法：  

|方法|含义|
|---|---|
|GET|获取 URI 指定的信息。如果 URI 指定的是文件，则返回文件的内容；如果 URI 指定的是 CGI 程序，则返回该程序的输出数据|
|POST|从客户端向服务器发送数据。一般用于发送表单中填写的数据等情况下|
|HEAD|和 GET 基本相同。不过它只返回 HTTP 的消息头（message header），而并不返回数据的内容。用于获取文件最后更新时间等属性信息|
|OPTIONS|用于通知或查询通信选项|
|PUT|替换 URI 指定的服务器上的文件。如果 URI 指定的文件不存在，则创建该文件|
|DELETE|删除 URI 指定的服务器上的文件|
|TRACE|将服务器收到的请求行和头部（header）直接返回给客户端。用于在使用代理的环境中检查改写请求的情况|
|CONNECT|使用代理传输加密消息时使用的方法|

除了表中的内容之外，HTTP 消息中还有一些用来表示附加信息的头字段。客户端向 Web 服务器发送数据时，会先发送头字段，然后再发送数据。不过，头字段属于可有可无的附加信息。  

#### 响应消息

在响应消息的开头有一个状态码，它用来表示操作的执行结果是成功还是发生了错误。  
  - 当我们访问 Web 服务器时，遇到找不到的文件就会显示出404 Not Found 的错误信息，其实这就是状态码。
状态码后面就是头字段和网页数据。响应消息会被发送回客户端，客户端收到之后，浏览器会从消息中读出所需的数据并显示在屏幕上。到这里，HTTP 的整个工作就完成了。  

#### 补充知识

上表列出的 HTTP 方法中最常用的就是`GET`方法，所以一般的访问过程是：  
1. 在请求消息中写上 GET 方法，然后在 URI 中写上存放网页数据的文件名“/dir1/file1.html”；
   - 表示我们需要获取 /dir1/file1.html 文件中的数据。
2. 当 Web 服务器收到消息后，会打开 /dir1/file1.html 文件并读取出里面的数据；
3. 将读出的数据存放到响应消息中，并返回给客户端；
4. 最后，客户端浏览器会收到这些数据并显示在屏幕上。

还有一个经常使用的方法就是`POST`，在表单中填写数据并将其发送给 Web 服务器时就会使用这个方法。
  - 当我们在网上商城填写收货地址和姓名，或者是在网上填写问卷时，都会遇到带有输入框的网页，而这些可以输入信息的部分就是表单。
1. 使用POST 方法时，URI 会指向 Web 服务器中运行的一个应用程序的文件名；
   - 典型的例子包括“index.cgi”“index.php”等。
2. 在请求消息中，除了方法和 URI 之外，还要加上传递给应用程序和脚本的数据；
   - 这里的数据也就是用户在输入框里填写的信息。
3. 当服务器收到消息后，Web 服务器会将请求消息中的数据发送给 URI 指定的应用程序；
4. Web 服务器从应用程序接收输出的结果，会将它存放到响应消息中并返回给客户端；
5. 最后，客户端浏览器会收到这些数据并显示在屏幕上。

前面两个方法属于 HTTP 的典型用法，除此之外的其他方法在互联网上几乎见不到使用的例子。  

如果只有 GET 和 POST 方法，我们就只能从 Web 服务器中获取网页数据，以及将网页输入框中的信息发送给 Web 服务器。  
而有了 PUT 和 DELETE 方法，就能够从客户端修改或者删除 Web 服务器上的文件。  
有了这些功能，我们甚至可以将 Web 服务器当成文件服务器来用。  
  - 当然，出于安全上的原因，或者是支持 GET 和 POST 之外的方法的客户端没有广泛普及之类的原因，一般我们并不会碰到这样的用法。

### 生成 HTTP 请求消息

对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。  
HTTP 消息在格式上是有严格规定的，因此浏览器会按照规定的格式来生成请求消息。  

#### HTTP 请求消息的格式

|内容|名称|
|<方法><空格><URI><空格><HTTP版本>|请求行|
|---|---|
|<字段名>:<字段值>|消息头|
|...|消息头|
|...|消息头|
|...|消息头|
|<空行>||
|<消息体>|消息体|

- 请求行：通过这一行可以大致了解请求的内容；  
- 消息头：每行包含一个头字段，用于表示请求的附加信息。消息头的行数根据具体情况可变，一直延伸到空行为止；  
- 消息体：包含客户端向服务器发送的数据，例如用 POST 方法向 Web 服务器发送的网页表单数据。  

#### 写一个请求消息

请求行的重点是最开头的方法，方法可以告诉 Web 服务器它应该进行怎样的操作。但是方法有很多种，必须先判断应该选用其中的哪一种。  
选择的关键在于浏览器的工作状态，浏览器并非只有在这一种场景下才会向 Web 服务器发送请求消息。  
  - 比如点击网页中的超级链接，或者在表单中填写信息后点击“提交”按钮，这些场景都会触发浏览器的工作，而选用哪种方法也是根据场景来确定的。  

在地址栏中输入网址并显示网页，应该使用 GET 方法。  
点击超级链接的场景中也是使用 GET 方法。  
如果是表单，在 HTML 源代码中会在表单的属性中指定使用哪种方法来发送请求，可能是 GET 也可能是 POST。  
  - GET 方法能够发送的数据只有几百个字节，如果表单中的数据超过这一长度，则必须使用 POST 方法来发送。

写好方法之后，加一个空格，然后写 URI。URI 部分的格式如下，一般是文件和程序的路径名。
  - /\<目录名\>/…/\<文件名\>

第一行的末尾需要写上 HTTP 的版本号，这是为了表示该消息是基于哪个版本的 HTTP 规格编写的。到此为止，第一行就结束了。  

第二行开始为消息头。  
  - 尽管通过第一行我们就可以大致理解请求的内容，但有些情况下还需要一些额外的详细信息，而消息头的功能就是用来存放这些信息；
  - 消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等；
    - 这些项目表示的都是非常细节的信息。
  - 消息头中的内容随着浏览器类型、版本号、设置等的不同而不同，大多数情况下消息头的长度为几行到十几行不等。

写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据。这一部分称为消息体，也就是消息的主体。  
  - 不过，在使用 GET 方法的情况下，仅凭方法和 URI，Web 服务器就能够判断需要进行怎样的操作，因此消息体中不需要填写任何数据。
  - 当使用 POST 方法时，需要将表单中填写的信息写在消息体中。

到此为止，请求消息的生成操作就全部完成了。  

### 发送请求后会收到响应

这里先粗略地了解一下：响应消息的格式以及基本思路和请求消息是相同的，差别只在第一行上。  
  - 在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错；
  - 状态码和响应短语表示的内容一致，但它们的用途不同；
  - 状态码是一个数字，它主要用来向程序告知执行的结果；
  - 相对地，响应短语则是一段文字，用来向人们告知执行的结果。

#### HTTP 状态码概要

状态码的第一位数字表示状态类型，第二、三位数字表示具体的情况。下表列举了第一位数字的含义。  

|状态码|含义|
|---|---|
|1xx|告知请求的处理进度和情况|
|2xx|成功|
|3xx|表示需要进一步操作|
|4xx|客户端错误|
|5xx|服务器错误|

返回响应消息之后，浏览器会将数据提取出来并显示在屏幕上，我们就能够看到网页的样子了。  
如果网页的内容只有文字，那么到这里就全部处理完毕了，但如果网页中还包括图片等资源，则还有下文。  

#### 当网页包含图片时

当网页中包含图片时，会在网页中的相应位置嵌入表示图片文件的标签的控制信息。  
浏览器会在显示文字时搜索相应的标签，当遇到图片相关的标签时，会在屏幕上留出用来显示图片的空间，然后再次访问 Web 服务器，  
按照标签中指定的文件名向 Web 服务器请求获取相应的图片并显示在预留的空间中。  
这个步骤和获取网页文件时一样，只要在 URI 部分写上图片的文件名并生成和发送请求消息就可以了。  

> 1 条请求消息中只能写 1 个 URI。如果需要获取多个文件，必须对每个文件单独发送 1 条请求。
  - 比如 1 个网页中包含 3 张图片，那么获取网页加上获取图片，一共需要向 Web 服务器发送 4 条请求。
  判断所需的文件，然后获取这些文件并显示在屏幕上，这一系列工作的整体指挥也是浏览器的任务之一，而 Web 服务器却毫不知情。
  Web 服务器完全不关心这 4 条请求获取的文件到底是 1 个网页上的还是不同网页上的，它的任务就是对每一条单独的请求返回 1 条响应而已。

## 向 DNS 服务器查询 Web 服务器的 IP 地址

### IP 地址的基本知识

生成 HTTP 消息之后，需要根据域名查询 IP 地址将其交给操作系统，然后委托操作系统将消息发送给 Web 服务器。  
  - 尽管浏览器能够解析网址并生成 HTTP 消息，但它本身并不具备将消息发送到网络中的功能，因此这一功能需要委托操作系统来实现。  

互联网和公司内部的局域网都是基于 TCP/IP 的思路来设计的，TCP/IP 的结构就是由一些小的子网，通过路由器连接起来组成一个大的网络。  
  - 这里的子网可以理解为用集线器连接起来的几台计算机，我们将它看作一个单位，称为子网；
  - 将子网通过路由器连接起来，就形成了一个网络。

在网络中，所有的设备都会被分配一个地址。这个地址就相当于现实中某条路上的“ ×× 号 ×× 室”。  
  - “号”对应的号码是分配给整个子网的，“室”对应的号码是分配给子网中的计算机的，这就是网络中的地址；
  - “号”对应的号码称为网络号，“室”对应的号码称为主机号，这个地址的整体称为 IP 地址。
通过 IP 地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。  

#### 消息传送的具体过程

在后面的章节中会详细讲解，现在先简单了解一下。  
- 发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上；  
- 接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器；    
  - 即消息再次经过子网内的集线器被转发到下一个路由器。
- 前面的过程不断重复，最终消息就被传送到了目的地。  

#### 实际的 IP 地址

实际的 IP 地址是一串 32 比特的数字，按照 8 比特（ 1 字节）为一组分成 4 组，分别用十进制表示然后再用圆点隔开。  
这就是我们平常经常见到的 IP 地址格式，但仅凭这一串数字我们无法区分哪部分是网络号，哪部分是主机号。  
  - 在 IP 地址的规则中，网络号和主机号连起来总共是 32 比特，但这两部分的具体结构是不固定的。  
  
##### 子网掩码
  
在组建网络时，用户可以自行决定网络号和主机号在 32 比特之间的分配关系，因此，我们还需要另外的附加信息来表示 IP 地址的内部结构。  
  - 这一附加信息称为子网掩码。  

子网掩码表示网络号与主机号之间的边界。  

例：  
`10.11.12.13/255.255.255.0`  

|IP 地址：|10.|1.|2.|3|
|---|---|---|---|---|
|子网掩码：|255.|255.|255.|0|

将上面的十进制转换成比特后:  
|IP 地址：|00001010.|00000001.|00000010.|00000011|
|---|---|---|---|---|
|子网掩码：|11111111.|11111111.|11111111.|00000000|

其中，子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号。  
这种写法太长，我们也可以把 1 的部分的比特数用十进制表示并写在 IP 地址的右侧。  
  - 写成`10.11.12.13/24`。

顺带一提，IP 地址中主机号部分的比特全部为 0 或者全部为 1 时代表两种特殊的含义。  
  - 主机号部分全部为 0 代表整个子网而不是子网中的某台设备；
  - 主机号部分全部为 1 代表向子网上所有设备发送包，即广播。

### 域名和 IP 地址并用的理由

TCP/IP 网络是通过 IP 地址来确定通信对象的，在网址中使用服务器名称而不是 IP 地址是因为服务器名称好记。  
而不用服务器名称来确定通信对象是因为 IP 地址长度为 4 字节即 32 比特，而域名最短几十个字节，最长甚至255字节，使用域名来确定定位会大大增加路由器的负担。  

于是，现在我们使用的方案是让人来使用名称，让路由器来使用 IP 地址。  
为了填补两者之间的障碍，需要有一个机制能够通过名称来查询 IP 地址，或者通过 IP 地址来查询名称，  
这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。这个机制就是 DNS。  

### Socket 库提供查询 IP 地址的功能

查询 IP 地址的方法非常简单，只要询问最近的 DNS 服务器“www.lab.glasscom.com 的 IP 地址是什么”就可以了，DNS 服务器会回答说“该服务器的 IP 地址为xxx.xxx.xxx.xxx”。  

#### DNS

##### 向 DNS 服务器发送查询消息

向 DNS 服务器发出查询，也就是向 DNS 服务器发送查询消息，并接收服务器返回的响应消息。  
换句话说，对于 DNS 服务器，我们的计算机上一定有相应的 DNS 客户端，而相当于 DNS 客户端的部分称为 DNS 解析器，或者简称解析器。  
通过 DNS 查询 IP 地址的操作称为域名解析，因此负责执行解析（resolution）这一操作的就叫解析器（resolver）了。  
  - 解析器实际上是一段程序，它包含在操作系统的 Socket 库中。  

###### Socket 库

库就是一堆通用程序组件的集合，其他的应用程序都需要使用其中的组件。  
  - 使用现成的组件搭建应用程序可以节省编程工作量；
  - 多个程序使用相同的组件可以实现程序的标准化。

Socket 库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是这个库中的其中一种程序组件。  
Socket 库是用于调用网络功能的程序组件集合。  

##### 通过解析器向 DNS 服务器发出查询

解析器的用法非常简单。Socket 库中的程序都是标准组件，只要从应用程序中进行调用就可以了。  
具体来说，在编写浏览器等应用程序的时候，只要写上解析器的程序名称以及 Web 服务器的域名就可以了，这样就完成了对解析器的调用。  

调用解析器后，解析器会向 DNS 服务器发送查询消息，然后 DNS 服务器会返回响应消息。  
响应消息中包含查询到的 IP 地址，解析器会取出IP地址，并将其写入浏览器指定的内存地址中。  
接下来，浏览器在向 Web 服务器发送消息时，只要从该内存地址取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统就可以了。  

根据域名查询 IP 地址时，浏览器会使用 Socket 库中的解析器。  

###### 解析器的内部原理

解析器内部是怎样工作的：  
1. 网络应用程序（在我们的场景中就是指浏览器）调用解析器时，程序的控制流程就会转移到解析器的内部；
2. 当控制流程转移到解析器后，解析器调用协议栈，控制流程再次转移，协议栈会执行发送消息的操作，然后会生成要发送给 DNS 服务器的查询消息并通过网卡发送给 DNS 服务器；
   - 解析器会根据 DNS 的规格，生成一条表示“请告诉我 www.lab.glasscom.com 的 IP 地址”的数据，并将它发送给 DNS 服务器；
   - 发送消息这个操作并不是由解析器自身来执行，而是要委托给操作系统内部的协议栈来执行。
3. 当DNS 服务器收到查询消息后，它会根据消息中的查询内容进行查询；
   - 如果要访问的Web 服务器已经在DNS 服务器上注册，那么这条记录就能够被找到，然后其 IP 地址会被写入响应消息并返回给客户端。
4. 接下来，消息经过网络到达客户端，再经过协议栈被传递给解析器；
5. 解析器读取出消息取出 IP 地址，并将 IP 地址传递给应用程序；
   - 实际上，解析器会将取出的 IP 地址写入应用程序指定的内存地址中。
6. 到这里，解析器的工作就完成了，控制流程重新回到应用程序（浏览器），现在应用程序已经能够从内存中取出 IP 地址了。

计算机的内部结构就是这样一层一层的。也就是说，很多程序组成不同的层次，彼此之间分工协作。  
当接到上层委派的操作时，本层的程序并不会完成所有的工作，而是会完成一部分工作，再将剩下的部分委派到下层来完成。  

顺带一提，向 DNS 服务器发送消息时，我们当然也需要知道 DNS 服务器的 IP 地址。只不过这个 IP 地址是作为 TCP/IP 的一个设置项目事先设置好的，不需要再去查询了。  
不同的操作系统中 TCP/IP 的设置方法也有差异，像 Windows 可以设置自动获得 DNS 服务器地址或主动分配一个，解析器会根据设置的 DNS 服务器 IP 地址来发送消息。  

####### 控制流程转移

一般来说，应用程序编写的操作内容是从上往下按顺序执行的，当到达需要调用解析器的部分时，对应的那一行程序就会被执行，应用程序本身的工作就会暂停。  
然后，Socket 库中的解析器开始运行，完成应用程序委托的操作。  
像这样，由于调用了其他程序，原本运行的程序进入暂停状态，而被调用的程序开始运行，这就是“控制流程转移”。  

## 全世界 DNS 服务器的大接力

### DNS 服务器的基本工作

DNS 服务器的基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响应。  
其中，来自客户端的查询消息包含以下 3 种信息：  
1. 域名；
   - 服务器、邮件服务器（邮件地址中@ 后面的部分）的名称。
2.  Class；
   - 在最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而Class 就是用来识别网络的信息；
   - 不过，如今除了互联网并没有其他的网络了，因此 Class 的值永远是代表互联网的 IN。
3. 记录类型。
   - 表示域名对应何种类型的记录。例如：
     - 当类型为 A 时，表示域名对应的是 IP 地址；
     - 当类型为 MX 时，表示域名对应的是邮件服务器；
     - 对于不同的记录类型，服务器向客户端返回的信息也会不同。

DNS 服务器上事先保存有前面这 3 种信息对应的记录数据，DNS 服务器就是根据这些记录查找符合查询请求的内容并对客户端作出响应的。  
DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址。  

例如，如果要查询 www.lab.glasscom.com 这个域名对应的 IP 地址，客户端会向 DNS 服务器发送包含以下信息的查询消息。  
（a） 域名 = www.lab.glasscom.com；  
（b） Class = IN；  
（c） 记录类型 = A。  
然后，DNS 服务器会从已有的记录中查找域名、Class 和记录类型全部匹配的记录。  

### 域名的层次结构

如果是在像公司内部网络这样Web 和邮件服务器数量有限的环境中，所有的信息都可以保存在一台 DNS 服务器中，其工作方式也就完全符合我们前面讲解的内容。  
然而，互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台 DNS 服务器中是不可能的，因此一定会出现在 DNS 服务器中找不到要查询的信息的情况。  

此时 DNS 服务器的工作方式：  
将信息分布保存在多台 DNS 服务器中，这些 DNS 服务器相互接力配合，从而查找出要查询的信息。  

#### 信息是如何在 DNS 服务器上注册并保存的

DNS 服务器中的所有信息都是按照域名以分层次的结构来保存的。  
DNS 中的域名都是用句点来分隔的，比如 www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已。  
在域名中，越靠右的位置表示其层级越高，比如 www.lab.glasscom.com 这个域名如果按照公司里的组织结构来说，大概就是“com 事业集团 glasscom 部 lab 科的www”这样。  
其中，相当于一个层级的部分称为域。因此，com 域的下一层是 glasscom 域，再下一层是 lab 域，再下面才是 www 这个名字。  

这种具有层次结构的域名信息会注册到 DNS 服务器中，而每个域都是作为一个整体来处理的。  
换句话说就是，一个域的信息是作为一个整体存放在 DNS 服务器中的，不能将一个域拆开来存放在多台 DNS 服务器中。  
不过，DNS 服务器和域之间的关系也并不总是一对一的，一台DNS 服务器中也可以存放多个域的信息。  

### 寻找相应的 DNS 服务器并获取 IP 地址

如何找到 DNS 服务器中存放的信息的关键在于如何找到我们要访问的 Web 服务器的信息归哪一台 DNS 服务器管。  
互联网中有数万台 DNS 服务器，肯定不能一台一台挨个去找，我们可以采用下面的办法。  

首先，将负责管理下级域的 DNS 服务器的 IP 地址注册到它们的上级 DNS 服务器中，然后上级 DNS 服务器的 IP 地址再注册到更上一级的 DNS 服务器中，以此类推。  
这样，我们就可以通过上级 DNS 服务器查询出下级 DNS 服务器的 IP 地址，也就可以向下级 DNS 服务器发送查询请求了。  

也就是说，负责管理 lab.glasscom.com 这个域的 DNS 服务器的 IP 地址需要注册到 glasscom.com 域的 DNS 服务器中，  
而 glasscom.com 域的 DNS 服务器的IP 地址又需要注册到 com 域的 DNS 服务器中。  

#### 根域

在前面的讲解中，似乎com、jp 这些域（称为顶级域）就是最顶层了，它们各自负责保存下级DNS 服务器的信息，但实际上并非如此。在互联网中，com 和jp 的上面还有一级域，称为根域。  
根域不像 com、jp 那样有自己的名字，因此在一般书写域名时经常被省略；  
如果要明确表示根域，应该像 www.lab.glasscom.com. 这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。  

不过，一般都不写最后那个句点，因此根域的存在往往被忽略，但根域毕竟是真实存在的，根域的 DNS 服务器中保管着 com、jp 等的 DNS 服务器的信息。  
由于上级 DNS 服务器保管着所有下级 DNS 服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的 DNS 服务器。  

除此之外还需要完成另一项工作，那就是将根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。  
这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。  
因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。  

分配给根域 DNS 服务器的 IP 地址在全世界仅有 13 个，而且这些地址几乎不发生变化，因此将这些地址保存在所有的 DNS 服务器中也并不是一件难事。  
实际上，根域 DNS 服务器的相关信息已经包含在 DNS 服务器程序的配置文件中了，因此只要安装了 DNS 服务器程序，这些信息也就被自动配置好了。  

#### 具体实现流程

假设我们要查询 www.lab.glasscom.com 这台 Web 服务器的相关信息。  

1. 客户端首先会访问最近的一台 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）；
2. 由于最近的 DNS 服务器中没有存放 www.lab.glasscom.com 这一域名对应的信息，所以我们需要从顶层开始向下查找。
   - 最近的 DNS 服务器中保存了根域 DNS 服务器的信息，因此它会将来自客户端的查询消息转发给根域 DNS 服务器
3. 根域服务器中也没有 www.lab.glasscom.com 这个域名，但根据域名结构可以判断这个域名属于 com 域，因此根域 DNS 服务器会返回它所管理的 com 域中的 DNS 服务器的 IP 地址；
4. 最近的 DNS 服务器又会向 com 域的 DNS 服务器发送查询消息；
5. com 域中也没有 www.lab.glasscom.com这个域名的信息，和刚才一样，com 域服务器会返回它下面的 glasscom.com 域的 DNS 服务器的 IP 地址；
6. 以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标 DNS 服务器；
7. 只要向目标 DNS 服务器发送查询消息，就能够得到我们需要的答案，也就是 www.lab.glasscom.com 的 IP 地址了。
8. 收到客户端的查询消息之后，DNS 服务器会按照前面的方法来查询 IP 地址，并返回给客户端；
9. 这样，客户端就知道了 Web 服务器的 IP 地址，也就能够对其进行访问了。

### 通过缓存加快 DNS 服务器的响应

以上展示的是基本原理，与真实互联网中的工作方式还是有一些区别的。  
在真实的互联网中，一台 DNS 服务器可以管理多个域的信息，现实中上级域和下级域有可能共享同一台 DNS 服务器。  
在这种情况下，访问上级 DNS 服务器时就可以向下跳过一级 DNS 服务器，直接返回再下一级 DNS 服务器的相关信息。  

此外，有时候并不需要从最上级的根域开始查找，因为 DNS 服务器有一个缓存功能，可以记住之前查询过的域名。  
如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。  
相比每次都从根域找起来说，缓存可以减少查询所需的时间。  
并且，当要查询的域名不存在时，“不存在”这一响应结果也会被缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。  

这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。  
因此，DNS 服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。  
而且，在对查询进行响应时，DNS 服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的 DNS 服务器。  

## 委托协议栈发送消息

### 数据收发操作概览

知道了 IP 地址之后，就可以委托操作系统内部的协议栈向这个目标 IP 地址，也就是我们要访问的 Web 服务器发送消息了。  
要发送给 Web 服务器的 HTTP 消息是一种数字信息（digital data），因此也可以说是委托协议栈来发送数字信息。  
  - 收发数字信息这一操作不仅限于浏览器，对于各种使用网络的应用程序来说都是共通的；
  - 因此，这一操作的过程也不仅适用于 Web，而是适用于任何网络应用程序。

和向 DNS 服务器查询 IP 地址的操作一样，收发数字信息这一操作也需要使用 Socket 库中的程序组件。  
不过，查询 IP 地址只需要调用一个程序组件就可以了，而这里需要按照指定的顺序调用多个程序组件，这个过程有点复杂。  
发送数据是一系列操作相结合来实现的。  

使用 Socket 库来收发数据的操作过程，简单来说，就像收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。  
我们可以把数据通道想象成一条管道，将数据从一端送入管道，数据就会到达管道的另一端然后被取出。  
  - 数据可以从任何一端被送入管道，数据的流动是双向的。
  - 不过，这并不是说现实中真的有这么一条管道，只是为了帮助大家理解数据收发操作的全貌。
收发数据的整体思路就是这样，但还有一点也非常重要。  
在进行收发数据操作之前，双方需要先建立起这条管道才行。  
  - 建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字。我们需要先创建套接字，然后再将套接字连接起来形成管道。  

实际的过程是下面这样的：  
1. 服务器一方先创建套接字，然后等待客户端向该套接字连接管道；
   - 服务器程序一般会在启动后就创建好套接字并等待客户端连接管道。
2. 当服务器进入等待状态时，客户端就可以连接管道了；
   - 客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务器端的套接字上。
3. 当双方的套接字连接起来之后，通信准备就完成了；
4. 接下来，只要将数据送入套接字就可以收发数据了；
5. 当数据全部发送完毕之后，连接的管道将会被断开；
   - 管道在连接时是由客户端发起的，但在断开时可以由客户端或服务器任意一方发起。
   - 其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。
6. 到此为止，通信操作就结束了。

综上所述，收发数据的操作分为若干个阶段，可以大致总结为以下 4 个。  
1. 创建套接字（创建套接字阶段）；
2. 将管道连接到服务器端的套接字上（连接阶段）；
3. 收发数据（通信阶段）；
4. 断开管道并删除套接字（断开阶段）。

在每个阶段，Socket 库中的程序组件都会被调用来执行相关的数据收发操作。  
前面这 4 个操作都是由操作系统中的协议栈来执行的，浏览器等应用程序并不会自己去做连接管道、放入数据这些工作，而是委托协议栈来代劳。  
本章只介绍“委托”这个操作。关于协议栈收到委托之后具体是如何连接管道和放入数据的将在第 2 章介绍。  

此外，这些委托的操作都是通过调用 Socket 库中的程序组件来执行的。  
但这些数据通信用的程序组件其实仅仅充当了一个桥梁的角色，并不执行任何实质性的操作，应用程序的委托内容最终会被原原本本地传递给协议栈。  
因此，我们无法形象地展示这些程序组件到底完成了怎样的工作，与其勉强强调 Socket 库的存在，还不如将 Socket 库和协议栈看成一个整体并讲解它们的整体行为让人更容易理解。  
因此，后文将会采用这样的讲法。不过，请大家不要忘记 Socket 库这一桥梁的存在。  

### 创建套接字阶段

应用程序（浏览器）委托收发数据的过程关键点就是像对 DNS 服务器发送查询一样，  
调用 Socket 库中的特定程序组件访问 DNS 服务器时我们调用的是一个叫作 gethostbyname 的程序组件（也就是解析器），而这一次则需要按照一定的顺序调用若干个程序组件。  

首先是套接字创建阶段。客户端创建套接字的操作非常简单，只要调用 Socket 库中的 socket 程序组件就可以了。  
  - 调用 Socket 库中的程序组件的思路和调用解析器是一样的，调用解析器是在程序中直接写解析器的程序名`gethostbyname`即可；  
  - 和调用解析器一样，调用 socket 之后，控制流程会转移到socket 内部并执行创建套接字的操作，完成之后控制流程又会被移交回应用程序。
套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中；  
  - 描述符是用来识别不同的套接字的；
  - 因为同一台计算机上可能同时存在多个套接字，在这样的情况下，我们就需要一种方法来识别出某个特定的套接字，这种方法就是描述符。
当创建套接字后，我们就可以使用这个套接字来执行收发数据的操作了。  
  - 这时，只要我们出示描述符，协议栈就能够判断出我们希望用哪一个套接字来连接或者收发数据了；
  - 应用程序是通过“描述符”这一类似号码牌的东西来识别套接字的。

### 连接阶段：把管道接上去

接下来，我们需要委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序通过调用 Socket 库中的名为 connect 的程序组件来完成这一操作。  
这里的要点是当调用 connect 时，需要指定描述符、服务器 IP 地址和端口号这 3 个参数。  

1. 描述符；
   - 就是在创建套接字的时候由协议栈返回的那个描述符。
     - connect 会将应用程序指定的描述符告知协议栈，然后协议栈根据这个描述符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接的操作。
2. 服务器 IP 地址；
   - 就是通过 DNS 服务器查询得到的我们要访问的服务器的 IP 地址。
3. 端口号。
   - IP 地址是为了区分网络中的各个计算机而分配的数值。因此，只要知道了 IP 地址，我们就可以识别出网络上的某台计算机；
   - 但是，连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行，而仅凭 IP 地址是无法做到这一点的；
   - 当同时指定 IP 地址和端口号时，就可以明确识别出某台具体的计算机上的某个具体的套接字。

#### 端口号

能否使用描述符来识别套接字？  
描述符是和委托创建套接字的应用程序进行交互时使用的，并不是用来告诉网络连接的另一方的，因此另一方并不知道这个描述符。  
同样地，客户端也无法知道服务器上的描述符。因此，客户端也无法通过服务器端的描述符去确定位于服务器上的某一个套接字。  

所以，我们需要另外一个对客户端也同样适用的机制，而这个机制就是端口号。  
如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。  

##### 实现规定好的端口号

服务器上所使用的端口号是根据应用的种类事先规定好的，仅此而已。比如 Web 是 80 号端口，电子邮件是 25 号端口。  
关于端口号，我们将在第 6 章探索服务器内部工作的时候进行介绍，这里大家只要这样记住就行了：只要指定了事先规定好的端口号，就可以连接到相应的服务器程序的套接字。  
也就是说，浏览器访问 Web 服务器时使用 80 号端口，这是已经规定好的。  

端口号的规则是全球统一的，为了避免重复和冲突，端口号和 IP 地址一样都是由 IANA（Internet Assigned Number Authority，互联网编号管理局）这一组织来统一管理的。  

##### 客户端的端口

既然确定连接对象的套接字需要使用端口号，那么服务器也得知道客户端的套接字号码才行吧，这个问题是怎么解决的呢？  
事情是这样的，首先，客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。  
接下来，当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。  
  - 这部分内容我们会在第2 章探索协议栈内部工作时进行介绍。
  - 在创建套接字时，服务器也可以自行指定端口号，但一般并不常用。

总而言之，就是当调用 connect 时，协议栈就会执行连接操作。  
当连接成功后，协议栈会将对方的 IP 地址和端口号等信息保存在套接字中，这样我们就可以开始收发数据了。  

### 通信阶段：传递消息

当套接字连接起来之后，剩下的事情就简单了。只要将数据送入套接字，数据就会被发送到对方的套接字中。
当然，应用程序无法直接控制套接字，因此还是要通过 Socket 库委托协议栈来完成这个操作。
这个操作需要使用 write 这个程序组件，具体过程如下：
1. 当调用 write 时，需要指定描述符和发送数据，然后协议栈就会将数据发送到服务器。
   - 应用程序需要在内存中准备好要发送的数据，根据用户输入的网址生成的 HTTP 请求消息就是我们要发送的数据。
   - 由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。
2. 当发送数据会通过网络到达我们要访问的服务器，服务器执行接收操作，解析收到的数据内容并执行相应的操作，向客户端返回响应消息；
3. 当消息返回后，需要执行的是接收消息的操作。
   - 接收消息的操作是通过 Socket 库中的 read 程序组件委托协议栈来完成的。
   - 调用 read 时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。
4. 当服务器返回响应消息时，read 就会负责将接收到的响应消息存放到接收缓冲区中。
   - 由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。

### 断开阶段：收发数据结束

当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需要调用Socket 库的 close 程序组件进入断开阶段。  
最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。  

断开的过程如下：  
1. Web 使用的 HTTP 协议规定，当 Web 服务器发送完响应消息之后，应该主动执行断开操作，因此 Web 服务器会首先调用 close 来断开连接。
2. 断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。
3. 接下来，当浏览器调用 read 执行接收数据操作时，read 会告知浏览器收发数据操作已结束，连接已经断开。
4. 浏览器得知后，也会调用 close 进入断开阶段。

这就是 HTTP 的工作过程。HTTP 协议将HTML 文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。  
因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。  
对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。  
在HTTP 版本1.1 中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。  

> 本章我们探索了浏览器与 Web 服务器之间收发消息的过程，但实际负责收发消息的是协议栈、网卡驱动和网卡，只有这 3 者相互配合，数据才能够在网络中流动起来。
  下一章我们将对这一部分进行探索。

>	zongjie
	1. 浏览器解析URL，并根据 HTTP 协议进行客户端和服务器之间交互的消息内容和步骤
	2. 生成请求信息：包括方法和 URI
	3. 解析器调用协议栈，协议栈向最近的 DNS 服务器发送查询 Web 服务器的 IP 地址的信息
	4. 一层层查下去直到查到对应域名的 IP 地址
	5. 信息传回客户端，协议栈传回解析器，解析器传回应用程序
	6. 得知 IP 地址，客户端根据端口、描述符、IP 地址找到对应 IP 地址的套接字，
	7. 告知对应设备客户端的套接字信息
	8. 两个套接字连接
	9. 使用 write 发送信息进入客户端的套接字传送到服务器的套接字
	10. 服务器发回信息，使用 read 把返回信息放到接收缓存区
	11. 发送结束服务器断开，接着客户端断开，接着浏览器断开

# 用电信号传输 TCP/IP 数据

## 热身问答

1. 一般情况下，以太网的头部（网络包开头的控制信息）格式并非遵循国际标准（IEEE802.3/802.2），而是遵循一个更古老的规格（以太网第 2 版，又称 DIX 规格），  
   相对地，国际标准（IEEE802.3/802.2）的头部格式由于长度太长、效率降低而没有普及。  
2. 最早的 TCP/IP 协议原型设计相当于现在的 TCP 和 IP 合在一起的样子，后来才拆分成为 TCP 和 IP 两个协议。  
3. 在网络包出现之前，通信都是像电话一样把线路连接起来进行的。但是，连接线路的通信方式只能和固定的对象进行通信，无法发挥计算机可以处理多种工作的特点。  
   为了解决这个问题，人们设计出了使用网络包来进行通信的方式。  

## 看点

### 创建套接字

从应用程序收到委托后，协议栈通过 TCP 协议收发数据的操作可以分为 4 个阶段。  
首先是创建套接字，在这个阶段，我们将介绍协议栈的内部结构、套接字的实体，以及创建套接字的操作过程。  

### 连接服务器

接下来是客户端套接字向服务器套接字进行连接的阶段。  
我们将介绍“连接”具体是进行怎样的操作，在这个过程中协议栈到底是如何工作的，以及客户端和服务器是如何进行交互的。  

### 收发数据

两端的套接字完成连接之后，就进入收发消息的阶段了。在这个阶段，协议栈会将从应用程序收到的数据切成小块并发送给服务器。  
考虑到通信过程中可能会出错导致网络包丢失，协议栈还需要确认切分出的每个包是否已经送达服务器，  对于没有送达的包要重新发送一次。  

### 从服务器断开连接并删除套接字

收发消息的操作全部结束之后，接下来要断开服务器的连接并删除套接字。  
断开操作的本质是当消息收发完成后客户端和服务器相互进行确认的过程，但这个过程并不只是相互确认并删除套接字那么简单。  

### IP 与以太网的包收发操作

在介绍 TCP 协议收发消息的操作之后，我们再来看看实际的网络包是如何进行收发的。  
协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号或者光信号发送出去。  

### 用 UDP 协议收发数据的操作

TCP 协议有很多方便的功能，比如网络包出错丢失时可以重发，因此很多应用程序都是使用 TCP 协议来收发数据的，但这些方便的功能也有帮倒忙的时候。  
在这种情况下我们还有另外一种叫 UDP 的协议。这里我们将介绍 UDP 的必要性以及它与 TCP 的差异。  

## 创建套接字

本章将说明操作系统中的网络控制软件（协议栈）和网络硬件（网卡）是如何将浏览器的消息发送给服务器的。  

### 协议栈的内部结构

和浏览器不同的是，协议栈的工作我们从表面上是看不见的，可能比较难以想象。  

协议栈的内部分为几个部分，分别承担不同的功能。  
1. 协议栈的上半部分有两块；
   - 分别是负责用 TCP 协议收发数据的部分；
   - 负责用 UDP 协议收发数据的部分；
   - TCP 协议和 UDP 协议会接受应用程序的委托执行收发数据的操作；
   - 像浏览器、邮件等一般的应用程序都是使用 TCP 收发数据的，而像 DNS 查询等收发较短的控制数据的时候则使用 UDP。  
2. 下面一半是用 IP 协议控制网络包收发操作的部分。
  - 在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由 IP 来负责的；
  - 此外，IP 中还包括 ICMP 协议和 ARP 协议；
  - ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息；
  - ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

#### TCP/IP 软件的分层结构

TCP/IP 软件采用分层结构，包括应用程序、操作系统、驱动程序、硬件四个部分，四部分由上而下。  
上面的部分会向下面的部分委派工作，下面的部分接受委派的工作并实际执行。  
当然，这一上下关系只是一个总体的规则，其中也有一部分上下关系不明确，或者上下关系相反的情况，所以也不必过于纠结。  

1. 最上面的部分是网络应用程序；
   - 也就是浏览器、电子邮件客户端、Web 服务器、电子邮件服务器等程序，它们会将收发数据等工作委派给下层的部分来完成。
   - 除了浏览器之外，其他应用程序在网络上收发数据的操作也都是类似上面这样的
     - 也就是说，尽管不同的应用程序收发的数据内容不同，但收发数据的操作是共通的。
     - 因此，下面介绍的内容不仅适用于浏览器，也适用于各种应用程序。
2. 应用程序的下面是 Socket 库，其中包括解析器，解析器用来向 DNS 服务器发出查询；
3. 再下面就是操作系统内部了，其中包括协议栈；
4. IP 下面的网卡驱动程序负责控制网卡硬件，
5. 最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。

### 套接字的实体就是通信控制信息

在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP 地址、端口号、通信操作的进行状态等。  
本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。  

协议栈在执行操作时需要参阅这些控制信息。  
例如，在发送数据时，需要看一看套接字中的通信对象 IP 地址和端口号，以便向指定的 IP 地址和端口发送数据。  
在发送数据之后，协议栈需要等待对方返回收到数据的响应信息，但数据也可能在中途丢失，永远也等不到对方的响应。  
在这样的情况下，我们不能一直等下去，需要在等待一定时间之后重新发送丢失的数据，这就需要协议栈能够知道执行发送数据操作后过了多长时间。  
为此，套接字中必须要记录是否已经收到响应，以及发送数据后经过了多长时间，才能根据这些信息按照需要执行重发操作。  

上面说的只是其中一个例子。套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。  
协议栈是根据套接字中记录的控制信息来工作的。  

### 调用 socket 时的操作

当浏览器调用socket、connect 等 Socket 库中的程序组件时，协议栈内部是如何工作的。

1. 首先是创建套接字的阶段；
应用程序调用 socket 申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。  
在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。  
  - 用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们先要开辟出这样一块空间来，这相当于为控制信息准备一个容器；
  - 但光一个容器并没有什么用，还需要往里面存入控制信息。
套接字刚刚创建时，数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。  
到这里，创建套接字的操作就完成了。  

2. 接下来，需要将表示这个套接字的描述符告知应用程序；  
   - 描述符相当于用来区分协议栈中的多个套接字的号码牌。

3. 收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。
由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息。  
这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。  

## 连接服务器

### 连接是什么意思

创建套接字之后，应用程序（浏览器）就会调用 connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。  
连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作。  
  - 所谓控制信息，就是用来控制数据收发操作所需的一些信息，IP 地址和端口号就是典型的例子。

网线是一直连接着的，随时都有信号从中流过，如果通信过程只是将数据转换为电信号，那么这一操作随时都可以进行。  
不过，在这个时间点，也就是套接字刚刚创建完成时，当应用程序委托发送数据的时候，协议栈会如何操作呢？  

对于客户端方面来说，套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。  
在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。  
浏览器可以根据网址来查询服务器的 IP 地址，而且根据规则也知道应该使用 80 号端口，但只有浏览器知道这些必要的信息是不够的；  
因为在调用 socket 创建套接字时，这些信息并没有传递给协议栈。  
因此，我们需要把服务器的 IP 地址和端口号等信息告知协议栈，这是连接操作的目的之一。  

此时服务器上也会创建套接字，但服务器上的协议栈和客户端一样，只创建套接字是不知道应该和谁进行通信的。  
而且，和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁，这样下去永远也没法开始通信。  
于是，我们需要让客户端向服务器告知必要的信息，比如“我想和你开始通信，我的IP 地址是xxx.xxx.xxx.xxx，端口号是yyyy。”  
可见，客户端向服务器传达开始通信的请求，也是连接操作的目的之一。  

连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备。  
此外，当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的。  

上面这些就是“连接”这个词代表的具体含义。  

### 负责保存控制信息的头部

控制信息其实可以大体上分为两类。  

第一类是客户端和服务器相互联络时交换的控制信息。  
这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程中都需要，  
这些内容在 TCP 协议的规格中进行了定义。  

这些字段是固定的，在连接、收发、断开等各个阶段中，每次客户端和服务器之间进行通信时，都需要提供这些控制信息。  
具体来说，这些信息会被添加在客户端与服务器之间传递的网络包的开头。在连接阶段，由于数据收发还没有开始，所以网络包中没有实际的数据，只有控制信息。  

这些控制信息位于网络包的开头，因此被称为头部。
此外，以太网和 IP 协议也有自己的控制信息，这些信息也叫头部，为了避免各种不同的头部发生混淆，我们一般会记作 TCP 头部、以太网头部、IP 头部。
客户端和服务器在通信中会将必要的信息记录在头部并相互确认。  
头部的信息非常重要，理解了头部各字段的含义，就等于理解了整个通信的过程。  

TCP 头部格式：  
|字段名称|长度（比特）|含义|
|---|---|---|
|发送方端口号|16|发送网络包的程序的端口号|
|接收方端口号|16|网络包的接收方程序的端口号|
|序号（发送数据的顺序编号）|32|发送方告知接收方该网络包发送的数据相当于所有发送数据的第几个字节|
|ACK 号（接收数据的顺序编号）|32|接收方告知发送方接收方已经收到了所有数据的第几个字节。其中，ACK 是acknowledge 的缩写|
|数据偏移量|4|表示数据部分的起始位置，也可以认为表示头部的长度|
|保留|6|该字段为保留，现在未使用|
|控制位|6|该字段中的每个比特分别表示以下通信控制含义。URG：表示紧急指针字段有效; ACK：表示接收数据序号字段有效，一般表示数据已被接收方收到; PSH：表示通过 flush 操作发送的数据; RST：强制断开连接，用于异常中断的情况; SYN：发送方和接收方相互确认序号，表示连接操作; FIN：表示断开连接|
|窗口|16|接收方告知发送方窗口大小（即无需等待确认可一起发送的数据量）|
|校验和|16|用来检查是否出现错误|
|紧急指针|16|表示应紧急处理的数据位置|
|可选字段|可变长度|除了上面的固定头部字段之外，还可以添加可选字段，但除了连接操作之外，很少使用可选字段|

控制信息的第二类是保存在套接字中，用来控制协议栈操作的信息。  
应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。  

我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的，因此，“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同，但这并没有什么问题。  
因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。  
例如，Windows 和 Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同。  
但即便如此，两种系统之间依然能够互相通信，同样地，计算机和手机之间也能够互相通信。  
正如前面所说，协议栈的实现不同，因此我们无法具体说明协议栈里到底保存了哪些控制信息，但可以用命令来显示一些重要的套接字控制信息，  
这些信息无论何种操作系统的协议栈都是共通的，通过理解这些重要信息，就能够理解协议栈的工作方式了。  

> 网络包的结构是“以太网和 IP 的控制信息” + “ TCP 的控制信息” + “数据块”。

### 连接操作的实际过程

连接的具体操作过程是从应用程序调用Socket 库的connect 开始的。  
`connect（< 描述符>, < 服务器IP 地址和端口号>, …）`  
上面的调用提供了服务器的 IP 地址和端口号，这些信息会传递给协议栈中的 TCP 模块。  
然后，TCP 模块会与该 IP 地址对应的对象，也就是与服务器的 TCP 模块交换控制信息，这一交互过程包括下面几个步骤。  

1. 客户端先创建一个包含表示开始数据收发操作的控制信息的头部；
   - 头部包含很多字段，这里要关注的重点是发送方和接收方的端口号；
   - 这样，客户端（发送方）的套接字就准确找到了服务器（接收方）的套接字，也就是搞清楚了我应该连接哪个套接字；
   - 我们将头部中的控制位的 SYN 比特设置为 1，大家可以认为它表示连接。此外还需要设置适当的序号和窗口大小。
2. 当 TCP 头部创建好之后，接下来 TCP 模块会将信息传递给 IP 模块并委托它进行发送；
3. IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器；
4. 然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块，服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字；
   - 也就是说，从处于等待连接状态的套接字中找到与 TCP 头部中记录的端口号相同的套接字就可以了。
5. 当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接；
6. 上述操作完成后，服务器的 TCP 模块会返回响应，这个过程和客户端一样，需要在 TCP 头部中设置发送方和接收方端口号以及 SYN 比特；
   - 此外，在返回响应时还需要将 ACK 控制位设为1，这表示已经接收到相应的网络包；
   - 网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达，而设置 ACK 比特就是用来进行这一确认的；
   - 客户端向服务器发送第一个网络包时，由于服务器还没有接收过网络包，所以需要将 ACK 比特设为0。
7. 接下来，服务器 TCP 模块会将 TCP 头部传递给 IP 模块，并委托 IP 模块向客户端返回响应；
8. 然后，网络包就会返回到客户端，通过 IP 模块到达 TCP 模块，并通过 TCP 头部的信息确认连接服务器的操作是否成功；
   - 如果 SYN 为 1 则表示连接成功，这时会向套接字中写入服务器的 IP 地址、端口号等信息，同时还会将状态改为连接完毕；
   - 到这里，客户端的操作就已经完成。
9. 刚才服务器返回响应时将 ACK 比特设置为 1，相应地，客户端也需要将 ACK 比特设置为 1 并发回服务器，告诉服务器刚才的响应包已经收到。
   - 当这个服务器收到这个返回包之后，连接操作才算全部完成。

头部和套接字之间的关系是？

## 收发数据

### 将 HTTP 请求消息交给协议栈

当控制流程从 connect 回到应用程序之后，接下来就进入数据收发阶段了。  
数据收发操作是从应用程序调用 write 将要发送的数据交给协议栈开始的，协议栈收到数据后执行发送操作，这一操作包含如下要点：  

1. 协议栈并不关心应用程序传来的数据是什么内容；  
   - 应用程序在调用 write 时会指定发送数据的长度，在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已。

2. 协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。  
   - 这样做是有道理的。应用程序交给协议栈发送的数据长度是由应用程序本身来决定的，不同的应用程序在实现上有所不同。
     - 有些程序会一次性传递所有的数据，有些程序则会逐字节或者逐行传递数据；
     - 总之，一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为；
     - 在这样的情况下，如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。

至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的：  

1. 每个网络包能容纳的数据长度；  
   - 协议栈会根据一个叫作MTU（Maximum Transmission Unit，最大传输单元）的参数来进行判断。
     - MTU 表示一个网络包的最大长度，在以太网中一般是1500 字节。
   - MTU 是包含头部的总长度，因此需要从MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作MSS（Maximum Segment Size，最大分段大小）。
   - 当从应用程序收到的数据长度超过或者接近MSS 时再发送出去，就可以避免发送大量小包的问题了。

2. 时间。
   - 当应用程序发送数据的频率不高的时候，如果每次都等到长度接近MSS 时再发送，可能会因为等待时间太长而造成发送延迟，
     - 这种情况下，即便缓冲区中的数据长度没有达到MSS，也应该果断发送出去。
   - 为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去，这个时间并没有多长，是以毫秒为单位来计算的。

判断要素就是这两个，但它们其实是互相矛盾的。  
- 如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟；
- 如果时间优先，那么延迟时间会变少，但又会降低网络的效率。
- 因此，在进行发送操作时需要综合考虑这两个要素以达到平衡。
不过，TCP 协议规格中并没有告诉我们怎样才能平衡，因此实际如何判断是由协议栈的开发者来决定的，  
也正是由于这个原因，不同种类和版本的操作系统在相关操作上也就存在差异。  

正如前面所说，如果仅靠协议栈来判断发送的时机可能会带来一些问题，因此协议栈也给应用程序保留了控制发送时机的余地。  
应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。  
像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。  

### 对较大的数据进行拆分

HTTP 请求消息一般不会很长，一个网络包就能装得下，  
但如果其中要提交表单数据，长度就可能超过一个网络包所能容纳的数据量，比如在博客或者论坛上发表一篇长文就属于这种情况。  

这种情况下，发送缓冲区中的数据就会超过 MSS 的长度，这时我们当然不需要继续等待后面的数据了。  
发送缓冲区中的数据会被以 MSS 长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。  
根据发送缓冲区中的数据拆分的情况，当判断需要发送这些数据时，就在每一块数据前面加上 TCP 头部，并根据套接字中记录的控制信息标记发送方和接收方的端口号，  
然后交给 IP 模块来执行发送数据的操作，IP 模块会在网络包前面添加 IP 头部和以太网的 MAC 头部后发送网络包。  

### 使用 ACK 号确认网络包已收到

到这里，网络包已经装好数据并发往服务器了，但数据发送操作还没有结束。  
TCP 具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作。  

确认的原理：  

首先，TCP 模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在 TCP 头部中，“序号”字段就是派在这个用场上的。  
然后，发送数据的长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。  
有了上面两个数值，我们就可以知道发送的数据是从第几个字节开始，长度是多少了。  

通过这些信息，接收方还能够检查收到的网络包有没有遗漏。  
例如，假设上次接收到第 1460 字节，那么接下来如果收到序号为 1461 的包，说明中间没有遗漏；但如果收到的包序号为 2921，那就说明中间有包遗漏了。  
像这样，如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入 TCP 头部的 ACK 号中发送给发送方。  
  - 返回 ACK 号时，除了要设置 ACK 号的值以外，还需要将控制位中的 ACK 比特设为 1，这代表 ACK 号字段有效，接收方也就可以知道这个网络包是用来告知 ACK 号的。
这个返回 ACK 号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据。  
  - 在实际的通信中，序号并不是从 1 开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。
    - 但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。

> 在刚才讲过的连接过程中，有一个将 SYN 控制位设为 1 并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。  
  实际上，在将 SYN 设为1 的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值 SYN 为 1 表示进行连接，  
  这是因为将 SYN 设为 1 并告知初始序号这一操作仅在连接过程中出现，因此发送 SYN 为 1 的网络包就表示发起连接的意思。  
  实际上，SYN 是 Synchronize（同步）的缩写，意思是通过告知初始序号使通信双方保持步调一致，以便完成后续的数据收发检查，这才是SYN 原本的含义。  

前面介绍了通过序号和 ACK 号来进行数据确认的思路，但仅凭这些还不够。  
因为刚刚只考虑了单向的数据传输，但 TCP 数据收发是双向的，在客户端向服务器发送数据的同时，服务器也会向客户端发送数据，因此必须要想办法应对这样的情况。  
不过，这其实也不难，只要增加一种左右相反的情形就可以了。  
首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算 ACK 号并返回给客户端。  
相反地，服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算 ACK 号并返回给服务器。  
此外，客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。  

#### 实际工作流程

1. 首先，客户端在连接时需要计算出与从客户端到服务器方向通信相关的序号初始值，并将这个值发送给服务器；
2. 接下来，服务器会通过这个初始值计算出 ACK 号并返回给客户端，同时，服务器也需要计算出与从服务器到客户端方向通信相关的序号初始值，并将这个值发送给客户端；
   - 初始值有可能在通信过程中丢失，因此当服务器收到初始值后需要返回 ACK 号作为确认。
3. 接下来像刚才一样，客户端也需要根据服务器发来的初始值计算出 ACK 号并返回给服务器；
4. 到这里，序号和 ACK 号都已经准备完成了，接下来就可以进入数据收发阶段了。

数据收发操作本身是可以双向同时进行的，但 Web 中是先由客户端向服务器发送请求，序号也会跟随数据一起发送；  
然后，服务器收到数据后再返回 ACK 号；  
从服务器向客户端发送数据的过程则正好相反。  

TCP 采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的 ACK 号，那么就重新发送这些包。  
通过这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）。  
反过来说，有了这一机制，我们就不需要在其他地方对错误进行补救了。  

因此，网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。  
应用程序也是一样，因为采用 TCP 传输，即便发生一些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好了。  

不过，如果发生网络中断、服务器宕机等问题，那么无论 TCP 怎样重传都不管用。  
这种情况下，无论如何尝试都是徒劳，因此 TCP 会在尝试几次重传无效之后强制结束通信，并向应用程序报错。  

### 根据网络包平均往返时间调整 ACK 号等待时间

返回 ACK 号的等待时间（这个等待时间叫超时时间）。  

当网络传输繁忙时就会发生拥塞，ACK 号的返回会变慢，这时我们就必须将等待时间设置得稍微长一点，否则可能会发生已经重传了包之后，前面的 ACK 号才姗姗来迟的情况。  
这样的重传是多余的，看上去只是多发一个包而已，但它造成的后果却没那么简单。  
- 因为 ACK 号的返回变慢大多是由于网络拥塞引起的，因此如果此时再出现很多多余的重传，对于本来就很拥塞的网络来说无疑是雪上加霜；
- 不过如果某一个包被重复发送多次，接收方可以根据序号判断出这个包是重复的，因此并不会造成网络异常。

但如果等待时间过长，那么包的重传就会出现很大的延迟，也会导致网络速度变慢。  

等待时间需要设为一个合适的值，不能太长也不能太短，但这并不容易。  
根据服务器物理距离的远近，ACK 号的返回时间也会产生很大的波动，而且我们还必须考虑到拥塞带来的影响。  
- 例如，在公司里的局域网环境下，几毫秒就可以返回 ACK 号，但在互联网环境中，当遇到拥塞时需要几百毫秒才能返回ACK 号也并不稀奇。

正因为波动如此之大，所以将等待时间设置为一个固定值并不是一个好办法。  
因此，TCP 采用了动态调整等待时间的方法，这个等待时间是根据 ACK 号返回所需的时间来判断的。  
- 具体来说，TCP 会在发送数据的过程中持续测量ACK 号的返回时间，
  - 如果ACK 号返回变慢，则相应延长等待时间；
  - 相对地，如果ACK 号马上就能返回，则相应缩短等待时间。
- 由于计算机的时间测量精度较低，ACK 返回时间过短时无法被正确测量，因此等待时间有一个最小值，这个值在每个操作系统上不一样，基本上是在0.5 秒到1 秒之间。

### 使用窗口有效管理 ACK 号

每发送一个包就等待一个 ACK 号的方式是最简单也最容易理解的，但在等待 ACK 号的这段时间中，如果什么都不做那实在太浪费了。  
为了减少这样的浪费，TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作。  
- 所谓滑动窗口，就是在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。
- 这样一来，等待 ACK 号的这段时间就被有效利用起来了。

虽然这样做能够减少等待 ACK 号时的时间浪费，但有一些问题需要注意。  
在一来一回方式中，接收方完成接收操作后返回 ACK 号，然后发送方收到 ACK 号之后才继续发送下一个包，因此不会出现发送的包太多接收方处理不过来的情况。  
但如果不等返回 ACK 号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况。  

具体解释一下。  
当接收方的 TCP 收到包后，会先将数据存放到接收缓冲区中。  
然后，接收方需要计算 ACK 号，将数据块组装起来还原成原本的数据并传递给应用程序，如果这些操作还没完成下一个包就到了也不用担心，因为下一个包也会被暂存在接收缓冲区中。  
如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。  
缓冲区溢出之后，后面的数据就进不来了，因此接收方就收不到后面的包了，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力。  

可以通过下面的方法来避免这种情况的发生。  
首先，接收方需要告诉发送方自己最多能接收多少数据；  
然后发送方根据这个值对数据发送操作进行控制；  
这就是滑动窗口方式的基本思路。  

#### 滑动窗口的具体工作方式

接收方将数据暂存到接收缓冲区中并执行接收操作；  
当接收操作完成后，接收缓冲区中的空间会被释放出来，也就可以接收更多的数据了；  
这时接收方会通过TCP 头部中的窗口字段将自己能接收的数据量告知发送方；  
这样一来，发送方就不会发送过多的数据，导致超出接收方的处理能力了。  

接收方在收到数据之后马上就会开始进行处理，如果接收方的性能高，处理速度比包的到达速率还快，缓冲区马上就会被清空，并通过窗口字段告知发送方。  

能够接收的最大数据量称为窗口大小。  

### ACK 与窗口的合并

要提高收发数据的效率，还需要考虑另一个问题，那就是返回 ACK 号和更新窗口的时机。

首先，对于更新窗口大小的时机；
当收到的数据刚刚开始填入缓冲区时，其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度。
因此，更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候。
  - 这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作，
    - 因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机。

当接收方收到数据时，如果确认内容没有问题，就应该向发送方返回 ACK 号，因此我们可以认为收到数据之后马上就应该进行这一操作。

如果将前面两个因素结合起来看：  
首先，发送方的数据到达接收方，在接收操作完成之后就需要向发送方返回 ACK 号，而再经过一段时间，当数据传递给应用程序之后才需要更新窗口大小。

但如果根据这样的设计来实现，每收到一个包，就需要向发送方分别发送 ACK 号和窗口更新这两个单独的包。
这样一来，接收方发给发送方的包就太多了，导致网络效率下降。
因此，接收方在发送ACK 号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了。

举些例子：
- 在等待发送 ACK 号的时候正好需要更新窗口，这时就可以把 ACK 号和窗口更新放在一个包里发送，从而减少包的数量；
- 当需要连续发送多个 ACK 号时，也可以减少包的数量，只要发送最后一个ACK 号就可以了，中间的可以全部省略；
  - 这是因为 ACK 号表示的是已收到的数据量，也就是说，它是告诉发送方目前已接收的数据的最后位置在哪里，
- 当需要连续发送多个窗口更新时也可以减少包的数量，这种情况和 ACK 号一样，可以省略中间过程，只要发送最终的结果就可以了。
  - 连续发生窗口更新说明应用程序连续请求了数据，接收缓冲区的剩余空间连续增加。

### 接收 HTTP 响应消息

至此讲解完协议栈接到浏览器委托后发送 HTTP 请求消息的一系列操作过程了。  
不过，浏览器的工作并非到此为止。发送 HTTP 请求消息后，接下来还需要等待 Web 服务器返回响应消息。  
对于响应消息，浏览器需要进行接收操作，这一操作也需要协议栈的参与。  

首先，浏览器在委托协议栈发送请求消息之后，会调用 read 程序来获取响应消息。  
然后，控制流程会通过 read 转移到协议栈，  
然后协议栈会执行接下来的操作。  

和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下：  
首先，协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。  
响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。  
这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作。  

> 大家可以认为这时协议栈会进入暂停状态，但实际上并非如此。  
  协议栈会负责处理来自很多应用程序的工作，因此挂起其中一项工作并不意味着协议栈就完全暂停了，协议栈会继续执行其他的工作。  
  在执行其他工作的时候，挂起的工作并没有在执行，因此看上去和暂停是一样的。  

之前有说过协议栈接收数据的具体操作，这里进行简单总结：  
首先，协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号；  
然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序；  
- 具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。
将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新。  
- 如果窗口更新能够和 ACK 号等合并的话，在这里就会发送合并后的包。

## 从服务器断开并删除套接字

### 数据发送完毕后断开连接

应用程序判断所有数据都已经发送完毕时，数据发送完毕的一方会发起断开过程，但不同的应用程序会选择不同的断开时机。  

以 Web 为例：  
浏览器向 Web 服务器发送请求消息，Web 服务器再返回响应消息，这时收发数据的过程就全部结束了，服务器一方会发起断开过程。  
  - 这里讲的是 HTTP 1.0 的情形；
  - 在 HTTP 1.1 中，服务器返回响应消息之后，客户端还可以继续发起下一个请求消息，如果接下来没有请求要发送了，客户端一方会发起断开过程。

也有一些程序是客户端发送完数据就结束了，不用等服务器响应，这时客户端会先发起断开过程。  
这一判断是应用程序作出的，协议栈在设计上允许任何一方先发起断开过程。  

无论哪种情况，完成数据发送的一方会发起断开过程，这里我们以服务器一方发起断开过程为例来进行讲解。  
首先，服务器一方的应用程序会调用 Socket 库的 close 程序。  
然后，服务器的协议栈会生成包含断开信息的 TCP 头部，具体来说就是将控制位中的 FIN 比特设为 1。  
接下来，协议栈会委托IP 模块向客户端发送数据。  
- 同时，服务器的套接字中也会记录下断开操作的相关信息。

接下来轮到客户端了。  
当收到服务器发来的 FIN 为 1 的 TCP 头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态；  
然后，为了告知服务器已收到 FIN 为 1 的包，客户端会向服务器返回一个 ACK 号；  
这些操作完成后，协议栈就可以等待应用程序来取数据了；  
过了一会儿，应用程序就会调用 read 来读取数据；
- 这时，协议栈不会向应用程序传递数据，而是会告知应用程序（浏览器）来自服务器的数据已经全部收到了；
- 根据规则，服务器返回请求之后，Web 通信操作就全部结束了，因此只要收到服务器返回的所有数据，客户端的操作也就随之结束了。
客户端应用程序会调用 close 来结束数据收发操作；  
这时客户端的协议栈也会和服务器一样，生成一个 FIN 比特为 1 的 TCP 包，然后委托 IP 模块发送给服务器；  
一段时间之后，服务器就会返回 ACK 号；  
到这里，客户端和服务器的通信就全部结束了。  

### 删除套接字

和服务器的通信结束之后，用来通信的套接字也就不会再使用了，这时我们就可以删除这个套接字了。  
不过，套接字并不会立即被删除，而是会等待一段时间之后再被删除。  

等待这段时间是为了防止误操作，引发误操作的原因有很多，这里无法全部列举，下面来举一个最容易理解的例子。  

假设是客户端先发起断开，则断开的操作顺序如下：  
1. 客户端发送 FIN；
2. 服务器返回 ACK 号；
3. 服务器发送 FIN；
4. 客户端返回 ACK 号。

如果最后客户端返回的 ACK 号丢失了，服务器没有接收到 ACK 号，可能会重发一次 FIN ；  
但如果这时客户端的套接字已经删除了，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来；  
这时如果别的应用程序要创建套接字，新套接字碰巧又被分配到了同一个端口号，而服务器重发的 FIN 正好到达；  
本来这个 FIN 是要发给之前被删掉的套接字的，但新套接字有同样的端口号，于是这个 FIN 就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。  
之所以不马上删除套接字，就是为了防止这样的误操作。  

至于具体等待多长时间，这和包重传的操作方式有关。  
网络包丢失之后会进行重传，这个操作通常要持续几分钟。  
如果重传了几分钟之后依然无效，则停止重传。  
在这段时间内，网络中可能存在重传的包，也就有可能发生前面讲到的这种误操作，因此需要等待到重传完全结束。  
协议中对于这个等待时间没有明确的规定，一般来说会等待几分钟之后再删除套接字。  

### 数据收发操作小结

数据收发操作的步骤：

1. 创建套接字；
   - 一般来说，服务器一方的应用程序在启动时就会创建好套接字并进入等待连接的状态；
   - 客户端则一般是在用户触发特定动作，需要访问服务器的时候创建套接字；
   - 在这个阶段，还没有开始传输网络包。
2. 客户端会向服务器发起连接操作；
   - 首先，客户端会生成一个 SYN 为 1 的 TCP 包并发送给服务器；
     - 这个 TCP 包的头部还包含了客户端向服务器发送数据时使用的初始序号，以及服务器向客户端发送数据时需要用到的窗口大小。
   - 当这个包到达服务器之后，服务器会返回一个 SYN 为 1 的 TCP 包；
     - 这个包的头部中也包含了序号和窗口大小，此外还包含表示确认已收到客户端发送的 TCP 包的 ACK 号。
   - 当这个包到达客户端时，客户端会向服务器返回一个包含表示确认的 ACK 号的 TCP 包；
   - 到这里，连接操作就完成了，双方进入数据收发阶段。
3. 数据收发阶段；
数据收发阶段的操作根据应用程序的不同而有一些差异，以 Web 为例：  
   - 首先客户端会向服务器发送请求消息；
     - TCP 会将请求消息切分成一定大小的块，并在每一块前面加上 TCP 头部，然后发送给服务器；
     - TCP 头部中包含序号，它表示当前发送的是第几个字节的数据。
   - 当服务器收到数据时，会向客户端返回 ACK 号；
     - 在最初的阶段，服务器只是不断接收数据，随着数据收发的进行，数据不断传递给应用程序，接收缓冲区就会被逐步释放。这时，服务器需要将新的窗口大小告知客户端。
   - 当服务器收到客户端的请求消息后，会向客户端返回响应消息，这个过程和刚才的过程正好相反。
4. 断开操作。
服务器的响应消息发送完毕之后，数据收发操作就结束了，这时就会开始执行断开操作。  
以 Web 为例：  
   - 服务器会先发起断开过程；
   - 在这个过程中，服务器先发送一个 FIN 为 1 的 TCP 包；
   - 然后客户端返回一个表示确认收到的 ACK 号；
   - 接下来，双方还会交换一组方向相反的 FIN 为 1 的 TCP 包和包含 ACK 号的 TCP 包；
   - 最后，在等待一段时间后，套接字会被删除。

## IP 与以太网的包收发操作

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成包发送给通信对象。  

### 包的基本知识

包是由头部和数据两部分构成的。  
- 头部包含目的地址等控制信息；
- 头部后面就是委托方要发送给对方的数据。

TCP/IP包：  
|MAC头部|IP头部|TCP头部|数据块|
|---|---|---|---|
|MAC头部：以太网控制信息|IP头部：IP控制信息|||

一般来说 TCP 头部和数据块加起来就是包的内容；  
IP 头部加 TCP 头部加数据块是 IP 包；  
IP 包加 MAC 头部是以太网包。  

#### 包发往目的地的过程

1. 首先，发送方的网络设备会负责创建包；  
   - 创建包的过程就是生成含有正确控制信息的头部，然后再附加上要发送的数据。
2. 接下来，包会被发往最近的网络转发设备；  
   - 当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里。
   - 这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个方向。
3. 接下来，包在向目的地移动的过程中，又会到达下一个转发设备，然后又会按照同样的方式被发往下一个转发设备。  
   - 就这样，经过多个转发设备的接力之后，包最终就会到达接收方的网络设备。

当然，发送方向接收方发送一个包，接收方可能也会向发送方返回一个包，此时的发送方到了接下来的某个时刻就会变成接收方。  
因此，我们不需要把发送方和接收方明确区分开来，在这里我们把发送方和接收方统称为终端节点。  
- 相应地，转发设备被称为转发节点或者中间节点。


网络中有路由器和集线器两种不同的转发设备，它们在传输网络包时有着各自的分工。  
1. 路由器根据目标地址判断下一个路由器的位置；
2. 集线器在子网中将网络包传输到下一个路由。

实际上，集线器是按照以太网规则传输包的设备，而路由器是按照 IP 规则传输包的设备，因此我们也可以作如下理解。  
1. IP 协议根据目标地址判断下一个 IP 转发设备的位置；
2. 子网中的以太网协议将包传输到下一个转发设备。

TCP/IP 包包含如下两个头部：  
1. MAC 头部（用于以太网协议）；
2. IP 头部（用于 IP 协议）。

这两个头部分别具有不同的作用。 
 
1. 首先，发送方将包的目的地，也就是要访问的服务器的 IP 地址写入 IP 头部中；  
   - 这样一来，我们就知道这个包应该发往哪里，IP 协议就可以根据这一地址查找包的传输方向，从而找到下一个路由器的位置。  
2. 接下来，IP 协议会委托以太网协议将包传输过去；  
   - 这时，IP 协议会查找下一个路由器的以太网地址（ MAC 地址），并将这个地址写入 MAC 头部中；
   - 这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。  
3. 网络包在传输过程中会经过集线器，集线器是根据以太网协议工作的设备;  
   - 为了判断包接下来应该向什么地方传输，集线器里有一张表（用于以太网协议的表），可根据以太网头部中记录的目的地信息查出相应的传输方向;
   - 当存在多个集线器时，网络包会按顺序逐一通过这些集线器进行传输。  
4. 接下来，包会到达下一个路由器；
   - 路由器中有一张 IP 协议的表，可根据这张表以及 IP 头部中记录的目的地信息查出接下来应该发往哪个路由器;
   - 为了将包发到下一个路由器，我们还需要查出下一个路由器的 MAC 地址，并记录到 MAC 头部中，大家可以理解为改写了 MAC 头部;
   - 这样，网络包就又被发往下一个节点了;
   - 更准确地说，收到包的时候 MAC 头部会被舍弃，而当再次发送的时候又会加上包含新 MAC 地址的新 MAC 头部。
5. 这个过程不断重复，最终网络包就会被送到目的地。
   - 当目的地设备成功接收之后，网络包的传输过程就结束了。

这就是一个网络包从出发到到达目的地的全过程。  

虽然看起来有点复杂，不过设计这样的分工是有原因的。  
其中以太网的部分也可以替换成其他的东西，例如无线局域网、ADSL、FTTH 等，它们都可以替代以太网的角色帮助 IP 协议来传输网络包。  
- 当使用除以太网之外的其他网络进行传输时，MAC 头部也会被替换为适合所选通信规格的其他头部。
因此，将 IP 和负责传输的网络分开，可以更好地根据需要使用各种通信技术。像互联网这样庞大复杂的网络，在架构上需要保证灵活性，这就是设计这种分工方式的原因。  

### 在协议栈中 IP 模块如何完成包收发操作概览

尽管之前说 IP 模块负责将包发给对方，但实际上将包从发送方传输到接收方的工作是由集线器、路由器等网络设备来完成的，  
因此 IP 模块仅仅是整个包传输过程的入口而已。即便如此，IP 模块还是有很多工作需要完成。  

1. 包收发操作的起点是 TCP 模块委托 IP 模块发送包的操作；
   - 这个委托的过程就是 TCP 模块在数据块的前面加上 TCP 头部，然后整个传递给 IP 模块，这部分就是网络包的内容。
   - 与此同时，TCP 模块还需要指定通信对象的 IP 地址，也就是需要写清楚“将什么内容发给谁”。
2. 收到委托后，IP 模块会将包的内容当作一整块数据，在前面加上包含控制信息的头部，即 IP 头部和 MAC 头部这两种头部；
   - IP 头部中包含 IP 协议规定的、根据 IP 地址将包发往目的地所需的控制信息；
   - MAC 头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息；
   - 加上这两个头部之后，一个包就封装好了，这些就是 IP 模块负责的工作。
     - 凡是局域网所使用的头部都叫 MAC 头部，但其内容根据局域网的类型有所不同；
     - 此外，对于除局域网之外的其他通信技术，还有不同名称的各种头部，但它们只是名字不叫 MAC 头部而已，承担的作用和 MAC 头部是相同的。
3. 接下来，封装好的包会被交给网络硬件，例如以太网、无线局域网等；
   - 网络硬件可能是插在计算机主板上的板卡，也可能是笔记本电脑上的 PCMCIA 卡，或者是计算机主板上集成的芯片；
   - 不同形态的硬件名字也不一样，本书将它们统称为网卡。
4. 传递给网卡的网络包是由一连串 0 和 1 组成的数字信息，网卡会将这些数字信息转换为电信号或光信号，并通过网线（或光纤）发送出去；
5. 然后这些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步地送达接收方；
6. 包送达对方之后，对方会作出响应；
7. 返回的包也会通过转发设备发送回来，然后我们需要接收这个包；
   - 接收的过程和发送的过程是相反的，信息先以电信号的形式从网线传输进来，然后由网卡将其转换为数字信息并传递给 IP 模块；
   - 接下来，IP 模块会将 MAC 头部和 IP 头部后面的内容，也就是 TCP 头部加上数据块，传递给 TCP 模块。
8. 接下来的操作就是我们之前讲过的 TCP 模块负责的部分了。

在这个过程中，有2个关键的点。  
1. IP 的包收发操作都是相同的，并不会因包本身而有所区别；  
   - 因为 IP 模块会将 TCP 头部和数据块看作一整块二进制数据，在执行收发操作时并不关心其中的内容。
2. IP 模块也不关心 TCP 的操作阶段，对于包的乱序和丢失也一概不知。  
   - 总之，IP 的职责就是将委托的东西打包送到对方手里，或者是将对方送来的包接收下来，仅此而已。

### 生成包含接收方 IP 地址的 IP 头部

IP 模块接受 TCP 模块的委托负责包的收发工作，它会生成 IP 头部并附加在 TCP 头部前面。  

IP 头部最重要的内容就是 IP 地址，它表示这个包应该发到哪里去；  
- 这个地址是由 TCP 模块告知的，而 TCP 又是在执行连接操作时从应用程序那里获得这个地址的，因此这个地址的最初来源就是应用程序。
- IP 不会自行判断包的目的地，而是将包发往应用程序指定的接收方，即便应用程序指定了错误的 IP 地址，IP 模块也只能照做。

IP 头部中还需要填写发送方的IP 地址；  
- 一般的客户端计算机上只有一块网卡，因此也就只有一个 IP 地址，这种情况下我们可以认为这个 IP 地址就是计算机的 IP 地址；
- 但如果计算机上有多个网卡，情况就没那么简单了。
  - IP 地址实际上并不是分配给计算机的，而是分配给网卡的，因此当计算机上存在多块网卡时，每一块网卡都会有自己的 IP 地址；
  - 很多服务器上都会安装多块网卡，这时一台计算机就有多个 IP 地址，在填写发送方 IP 地址时就需要判断到底应该填写哪个地址；
  - 这个判断相当于在多块网卡中判断应该使用哪一块网卡来发送这个包，也就相当于判断应该把包发往哪个路由器；
  - 因为只要确定了目标路由器，也就确定了应该使用哪块网卡，也就确定了发送方的 IP 地址。
>（因为 IP 表，即路由表（Routing Table）中目标路由器的 IP 和转发路由器的 IP 和网卡这样的网络接口是有对应关系的。）

接下来还需要填写协议号。
- 它表示包的内容是来自哪个模块的
  - 如果是TCP 模块委托的内容，则设置为06（十六进制）；
  - 如果是UDP 模块委托的内容，则设置为17（十六进制）；
  - 这些值都是按照规则来设置的。

### 生成以太网用的MAC 头部

生成了 IP 头部之后，接下来 IP 模块还需要在 IP 头部的前面加上 MAC 头部；  
IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，TCP/IP 的这个思路是行不通的；  
以太网在判断网络包目的地时和 TCP/IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的。  

IP 模块在生成 IP 头部之后，会在它前面再加上 MAC 头部。MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。  

MAC 头部的开头是接收方和发送方的 MAC 地址；  
- 大家可以认为它们和IP 头部中的接收方和发送方IP 地址的功能差不多，只不过 IP 地址的长度为32 比特，而MAC地址为48 比特。
- 此外，IP 地址是类似多少弄多少号这种现实中地址的层次化的结构，而 MAC 地址中的 48 比特可以看作是一个整体。

尽管有上述差异，但从表示接收方和发送方的意义上来说，MAC 地址和 IP 地址是没有区别的，因此可以暂且先把它们当成是一回事。  

第 3 个以太类型字段和 IP 头部中的协议号类似。  
在 IP 中，协议号表示 IP 头部后面的包内容的类型；  
而在以太网中，我们可以认为以太网类型后面就是以太网包的内容，而以太类型就表示后面内容的类型。  
以太网包的内容可以是 IP 、 ARP 等协议的包，它们都有对应的值，这也是根据规则来确定的。  

MAC 头部的字段：  
|字段名称|长度（比特）|含义|
|---|---|---|
|接收方 MAC 地址|48|网络包接收方的 MAC 地址，在局域网中使用这一地址来传输网络包|
|发送方 MAC 地址|48|网络包发送方的 MAC 地址，接收方通过它来判断是谁发送了这个包|
|以太类型|16|使用的协议类型。一般在 TCP/IP 通信中只使用 0800：IP 协议 和 0806：ARP 协议 这两种|

在生成 MAC 头部时，只要设置接收方 MAC 地址、发送方 MAC 地址、以太类型这 3 个字段就可以了。  
以太类型：这里填写表示 IP 协议的值 0800（十六进制）；  
发送方 MAC 地址，这里填写网卡本身的 MAC 地址；  
  - MAC 地址是在网卡生产时写入ROM里的，只要将这个值读取出来写入 MAC 头部就可以了；
    - 实际上，只有在操作系统启动过程中对网卡进行初始化的时候才会读取 MAC 地址，读取出来之后会存放在内存中，每次执行收发操作时实际上使用的是内存中的值。
  - 对于多块网卡的情况，判断出从哪块网卡发送包，然后将这块网卡对应的 MAC 地址填进去就好了。
接收方 MAC 地址，IP 模块根据路由表 Gateway 栏的内容判断应该把包发送给谁，但只知道对方的 IP 地址，还不知道对方的 MAC 地址，所以需要根据 IP 地址查询 MAC 地址。  

### 通过 ARP 查询目标路由器的 MAC 地址

在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。  

ARP（Address Resolution Protocol，地址解析协议。）就是利用广播对所有设备提问：“×× 这个 IP 地址是谁的？请把你的 MAC 地址告诉我。”
然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是××××。
- 不是这个IP 地址的设备会忽略广播，什么都不回答。

如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址，然后，我们将这个 MAC 地址写入 MAC 头部，MAC头部就完成了。  
如果不在同一个子网，那 ARP 的对象就变成默认网关，数据包交给网关，由路由器转发。  
  - 永远不会 ARP 远端主机的 IP。

不过，如果每次发送包都要这样查询一次，网络中就会增加很多 ARP 包，因此我们会将查询结果放到一块叫作 ARP 缓存的内存空间中留着以后用。  
也就是说，在发送包时，先查询一下 ARP 缓存。  
- 如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址；
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 查询。

MAC 地址的写法：  
1. 用“-”分隔的写法：00-80-C8-2D-82-EA
2. 用“:”分隔的写法：00:80:C8:2D:82:EA
MAC 地址的长度为 48 比特，即6字节，按照惯例有这两种写法，它们的意思是一样的，使用任何一种写法都可以。  

有了 ARP 缓存，我们可以减少 ARP 包的数量，但如果总是使用 ARP 缓存中保存的地址也会产生问题：  
  - 例如当 IP 地址发生变化时，ARP 缓存的内容就会和现实发生差异。  
为了防止这种问题的发生，ARP 缓存中的值在经过一段时间后会被删除，一般这个时间在几分钟左右。  
  - 这个删除的操作非常简单粗暴，不管 ARP 缓存中的内容是否有效，只要经过几分钟就全部删掉，这样就不会出问题了。  
  - 当地址从 ARP 缓存中删除后，只要重新执行一次 ARP 查询就可以再次获得地址了。  
上面这个策略能够在几分钟后消除缓存和现实的差异，但 IP 地址刚刚发生改变的时候，ARP 缓存中依然会保留老的地址，这时就会发生通信的异常。  
  - 遇到这种情况，可以查看ARP 缓存的内容，并手动删除过时的条目。

将 MAC 头部加在 IP 头部的前面，整个包就完成了。
- 到这里为止，整个打包的工作是由 IP 模块负责的。  
  有人认为，MAC 头部是以太网需要的内容，并不属于 IP 的职责范围，但从现实来看，让IP 负责整个打包工作是有利的。  
  如果在交给网卡之前，IP 模块能够完成整个打包工作，那么网卡只要将打好的包发送出去就可以了。  
  对于除 IP 以外的其他类型的包也是一样，如果在交给网卡之前完成打包，那么对于网卡来说，发送的操作和发送IP 包是完全相同的。  
  这样一来，同一块网卡就可以支持各种类型的包。  
- 至于接收操作，我们到后面会讲，但如果接收的包可以原封不动直接交给IP 模块来处理，网卡就只要负责接收就可以了。  
  这样一来，一块网卡也就能支持各种类型的包了。  
  与其机械地设计模块和设备之间的分工，导致网卡只能支持IP 包，不如将分工设计得现实一些，让网卡能够灵活支持各种类型的包。  
  
### 以太网的基本知识

以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术。

通过 MAC 头部中的接收方 MAC 地址，就能够知道包是发给谁的；  
而通过发送方 MAC 地址，就能够知道包是谁发出的；  
此外，通过以太类型就可以判断包里面装了什么类型的内容。  
以太网其实就这么简单。  

尽管以太网经历了数次变迁，但其基本的 3 个性质至今仍未改变，即将包发送到 MAC 头部的接收方 MAC 地址代表的目的地，用发送方 MAC地址识别发送方，用以太类型识别包的内容。  
因此，大家可以认为具备这 3 个性质的网络就是以太网。  

以太网中的各种设备也是基于以太网规格来工作的，因此下面的内容不仅适用于客户端计算机，同样也适用于服务器、路由器等各种设备。  
- 路由器等网络设备的网卡是集成在设备内部的，其电路的设计也有所不同，尽管结构有差异，但功能和行为是没有区别的。
此外，以太网和 IP 一样，并不关心网络包的实际内容，因此以太网的收发操作也和 TCP 的工作阶段无关，都是共通的，同样也与应用程序的种类无关。  

### 将 IP 包转换成电或光信号发送出去

以太网的包收发操作：  
IP 生成的网络包只是存放在内存中的一串数字信息，没有办法直接发送给对方。  
因此，我们需要将数字信息转换为电或光信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。  

负责执行这一操作的是网卡，但网卡也无法单独工作，要控制网卡还需要网卡驱动程序。  

#### 网卡的初始化过程

网卡并不是通上电之后就可以马上开始工作的，而是和其他硬件一样，都需要进行初始化。  
- 也就是说，打开计算机启动操作系统的时候，网卡驱动程序会对硬件进行初始化操作，然后硬件才进入可以使用的状态； 
- 这些操作包括硬件错误检查、初始设置等步骤，这些步骤对于很多其他硬件也是共通的。
  - 但也有一些操作是以太网特有的，那就是在控制以太网收发操作的 MAC 模块中设置 MAC 地址。

网卡的 ROM 中保存着全世界唯一的 MAC 地址，这是在生产网卡时写入的，将这个值读出之后就可以对 MAC 模块进行设置，MAC 模块就知道自己对应的 MAC 地址了。  
也有一些特殊的方法，比如从命令或者配置文件中读取 MAC 地址并分配给 MAC 模块。这种情况下，网卡会忽略 ROM 中的 MAC 地址。  

有人认为在网卡通电之后，ROM 中的 MAC 地址就自动生效了，其实不然，真正生效的是网卡驱动进行初始化时在 MAC 模块中设置的那个 MAC 地址。  
在操作系统启动并完成这些初始化操作之后，网卡就可以等待来自 IP 的委托了。  

### 给网络包再加 3 个控制数据

网卡将包转换成电信号并发送到网线中的过程：  
网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向 MAC 模块发送发送包的命令。接下来就轮到 MAC 模块进行工作了。  
1. 首先，MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列；
   - 报头是一串像 10101010… 这样 1 和 0 交替出现的比特序列，长度为 56 比特，它的作用是确定包的读取时机;
     - 当这些 1010 的比特序列被转换成电信号后，会形成波形。接收方在收到信号时，遇到这样的波形就可以判断读取数据的时机。
      - 关于如何通过电信号来读取数据：
       1. 用电信号来表达数字信息时，我们需要让 0 和 1 两种比特分别对应特定的电压和电流;
          - 通过测量信号中的电压和电流变化，还原出 0 和 1 两种比特的值;
          - 如果 1 和 0 连续出现的信号，由于电压和电流没有变化，我们就没办法判断出其中每个比特到底应该从哪里去切分。
       2. 要解决这个问题，最简单的方法就是在数据信号之外再发送一组用来区分比特间隔的时钟信号;
          - 因为各种原因，数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移。
       3. 要解决这个问题，可以采用将数据信号和时钟信号叠加在一起的方法。
          - 由于时钟信号是按固定频率变化的，只要对信号进行一段时间的观察，就可以找到其变化的周期，此时通过接收信号和时钟信号算出数据信号，从而还原 0 或 1 的比特的值。
   - 因此我们在包的数据前面加上一段用来测量时钟信号的特殊信号，即报头，就可以确定包的读取时机。

> 如果在包信号结束之后，继续传输时钟信号，就可以保持时钟同步的状态，下一个包就无需重新进行同步。  
  有些通信方式采用了这样的设计，但以太网的包结束之后时钟信号也跟着结束了，没有通过这种方式来保持时钟同步，因此需要在每个包的前面加上报头，用来进行时钟同步。  

起始帧分界符是一个用来表示包起始位置的标记。  
它的末尾比特排列有少许变化。接收方以这一变化作为标记，从这里开始提取网络包数据。  

末尾的 FCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串 32 比特的序列，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的。  
在包传输过程中，如果受到噪声的干扰而导致其中的数据发生了变化，那么接收方计算出的FCS 和发送方计算出的FCS 就会不同，这样我们就可以判断出数据有没有错误。  

### 向集线器发送网络包

加上报头、起始帧分界符和 FCS 之后，我们就可以将包通过网线发送出去了。  
发送信号的操作分为两种：  
1. 使用集线器的半双工模式；
   - 某一时刻只能进行发送或接收其中一种操作的叫作“半双工”；
2. 使用交换机的全双工模式。
   - 发送和接收同时并行的方式叫作“全双工”。

在半双工模式中，为了避免信号碰撞，首先要判断网线中是否存在其他设备发送的信号。  
- 如果有，则需要等待该信号传输完毕；
  - 因为如果在有信号时再发送一组信号，两组信号就会发生碰撞。
- 当之前的信号传输完毕，或者本来就没有信号在传输的情况下，我们就可以开始发送信号了。

1. 首先，MAC 模块从报头开始将数字信息按每个比特转换成电信号，然后由 PHY，或者叫 MAU 的信号收发模块发送出去；
   - 在这里，将数字信息转换为电信号的速率就是网络的传输速率；
     - 例如每秒将 10 Mbit 的数字信息转换为电信号发送出去，则速率就是 10 Mbit/s。
   - 根据以太网信号方式的不同，有些地方叫 MAU（Medium Attachment Unit，介质连接单元），有些地方叫 PHY（Physical Layer Device，物理层装置）。
     - 在速率为 100 Mbit/s 以上的以太网中都叫 PHY。
2. 接下来，PHY（MAU）模块会将信号转换为可在网线上传输的格式，并通过网线发送出去。
   - 以太网规格中对不同的网线类型和速率以及其对应的信号格式进行了规定，但 MAC 模块并不关心这些区别，而是将可转换为任意格式的通用信号发送给PHY（MAU）模块；
     - 然后 PHY（MAU）模块再将其转换为可在网线上传输的格式。
   - 可以认为 PHY（MAU）模块的功能就是对 MAC 模块产生的信号进行格式转换。

#### PHY（MAU）的职责

1. 将MAC 模块传递过来的信号通过网线发送出去；
2. 监控接收线路中有没有信号进来。
   - 在开始发送信号之前，需要先确认没有其他信号进来，这时才能开始发送；
   - 如果在信号开始发送到结束发送的这段时间内一直没有其他信号进来，发送操作就成功完成了。

> 以太网不会确认发送的信号对方有没有收到。  
  根据以太网的规格，两台设备之间的网线不能超过 100 米，在这个距离内极少会发生错误，万一发生错误，协议栈的 TCP 也会负责搞定，因此在发送信号时没有必要检查错误。  
  - 100 米时使用双绞线的情况，如果采用光纤则可以更长，而且错误率不会上升；
  - 实际上的错误率低于万分之一。

如果有多台设备同时向一台设备发送信号，这些信号就会通过接收线路一起传进来；
在使用集线器的半双工模式中，一旦发生这种情况，两组信号就会相互叠加，无法彼此区分出来，这就是所谓的信号碰撞。
- 这种情况下，继续发送信号是没有意义的，因此发送操作会终止。
- 为了通知其他设备当前线路已发生碰撞，还会发送一段时间的阻塞信号，
  - 然后所有的发送操作会全部停止。
等待一段时间之后，网络中的设备会尝试重新发送信号。
- 但如果所有设备的等待时间都相同，那肯定还会发生碰撞，因此必须让等待的时间相互错开。
具体来说，等待时间是根据 MAC 地址生成一个随机数计算出来的。

> 当网络拥塞时，发生碰撞的可能性就会提高，重试发送的时候可能又会和另外一台设备的发送操作冲突，这时会将等待时间延长一倍，然后再次重试。
  以此类推，每次发生碰撞就将等待时间延长一倍，最多重试10次，如果还是不行就报告通信错误。

在全双工模式中，发送和接收可以同时进行，不会发生碰撞。  
因此，全双工模式中不需要像半双工模式这样考虑这么多复杂的问题，即便接收线路中有信号进来，也可以直接发送信号。  
关于全双工模式会在第三章介绍。  

### 接收返回包

在使用集线器的半双工模式以太网中，一台设备发送的信号会到达连接在集线器上的所有设备。  
这意味着无论是不是发给自己的信号都会通过接收线路传进来，因此接收操作的第一步就是不管三七二十一把这些信号全都收进来再说。  

信号的开头是报头，通过报头的波形同步时钟，然后遇到起始帧分界符时开始将后面的信号转换成数字信息。  

首先，PHY（MAU）模块会将信号转换成通用格式并发送给MAC 模块，
MAC 模块再从头开始将信号转换为数字信息，并存放到缓冲区中。
当到达信号的末尾时，还需要检查FCS。
  - 具体来说，就是将从包开头到结尾的所有比特套用到公式中计算出FCS，然后和包末尾的FCS 进行对比，
    - 正常情况下两者应该是一致的，
    - 如果中途受到噪声干扰而导致波形发生紊乱，则两者的值会产生差异，这时这个包就会被当作错误包而被丢弃。
如果FCS 校验没有问题，接下来就要看一下MAC 头部中接收方 MAC 地址与网卡在初始化时分配给自己的MAC 地址是否一致
  - 以此来判断这个包是不是发给自己的
    - 我们没必要去接收发给别人的包，因此如果不是自己的包就直接丢弃，
    - 如果接收方MAC 地址和自己MAC 地址一致，则将包放入缓冲区中
    - 到这里，MAC 模块的工作就完成了，接下来网卡会通知计算机收到了一个包。

#### 中断

通知计算机的操作会使用一个叫作中断的机制。  
- 在网卡执行接收包的操作的过程中，计算机并不是一直监控着网卡的活动，而是去继续执行其他的任务。
- 因此，如果网卡不通知计算机，计算机是不知道包已经收到了这件事的。
  - 网卡驱动也是在计算机中运行的一个程序，因此它也不知道包到达的状态。
在这种情况下，我们需要一种机制能够打断计算机正在执行的任务，让计算机注意到网卡中发生的事情，这种机制就是中断。  

具体来说，中断的工作过程是这样的：  
首先，网卡向扩展总线中的中断信号线发送信号；  
  - 该信号线通过计算机中的中断控制器连接到CPU。
当产生中断信号时，CPU 会暂时挂起正在处理的任务，切换到操作系统中的中断处理程序；  
  - 中断处理程序执行完毕之后，CPU 会继续处理原来的任务。
然后，中断处理程序会调用网卡驱动，控制网卡执行相应的接收操作。  

中断是有编号的，网卡在安装的时候就在硬件中设置了中断号，在中断处理程序中则将硬件的中断号和相应的驱动程序绑定。  
  - 例如，假设网卡的中断号为11，则在中断处理程序中将中断号11 和相应的网卡驱动绑定起来，当网卡发起中断时，就会自动调用网卡驱动了；
  - 现在的硬件设备都遵循即插即用规范自动设置中断号，我们没必要去关心中断号了，
    - 即插即用英文缩写为 PnP (Plug and Play)，是一种自动对扩展卡和周边设备进行配置的功能。

网卡驱动被中断处理程序调用后，会从网卡的缓冲区中取出收到的包，并通过 MAC 头部中的以太类型字段判断协议的类型。  

现在在大多数情况下都是使用 TCP/IP 协议，但除了 TCP/IP 之外还有很多其他类型的协议；
  - 例如 NetWare 中使用的 IPX/SPX，以及 Mac 电脑中使用的 AppleTalk 等协议。
这些协议都被分配了不同的以太类型。
  - 如 0080（十六进制）代表 IP 协议，网卡驱动就会把这样的包交给 TCP/IP 协议栈；
  - 如果是 809B 则表示 AppleTalk 协议，就把包交给 AppleTalk 协议栈；
  - 以此类推。

按照探索之旅的思路，大家可能会认为向 Web 服务器发送包之后，后面收到的一定是 Web 服务器返回的包，其实并非如此。  
计算机中同时运行了很多程序，也会同时进行很多通信操作，因此收到的包也有可能是其他应用程序的。  
不过，即便如此也没问题，网卡不会关心包里的内容。  
- 只要按照以太类型将包交给对应的协议栈就可以了；
- 接下来，协议栈会判断这个包应该交给哪个应用程序，并进行相应的处理。

### 将服务器的响应包从 IP 传递给 TCP

假设 Web 服务器返回了一个网络包，此时协议栈会进行的处理：  
1. 服务器返回的包的以太类型应该是 0800 ，因此网卡驱动会将其交给 TCP/IP 协议栈来进行处理；
2. IP 模块开始工作；
   1. 第一步是检查 IP 头部，确认格式是否正确；
   2. 如果格式没有问题，下一步就是查看接收方 IP 地址；
      - 服务器返回的包的接收方 IP 地址应该与客户端网卡的地址一致，检查确认后就可以接收这个包了；
        - 此时还需要完成另一项工作：分片重组。
          - IP 协议有一个叫作分片的功能，简单来说，网线和局域网中只能传输小包，因此需要将大的包切分成多个小包；
          - 如果接收到的包是经过分片的，那么 IP 模块会将它们还原成原始的包；
          - 分片的包会在 IP 头部的标志字段中进行标记，当收到分片的包时，IP 模块会将其暂存在内部的内存空间中，然后等待IP头部中具有相同ID 的包全部到达，这是因为同一个包的所有分片都具有相同的 ID；
          - IP 头部还有一个分片偏移量（fragment offset）字段，它表示当前分片在整个包中所处的位置；
          - 根据这些信息，在所有分片全部收到之后，就可以将它们还原成原始的包，这个操作叫作分片重组。
      - 如果 IP 地址不一致，那一定是发生了什么错误，客户端计算机不负责对包进行转发，因此不应该收到不是发给自己的包。
        - 当发生这种错误时，IP 模块会通过 ICMP 消息中的 Destination unreachable 将错误告知发送方。
   3. 到这里，IP 模块的工作就结束了。 
3. 包会交给 TCP 模块，TCP 模块会根据 IP 头部中的接收方和发送方 IP 地址，以及 TCP 头部中的接收方和发送方端口号来查找对应的套接字。
   - 找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了。例如：
     - 如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取；
     - 如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立和断开连接的操作状态。

## UDP 协议的收发操作

### 不需要重发的数据用 UDP 发送更高效

大多数的应用程序都像之前介绍的一样使用 TCP 协议来收发数据，但当然也有例外。  
有些应用程序不使用 TCP 协议，而是使用 UDP 协议来收发数据。向 DNS 服务器查询 IP 地址的时候我们用的也是 UDP 协议。  

TCP 是一种复杂的机制，因为需要确保能够将数据高效且可靠地发送给对方。  
为了实现可靠性，就需要确认对方是否收到了发送的数据，如果没有就再发一遍；  
  - 要实现上面的要求，最简单的办法就是数据全部发送完毕之后让接收方返回一个接受确认。  
    - 如果没收到就直接全部重新发送一遍，但这种就很低效。
为了实现高效，就需要避免重发已经送达的包，只发那些出错或者未送达的包就可以了。  
TCP 之所以复杂就是为了实现这两点。  

不过，在某些情况下，即便没有 TCP 这样复杂的机制，我们也能够高效地重发数据，这种情况就是数据很短，用一个包就能装得下。  
  - 如果只有一个包，就不用考虑哪个包未送达了，因为全部重发也只不过是重发一个包而已，这种情况下我们就不需要 TCP 这样复杂的机制了；
  - 而且，如果不使用 TCP，也不需要发送那些用来建立和断开连接的控制包了；
  - 此外，我们发送了数据，对方一般都会给出回复，只要将回复的数据当作接收确认就行了，也不需要专门的接收确认包了。

### 控制用的短数据

像 DNS 查询等交换控制信息的操作基本上都可以在一个包的大小范围内解决，这种情况就适合使用 UDP 而不是 TCP 。  

UDP 协议的功能：  
1. 发送；
   - UDP 没有 TCP 的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤；  
   - 只要在从应用程序获取的数据前面加上 UDP 头部，然后交给 IP 进行发送就可以了。  
2. 接收；
   - 接收也很简单，只要根据 IP 头部中的接收方和发送方 IP 地址，以及 UDP 头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了。  
3. 除此之外，UDP 协议没有其他功能了，遇到错误或者丢包也一概不管。
   - 因为 UDP 只负责单纯地发送包而已，并不像 TCP 一样会对包的送达状态进行监控，所以协议栈也不知道有没有发生错误；  
   - 但这样并不会引发什么问题，因此出错时就收不到来自对方的回复，应用程序会注意到这个问题，并重新发送一遍数据；  
   - 这样的操作本身并不复杂，也并不会增加应用程序的负担。  

UDP 头部（总长8字节）中的控制信息：  
|字段名称|长度（比特）|含义|
|---|---|---|
|发送方端口号|16|网络包发送方的端口号|
|接收方端口号|16|网络包接收方的端口号|
|数据长度|16| UDP 头部后面数据的长度|
|校验和|16|用于校验错误|

### 音频和视频数据

还有另一个场景会使用 UDP，就是发送音频和视频数据的时候。  
音频和视频数据必须在规定的时间内送达，一旦送达晚了，就会错过播放时机，导致声音和图像卡顿。  

如果像 TCP 一样通过接收确认响应来检查错误并重发，重发的过程需要消耗一定的时间，因此重发的数据很可能已经错过了播放的时机。  
一旦错过播放时机，重发数据也是没有用的，因为声音和图像已经卡顿了，这是无法挽回的。  
  - 当然，我们可以用高速线路让重发的数据能够在规定的时间内送达，但这样一来可能要增加几倍的带宽才行；
  - UDP 经常会被防火墙阻止，因此当需要穿越防火墙传输音频和视频数据时，尽管需要消耗额外的带宽，但有时候也只能使用 TCP。  
音频和视频数据中缺少了某些包并不会产生严重的问题，只是会产生一些失真或者卡顿而已，一般都是可以接受的。  
在这些无需重发数据，或者是重发了也没什么意义的情况下，使用 UDP 发送数据的效率会更高。  

# 从网线到网络设备-探索集线器、交换机和路由器

## 热身问答

1. 最早的以太网使用专用同轴网线，后来变成由美国室内电话线改良的版本，原因是它可以兼容电话线的布线工具和材料，比较方便。
2. 交换机比路由器更加简单，因此可能有人以为交换机应该比路由器出现得更早，其实是路由器先问世的。
3. 对于路由器和交换机，如果包在传输过程中发生错误，会直接丢弃错误的包而不会尝试修复。不过操作系统中的网络控制软件（协议栈）会对丢弃的包进行重发，数据不会因此丢失。

## 探索之旅

### 信号在网线和集线器中传输

信号从计算机中流出之后，会在网线中经过集线器等设备前进。  
此时，信号是如何在网线和集线器传输的，就是我们的第一个看点。  
信号在传输过程中会衰减，还会受到噪声干扰而失真，如何抑制这些影响是我们的另一个看点。  

### 交换机的包转发操作

交换机的工作方式也是本章看点之一。  
交换机并不只是简单地让信号流过，而是先接收信号并将其还原为数字信息，然后再重新转换成信号并发送出去的过程。  
这里我们将详细探索这一过程。  

### 路由器的包转发操作

路由器和交换机一样也负责对包进行转发，但它们的工作方式有一些差异。  
交换机是基于以太网规格工作的设备，而路由器是基于 IP 工作的，它们之间的差异也是本章看点之一。  

### 路由器的附加功能

位于互联网接入端的路由器通常还会提供一些附加功能，例如将私有地址转换为公有地址的地址转换功能，以及阻止危险网络包的包过滤功能等。  
本章最后将介绍一下这些功能，这样我们就会对路由器有较全面的认识。  

## 信号在网线和集线器中传输

### 每个包都是独立传输的

从计算机发送出来的网络包会通过集线器、路由器等设备被转发，最终到达目的地。  
转发设备会根据包头部中的控制信息，在转发设备内部一个写有转发规则的表中进行查询，以此来判断包的目的地，然后将包朝目的地的方向进行转发。  

转发设备在进行转发时也不看数据的内容。因此，无论包里面装的是应用程序的数据或者是 TCP 协议的控制信息，都不会对包的传输操作本身产生影响。  
  - TCP 控制信息也叫 TCP 头部，但从以太网和 IP 传输网络包的角度来看，TCP 头部并不算是“头部”，只能算是“数据”。
换句话说，HTTP 请求的方法，TCP 的确认响应和序号，客户端和服务器之间的关系，这一切都与包的传输无关。  
因此，所有的包在传输到目的地的过程中都是独立的，相互之间没有任何关联。  

网络包从客户端计算机发出以后，要经过集线器、交换机和路由器，最终进入互联网。  
  - 但实际上，现在一般使用的路由器已经集成了集线器和交换机的功能，使用独立设备的情况很少见。

### 防止网线中的信号衰减很重要

信号流出网卡进入网线，网卡中的 PHY（MAU）模块负责将包转换成电信号，信号通过 RJ-45 接口进入双绞线。  
  - 以太网信号的本质是正负变化的电压，大家可以认为网卡的 PHY（MAU）模块就是一个从正负两个信号端子输出信号的电路。 

网卡的 PHY（MAU）模块直接连接 RJ-45 接口，信号从这个接口中的 1 号和 2 号针脚流入网线。  
然后，信号会通过网线到达集线器的接口，这个过程就是单纯地传输电信号而已。  
但是，信号到达集线器的时候并不是跟刚发送出去的时候一模一样。集线器收到的信号有时会出现衰减。  
信号在网线的传输过程中，能量会逐渐损失。网线越长，信号衰减就越严重。  

而且，信号损失能量并非只是变弱而已，以太网中的信号波形是方形的，但损失能量会让信号的拐角变圆，这是因为电信号的频率越高，能量的损失率越大。  
信号的拐角意味着电压发生剧烈的变化，而剧烈的变化意味着这个部分的信号频率很高。  
高频信号更容易损失能量，因此本来剧烈变化的部分就会变成缓慢的变化，拐角也就变圆了。  

即便线路条件很好，没有噪声，信号在传输过程中依然会发生失真，如果再加上噪声的影响，失真就会更厉害。  
噪声根据强度和类型会产生不同的影响，无法一概而论，但如果本来就已经衰减的信号再进一步失真，就会出现对 0 和 1 的误判，这就是产生通信错误的原因。  

### “双绞”是为了抑制噪声

局域网网线使用的是双绞线，其中“双绞”的意思就是以两根信号线为一组缠绕在一起，这种拧麻花一样的设计是为了抑制噪声的影响。  

产生噪声的原因是网线周围的电磁波，当电磁波接触到金属等导体时，在其中就会产生电流。  
因此，如果网线周围存在电磁波，就会在网线中产生和原本的信号不同的电流。  
由于信号本身也是一种带有电压变化的电流，其本质和噪声产生的电流是一样的，所以信号和噪声的电流就会混杂在一起，导致信号的波形发生失真，这就是噪声的影响。  

影响网线的电磁波分为两种。  
一种是由电机、荧光灯、CRT 显示器等设备泄漏出来的电磁波，这种电磁波来自网线之外的其他设备；  
另一种电磁波是从网线中相邻的信号线泄漏出来的。  
  - 由于传输的信号本身就是一种电流，当电流流过时就会向周围发出电磁波，这些电磁波对于其他信号线来说就成了噪声。这种内部产生的噪声称为串扰（crosstalk）。

双绞线抑制第一种电磁波的原理：  
首先，信号线是用金属做成的，当电磁波接触到信号线时，会沿电磁波传播的右旋方向产生电流，这种电流会导致波形发生失真。  
如果我们将信号线缠绕在一起，信号线就变成了螺旋形，其中两根信号线中产生的噪声电流方向就会相反，从而使得噪声电流相互抵消，噪声就得到了抑制。   
当然，即便信号线变成螺旋形，里面的信号依然可以原样传输，也就是说，信号没有变，只是噪声被削弱了。  

第二种电磁波，即串扰：  
这种噪声的强度其实并不高，但问题是噪声源的距离太近了。  
距离发生源越远，电磁波就会因扩散而变得越弱，但在同一根网线中的信号线之间距离很近，这些电磁波还没怎么衰减就已经接触到了相邻的信号线。  
  - 因此，尽管信号线产生的电磁波十分微弱，也能够在相邻的信号线中产生感应电流。
要抑制这种噪声，关键在于双绞线的缠绕方式。  
  - 在一根网线中，每一对信号线的扭绞间隔（节距）都有一定的差异，这使得在某些地方正信号线距离近，另一些地方则是负信号线距离近；
  - 由于正负信号线产生的噪声影响是相反的，所以两者就会相互抵消；
  - 从网线整体来看，正负的分布保持平衡，自然就会削弱噪声的影响。

通过将信号线缠绕在一起的方式，噪声得到了抑制，从结果来看提升了网线的性能，除此之外还有其他一些工艺也能够帮助提升性能：  
  - 例如在信号线之间加入隔板保持距离，以及在外面包裹可阻挡电磁波的金属屏蔽网等。

网线的性能是以“类”来区分的，现在市售双绞线的主要种类如下表所示：  

|类|含义|
|---|---|
|五类（CAT-5）|用于10 Mbit/s（10BASE-T）和 100 Mbit/s（100BASE-TX）以太网，可以最高 125 MHz 的频率在最长 100 米的距离内传输信号|
|超五类（CAT-5e）|用于千兆（1000BASE-T）以太网，对五类网线进行了改良，改善了串扰，也向下兼容 10BASE-T 和 100BASE-TX |
|六类（CAT-6）|支持最高 250 MHz 的信号传输，用于 1000BASE-TX 规格的千兆以太网和 10GBASE-T 规格的万兆以太网，同时向下兼容 10BASE-T、100BASE-TX 和 1000BASE-T |
|超六类（CAT-6A）|对六类网线进行了改良，改善了外部串扰，兼容 10GBASE-T、1000BASE-TX、1000BASE-T、100BASE-TX 和 10BASE-T |
|七类（CAT-7）|支持最高 600 MHz 的高速信号传输， 兼容 10GBASE-T、1000BASE-TX、1000BASE-T、100BASE-TX 和 10BASE-T |

### 集线器将信号发往所有线路

当信号到达集线器后，会被广播到整个网络中。以太网的基本架构就是将包发到所有的设备，然后由设备根据接收方 MAC 地址来判断应该接收哪些包。  
而集线器就是这一架构的忠实体现，它就是负责按照以太网的基本架构将信号广播出去。  

#### 集线器的内部结构

首先，在每个接口的后面装有和网卡中的 PHY（MAU）功能相同的模块；  
  - 但如果它们像网卡端一样采用直连式接线，是无法正常接收信号的；
  - 要正常接收信号，必须将“发送线路”和“接收线路”连接起来才行。
    - 集线器中的 PHY（MAU）模块与接口之间采用交叉接线的原因正是在于此。
信号到达集线器的 PHY（MAU）模块后，会进入中继电路；  
  - 中继电路的基本功能就是将输入的信号广播到集线器的所有端口上；
  - 当然，也有一些产品具有信号整形、错误抑制等功能，但基本上就是将输入的信号原封不动地输出到网线接口。
接下来，信号从所有接口流出，到达连接在集线器上的所有设备；  
然后，这些设备在收到信号之后会通过 MAC 头部中的接收方 MAC 地址判断是不是发给自己的，如果是发给自己的就接受，否则就忽略；  
这样，网络包就能够到达指定 MAC 地址的接收方了。  

由于集线器只是原封不动地将信号广播出去，所以即便信号受到噪声的干扰发生了失真，也会原样发送到目的地。  
这时，接收信号的设备，也就是交换机、路由器、服务器等，会在将信号转换成数字信息后通过 FCS 校验发现错误，并将出错的包丢弃。  
当然，丢弃包并不会影响数据的传输，因为丢弃的包不会触发确认响应。因此协议栈的 TCP 模块会检测到丢包，并对该包进行重传。  

##### MDI/MDI-X

MDI 是 Media Dependent Interface（媒体相关接口）的缩写，MDI-X 是 MDI-Crossover 的缩写。  

集线器的接口中有一个 MDI/MDI-X 切换开关，MDI 就是对RJ-45 接口和信号收发模块进行直连接线，而 MDI-X 则是交叉接线。  
由于集线器的接口一般都是 MDI-X 模式，要将两台集线器相连时，就需要将其中一台改成 MDI 模式。  
如果集线器上没有 MDI 切换开关，而且所有的接口又都是 MDI-X 时，可以用交叉网线连接两台集线器。  
  - 所谓交叉网线，就是一种将发送和接收信号线反过来接的网线。

交叉网线也可以用于将两台计算机直接连接起来。  
网卡不仅可以连接集线器，因为网卡的 PHY（MAU）模块和集线器都是一样的，所以两台计算机的网卡也可以相互连接；  
只要将一侧的发送信号线和另一侧的接收信号线连起来就可以收发数据了。  

## 交换机的包转发操作

交换机的设计是将网络包原样转发到目的地。  

交换机的工作流程：  
首先，信号到达网线接口，并由 PHY（MAU）模块进行接收，这一部分和集线器是相同的；  
  - 也就是说，它的接口和 PHY（MAU）模块也是以 MDI-X 模式进行连接的，当信号从双绞线传入时，就会进入 PHY（MAU）模块的接收部分。
接下来，PHY（MAU）模块会将网线中的信号转换为通用格式，然后传递给 MAC 模块；  
MAC 模块将信号转换为数字信息，然后通过包末尾的 FCS 校验错误，如果没有问题则存放到缓冲区中。  
将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了；  
  - MAC 地址表主要包含两个信息；
    - 一个是设备的 MAC 地址；
    - 另一个是该设备连接在交换机的哪个端口上；
    - MAC 地址和端口是一一对应的，通过这张表就能够判断出收到的包应该转发到哪个端口。

> 大家可以认为交换机的每个网线接口后面都是一块网卡，网线接口和后面的电路部分加在一起称为一个端口，也就是说交换机的一个端口就相当于计算机上的一块网卡。  
  但交换机的工作方式和网卡有一点不同。  
  网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；  
  相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。  

交换电路的工作流程：  
交换电路中的信号线排列成网格状，每一个交叉点都有一个交换开关，交换开关是电子控制的，通过切换开关的状态就可以改变信号的流向。
交换电路的输入端和输出端分别连接各个接收端口和发送端口，网络包通过这个网格状的电路在端口之间流动。
每个交叉点上的交换开关都可以独立工作，因此只要路径不重复，就可以同时传输多路信号。

例：将包从 2 号端口发送到 7 号端口。    
1. 信号会从输入端的 2 号线进入交换电路；
2. 让左起的 6 个开关水平导通，然后将第 7 个开关切换为垂直导通；
3. 信号就会流到输出端 7 号线路，于是网络包就被发送到了 7 号端口。

当网络包通过交换电路到达发送端口时，端口中的 MAC 模块和 PHY（MAU）模块会执行发送操作，将信号发送到网线中，这部分和网卡发送信号的过程是一样的。  
根据以太网的规则，首先应该确认没有其他设备在发送信号，也就是确认信号收发模块中的接收线路没有信号进来。  
  - 如果检测到其他设备在发送信号，则需要等待信号发送完毕；
  - 如果没有其他信号，或者其他信号已经发送完毕，这时就可以将包的数字信息转换为电信号发送出去。
在发送信号的过程中，还需要对接收信号进行监控，这一点和网卡也是一样的。  
如果在发送过程中检测到其他设备发送信号，就意味着出现了信号碰撞，这时需要发送阻塞信号以停止网络中所有的发送操作，等待一段时间后再尝试重新发送，这一步和网卡也是一样的。  

### MAC 地址表的维护

交换机在转发包的过程中，还需要对 MAC 地址表的内容进行维护，维护操作分为两种。
1. 收到包时，将发送方 MAC 地址以及其输入端口的号码写入 MAC 地址表中；
   - 由于收到包的那个端口就连接着发送这个包的设备，所以只要将这个包的发送方 MAC 地址写入地址表，以后当收到发往这个地址的包时，交换机就可以将它转发到正确的端口了；
   - 交换机每次收到包时都会执行这个操作，因此只要某个设备发送过网络包，它的 MAC 地址就会被记录到地址表中。
2. 删除地址表中某条记录的操作。
   - 这是为了防止设备移动时产生问题；
     - 如果之前连接在端口的设备产生了移动，那如果交换机继续按过时记录发送数据则会导致通信出错。
   - 但是交换机也无法得知设备是否产生移动。
     - 所以地址表中的记录不能永久有效，而是要在一段时间不使用后就自动删除。
     - 过时记录从地址表中删除的时间一般为几分钟，在删除过时记录之前，依然有可能有发给该设备的包到达交换机，这是交换机正常工作就会导致通信出错。
       - 可能性很小，但确实有可能发生；
       - 这种情况下重启一下交换机，地址表就会被清空并更新正确的信息，然后网络就又可以正常工作了。

总之，交换机会自行更新或删除地址表中的记录，不需要手动维护。当地址表的内容出现异常时，只要重启一下交换机就可以重置地址表，也不需要手动进行维护。  

### 特殊操作

上面介绍了交换机的基本工作方式，下面来看一些特殊情况下的操作。  

1. 交换机查询地址表之后发现记录中的目标端口和这个包的源端口是同一个端口；
   - 当交换机发现一个包要发回到原端口时，就会直接丢弃这个包。
     - 首先，计算机 A 发送的包到达集线器后会被集线器转发到所有端口上，也就是会到达交换机和计算机 B ；
     - 交换机转发这个包之后，这个包会原路返回集线器；
     - 然后，集线器又把包转发到所有端口，于是这个包又到达了计算机 A 和计算机 B ；
     - 所以计算机 B 就会收到两个相同的包，这会导致无法正常通信。
2. 地址表中找不到指定的MAC 地址。
   - 这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。
   - 这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。
   - 至于这种特殊情况的原因可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。

有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”  
其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入地址表，下次也就不需要把包发到所有端口了。  
局域网中每秒可以传输上千个包，多出一两个包并无大碍。  

此外，如果接收方 MAC 地址是一个广播地址，那么交换机会将包发送到除源端口之外的所有端口。  
  - 广播地址（broadcast address）是一种特殊的地址，将广播地址设为接收方地址时，包会发送到网络中所有的设备。
    - MAC 地址中的 FF:FF:FF:FF:FF:FF 和 IP 地址中的 255.255.255.255 都是广播地址。

### 全双工模式可以同时进行发送和接收

全双工模式是交换机特有的工作模式，它可以同时进行发送和接收操作，集线器不具备这样的特性。  
使用集线器时，如果多台计算机同时发送信号，信号就会在集线器内部混杂在一起，进而无法使用，这种现象称为碰撞，是以太网的一个重要特征。不过，只要不用集线器，就不会发生碰撞。   
  
而使用双绞线时，发送和接收的信号线是各自独立的，因此在双绞线中信号不会发生碰撞。  
网线连接的另一端，即交换机端口和网卡的 PHY（MAU）模块以及 MAC 模块，其内部发送和接收电路也是各自独立的，信号也不会发生碰撞。  
因此，只要不用集线器，就可以避免信号碰撞了。如果不存在碰撞，也就不需要半双工模式中的碰撞处理机制了。  
也就是说，发送和接收可以同时进行。  

然而，以太网规范中规定了在网络中有信号时要等该信号结束后再发送信号，因此发送和接收还是无法同时进行。  
于是，人们对以太网规范进行了修订，增加了一个无论网络中有没有信号都可以发送信号的工作模式，同时规定在这一工作模式下停用碰撞检测。  
这种工作模式就是全双工模式。  
  - 在全双工模式下，无需等待其他信号结束就可以发送信号，因此它比半双工模式速度要快。
  - 由于双方可以同时发送数据，所以可同时传输的数据量也更大，性能也就更高。

### 自动协商：确定最优的传输速率

随着全双工模式的出现，如何在全双工和半双工模式之间进行切换的问题也产生了。  
在全双工模式刚刚出现的时候，还需要手动进行切换，但这样实在太麻烦，于是后来出现了自动切换工作模式的功能。  
  - 这一功能可以由相互连接的双方探测对方是否支持全双工模式，并自动切换成相应的工作模式；
  - 此外，除了能自动切换工作模式之外，还能探测对方的传输速率并进行自动切换；
  - 这种自动切换的功能称为自动协商。

在以太网中，当没有数据在传输时，网络中会填充一种被称为连接脉冲的脉冲信号。
  - 在没有数据信号时就填充连接脉冲，这使得网络中一直都有一定的信号流过，从而能够检测对方是否在正常工作，或者说网线有没有正常连接；
  - 以太网设备的网线接口周围有一个绿色的LED 指示灯，它表示是否检测到正常的脉冲信号。
    - 如果绿灯亮，说明PHY（MAU）模块以及网线连接正常。

在双绞线以太网规范最初制定的时候，只规定了按一定间隔发送脉冲信号，这种信号只能用来确认网络是否正常。  
后来，人们又设计出了的具有特定排列的脉冲信号，通过这种信号可以将自身的状态告知对方。  
自动协商功能就利用了这样的脉冲信号，即通过这种信号将自己能够支持的工作模式和传输速率相互告知对方，并从中选择一个最优的组合。  
  - 支持的模式是按照优先级排序的，双方会根据都支持的模式从优先级高的开始选。  

### 交换机可同时执行多个转发操作

交换机只将包转发到具有特定 MAC 地址的设备连接的端口，其他端口都是空闲的，这些端口可以传输其他的包，因此交换机可以同时转发多个包。  
相对地，集线器会将输入的信号广播到所有的端口，如果同时输入多个信号就会发生碰撞，无法同时传输多路信号，因此从设备整体的转发能力来看，交换机要高于集线器。  

## 路由器的包转发操作

### 路由器的基本知识

网络包经过集线器和交换机之后，现在到达了路由器，并在此被转发到下一个路由器。  
这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。不过在具体的操作过程上，路由器和交换机是有区别的。  
  - 因为路由器是基于IP 设计的，而交换机是基于以太网设计的。

#### 路由器的内部结构

路由器包括转发模块和端口模块两部分。  
  - 转发模块负责判断包的转发目的地；
    - 转发模块也叫包转发模块，根据路由器中的记录判断包的转发目标。
  - 端口模块负责包的收发操作。
    - 不同的路由器端口模块有所不同，例如支持 ADSL 的路由器，支持 FTTH 的路由器，支持专线等线路的路由器等。
    - 以太网端口与计算机里的网卡差不多，也是由 RJ-45 接口、 MAU(PHY)、 MAC 和内存组成的。其中接口与 MAU(PHY) 之间一般采用和网卡一样的 MDI 方式进行连接。
    
通过更换网卡，计算机不仅可以支持以太网，也可以支持无线局域网，路由器也是一样。  
如果路由器的端口模块安装了支持无线局域网的硬件，就可以支持无线局域网了。  
  - 此外，计算机的网卡除了以太网和无线局域网之外很少见到支持其他通信技术的品种；
  - 而路由器的端口模块则支持除局域网之外的多种通信技术，如 ADSL、FTTH ，以及各种宽带专线等，只要端口模块安装了支持这些技术的硬件即可。

#### 路由器的工作原理

1. 路由器在转发包时，首先会通过端口将发过来的包接收进来，这一步的工作过程取决于端口对应的通信技术；
   - 对于以太网端口来说，就是按照以太网规范进行工作；
   - 对于无线局域网端口则是按照无线局域网的规范工作；
   - 总之就是委托端口的硬件将包接收进来。
2. 接下来，转发模块会根据接收到的包的 IP 头部中记录的接收方 IP 地址，在路由表中进行查询，以此判断转发目标；
3. 然后，转发模块将包转移到转发目标对应的端口，端口再按照硬件的规则将包发送出去。
   - 也就是转发模块委托端口模块将包发送出去的意思。

##### 关于路由器工作原理的一些补充

端口模块会根据相应通信技术的规范来执行包收发的操作，这意味着端口模块是以实际的发送方或者接收方的身份来收发网络包的。  
  - 以以太网端口为例，路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；
  - 端口还具有IP 地址，从这个意义上来说，它和计算机的网卡是一样的；
  - 当转发包时，首先路由器端口会接收发给自己的以太网包，然后查询转发目标，再由相应的端口作为发送方将以太网包发送出去。
    - 这一点和交换机是不同的，交换机只是将进来的包转发出去而已，它自己并不会成为发送方或者接收方。

### 路由表中的信息

在“查表判断转发目标”这一点上，路由器和交换机的大体思路是类似的，不过具体的工作过程有所不同。  
  - 交换机是通过 MAC 头部中的接收方 MAC 地址来判断转发目标的；
  - 路由器则是根据 IP 头部中的 IP 地址来判断的；
  - 由于使用的地址不同，记录转发目标的表的内容也会不同。

路由器中的表叫作路由表，结构如下： 
 
|目标地址 ( Destination) |子网掩码 ( Netmask ) | 网关 ( Gateway ) | 接口 ( Interface ) | 跃点数 ( Metric ) |
|---|---|---|---|---|
| 10.10.1.0 | 255.255.255.0 | - | e2 | 1 |
|...|...|...|...|...|

最左侧的目标地址列记录的是接收方的信息。  
  - 实际上这里的 IP 地址只包含表示子网的网络号部分的比特值，而表示主机号部分的比特值全部为 0 ;
  - 路由器会将接收到的网络包的接收方IP地址与路由表中的目标地址进行比较，并找到相应的记录。
    - 交换机在地址表中只匹配完全一致的记录;
    - 而路由器则会忽略主机号部分，只匹配网络号部分;
    - 打个比方，路由器在转发包的时候只看接收方地址属于哪个区，×× 区发往这一边，×× 区发往那一边。
在匹配地址的过程中，路由器需要知道网络号的比特数，因此路由表中还有一列子网掩码，通过子网掩码就可以判断出网络号的比特数。  

接下来在子网掩码的右边还有网关和接口两列，它们表示网络包的转发目标。  
根据目标地址和子网掩码匹配到某条记录后，路由器就会将网络包交给接口列中指定的网络接口（即端口），并转发到网关列中指定的 IP 地址。  

最后一列是跃点计数，它表示距离目标IP 地址的距离是远还是近。这个数字越小，表示距离目的地越近；数字越大，表示距离目的地越远。  

#### 路由表记录维护方式

路由表记录维护的方式和交换机也有所不同。  
  - 交换机中对MAC 地址表的维护是包转发操作中的一个步骤；
  - 路由器中对路由表的维护是与包转发操作相互独立的。
    - 也就是说，在转发包的过程中不需要对路由表的内容进行维护。

对路由表进行维护的方法有几种，大体上可分为以下两类：  
1. 由人手动维护路由记录；
2. 根据路由协议机制，通过路由器之间的信息交换由路由器自行维护路由表的记录。
   - 路由协议有很多种，例如 RIP、OSPC、BGP 等都属于路由协议。

#### 路由器工作时的一些例外

路由聚合会将几个子网合并成一个子网，并在路由表中只产生一条记录。  
  - 这会导致地址本身的子网掩码和路由表中的子网掩码是不一致的。  

比如：  
我们现在有 3 个子网，分别为 10.10.1.0/24、10.10.2.0/24、10.10.3.0/24 ，路由器 B 需要将包发往这 3 个子网；  
在这种情况下，路由器 B 的路由表中原本应该有对应这 3 个子网的 3 条记录；  
但在这个例子中，无论发往任何一个子网，都能通过路由器 A 来进行转发；  
因此我们可以在路由表中将这 3 个子网合并成 10.10.0.0/16，这样也可以正确地进行转发，但我们减少了路由表中的记录数量，这就是路由聚合；  
经过路由聚合，多个子网会被合并成一个子网，子网掩码会发生变化，同时，目标地址列也会改成聚合后的地址。  

还有另外一些情况，如将一个子网进行细分并注册在路由表中，然后拆分成多条记录。  

从结果上看，路由表的子网掩码列只是用来在匹配目标地址时告诉路由器应该匹配多少个比特。  
而且，目标地址中的地址和实际子网的网络号可能并不完全相同，但即便如此，路由器依然可以正常工作。  

此外，通过上述方法，我们也可以将某台具体计算机的地址写入路由表中，这时的子网掩码为 255.255.255.255，也就是说地址中的全部 32 个比特都为 1 。  
这样一来，主机号部分比特全部为 0 可以表示一个子网，主机号部分比特不全部为 0 可以表示某一台计算机，两种情况可以用相同的规则来处理。  
（这段没看懂）  

该看166页了




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































